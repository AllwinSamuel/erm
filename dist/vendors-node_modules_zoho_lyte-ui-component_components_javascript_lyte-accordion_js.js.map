{"version":3,"file":"vendors-node_modules_zoho_lyte-ui-component_components_javascript_lyte-accordion_js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAtmBA;AAAA;;AAAA;;;;;;;;;;AAymBA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA5FA;;AA+FA;;;AAGA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AA9BA;;AAiCA;;;AAGA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAjCA;;AAoCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlnCA","sources":["webpack://erm/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-accordion.js"],"sourcesContent":["import { prop } from \"@slyte/core\";\nimport { Component, LyteUiComponentComponentRegistry } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n/**\n * Renders an accordion\n * @component lyte-accordion\n * @version 1.0.0\n * @methods onChanged,onOpen,onClose,onBeforeClose,onBeforeOpen,afterRender\n */\n\nclass LyteAccordionComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    data() {\n\t\treturn {\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropDuration=0.2s\n\t\t\t * @suffix s,ms\n\t\t\t */\n\n\t\t\t'ltPropDuration': prop( 'string', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'duration', '0.2s' ) \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {string} ltPropHeight\n\t\t\t * @suffix px,pt,cm,mm,vh,vm,em\n\t\t\t */\n\n\t\t\t'ltPropHeight': prop( 'string' ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropExclusive=true\n\t\t\t */\n\n\t\t\t'ltPropExclusive': prop( 'boolean', { \n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'exclusive', true ) \n\t\t\t} ),\n\n\t\t\t'ltPropYield': prop( 'boolean', { \n\t\t\t\t'default': true \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropDynamic=false\n\t\t\t * @version 2.2.0\n\t\t\t */\n\n\t\t\t'ltPropDynamic': prop( 'boolean', {\n\t\t\t\t'default': window._lyteUiUtils.resolveDefaultValue( 'lyte-accordion', 'dynamic', true ) \n\t\t\t} ),\n\n\t\t\t/**\n\t\t\t * @componentProperty {boolean} ltPropNested=false\n\t\t\t * @version 3.12.0\n\t\t\t */\n\n\t\t\t'ltPropNested': prop( 'boolean', {\n\t\t\t\t'default': false\n\t\t\t} ),\n\n\t\t\t'ltPropPreventAutoScroll': prop( 'boolean', {\n\t\t\t\t'default': false\n\t\t\t} )\n\t\t};\n\t}\n\n    toggleCurrentPanel(header) {\n\t\theader.click();\n\t}\n\n    execAndCheck(name, event) {\n\t\tvar arg, ret;\n\n\t\targ = window._lyteAccordion.findProperParent( event.target ).parentElement;\n\t \tret = this.executeMethod( name, event, arg, this );\n\t \tret = ret == undefined ? true : ret;\n\t \treturn ret;\n\t}\n\n    initiateClose(activeElement, cb, event) {\n\t\tvar accordionItem = activeElement.parentElement,\n\t\theader = accordionItem.querySelector( 'lyte-accordion-header' ),\n\t\tisImmediate = accordionItem._immediate;\n\n\t\tif( !isImmediate ) {\n\t\t\t// Requires two rAFs to do this which is totally weird - https://jsfiddle.net/6dLnwyef/1/\n\t\t\twindow.requestAnimationFrame( function() {\n\t\t\t\tactiveElement.style.height = activeElement.getBoundingClientRect().height + 'px';\n\t\t\t\twindow.requestAnimationFrame( function() {\n\t\t\t\t\tactiveElement.style.height = '0px';\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\tthis.closeImmediately( activeElement );\n\t\t}\n\t\t\n\t\t\t\n\t\tactiveElement.style.overflow = 'hidden';\t\n\t\tactiveElement._close = true;\n\t\tactiveElement.parentElement.classList.remove( 'lyteAccordionActive' );\n\t\theader.setAttribute( 'aria-expanded', 'false' );\n\t\tactiveElement.setAttribute( 'aria-hidden', 'true' );\n\n\t\tif( cb ) {\n\t\t\tcb.call( this, event );\n\t\t}\n\t}\n\n    closeImmediately(accordionBody) {\n\n\t\taccordionBody.style.transitionDuration = '0s';\n\t\taccordionBody.style.height = '0px';\n\t\tthis.doAfterCloseWork( accordionBody );\n\t\t// TODO: Find a way to add onAfterClose callback\n\t\t// this.execNonRetCalls( [ 'onAfterClose', this ] );\n\t}\n\n\tdoAfterCloseWork( accordionBody ) {\n\t\taccordionBody.classList.add( 'lyteAccordionBodyHide' );\n\t}\n\n\n    execNonRetCalls(arr) {\n\t\tif( this.getMethods( arr[ 0 ] ) ) {\n\t\t\tthis.executeMethod.apply( this, arr );\n\t \t}\n\t}\n\n    isVisible(item) {\n\t\treturn !!( item.offsetWidth || item.offsetHeight || item.getClientRects().length );\n\t}\n\n    scrollIntoView(body) {\n\t\tvar isVisible = body && this.isVisible( body );\n\n\t\tif( !isVisible || !body ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tvar height = this.$node.getBoundingClientRect().height, \n \t\tscrollTop = this.$node.scrollTop,\n \t\tvisibleBound = scrollTop + height,\n \t\toffTop = body.offsetTop,\n \t\tmap = body.getAttribute( 'map' ),\n \t\telemBound = offTop + body.getBoundingClientRect().height, id,\n \t\tpreventAutoScroll = this.getData( 'ltPropPreventAutoScroll' );\n\n \t\tif( visibleBound < elemBound && !preventAutoScroll ) {\n \t\t\tthis.$node.scrollTop = this.$node.scrollTop + ( elemBound - visibleBound );\n \t\t}\n\n \t\tid = window.requestAnimationFrame( this.scrollIntoView.bind( this, body ) );\n \t\tthis.$addon.objectUtils( this.getData( 'rAFMap' ), 'add', map, id );\n\t}\n\n    dynamic(body) {\n\t\t/**\n\t\t * body is definitely defined over here\n\t\t *\n\t\t */\n\n\t\tvar final;\n\n\t\tbody.style.height = 'auto';\n\t\t// Issue in CRM - opening the accordion caused flickering\n\t\tbody.style.opacity = '0';\n\t\tfinal = body.getBoundingClientRect().height;\n\n\t\t// This requires two rAFs just like initiateClose. Dk why -> https://jsfiddle.net/6dLnwyef/2/\n\t\twindow.requestAnimationFrame( function() {\n\n\t\t\t/**\n\t\t \t * Gotta put it inside a rAF else it just joins the previous 0px and the \n\t\t \t * current final height So the transition looks like auto -> final instead of 0 -> final\n\t\t \t *\n\t\t \t */\n\n\t\t \tbody.style.height = '0px';\n\t\t \tbody.style.opacity = '1';\n\t\t\twindow.requestAnimationFrame( function() {\n\t\t\t\tbody.style.height = final + 'px';\n\t\t\t} );\n\n\t\t} )\n\t\t\n\n\t\t\n\t}\n\n    static(sibling, configuration) {\n\n\t\t/**\n\t\t * The sibling is definitely always present\n\t\t *\n\t\t */\n\n\t\tvar heightToSet = configuration.height;\n\n\t\tif( this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].conf \n\t \t\t&& heightToSet \n\t \t) {\n\t \t\tsibling.style.height = heightToSet;\n\t \t}\n\t \telse {\n\t \t\tsibling.style.height = this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].height;\n\t \t}\n\t}\n\n    calculate(sibling, configuration) {\n\t\tvar dynamic = this.getData( 'ltPropDynamic' );\n\t \t\n\t\tthis.doBeforeOpenWork( sibling );\n\n\t\tif( dynamic ) {\n\t\t\tthis.dynamic( sibling );\n\t\t}\n\t\telse {\n\t\t\tthis.static( sibling, configuration );\n\t\t}\n\t}\n\n\tdoBeforeOpenWork( accordionBody ) {\n\t\taccordionBody.classList.remove( 'lyteAccordionBodyHide' );\n\t\taccordionBody.parentElement.classList.add( 'lyteAccordionActive' );\n\t}\n\n\n    initiateOpen(sibling, configuration, event) {\n\t\tvar ret;\n\n\t\tthis.calculate( sibling, configuration );\n\t \tsibling._close = false;\n\t \tsibling.style.overflow = 'hidden';\n\t \tsibling.parentElement.classList.add( 'lyteAccordionActive' );\n\t \tret = window._lyteAccordion.findProperParent( event.target );\n\t \tret.setAttribute( 'aria-expanded', 'true' );\n\t \tsibling.setAttribute( 'aria-hidden', 'false' );\n\t \t\n \t\tthis.scrollIntoView( sibling );\n\t\tthis.execNonRetCalls( [  'onOpen', event, ret.parentElement, this ] );\n\t\tthis.execNonRetCalls( [ 'onChanged', event, ret.parentElement, this ] );\n\t \t\t\n\t}\n\n    didDestroy() {\n\t\tvar allNodes = this.$node.querySelectorAll( 'lyte-accordion-item' ), i = 0, curValue;\n\n\t\tfor( ; i < allNodes.length; i++ ) {\n\t\t\tcurValue = allNodes[ i ].getAttribute( 'lyte-shortcut' );\n\t\t\tif( curValue ) {\n\t\t\t\tallNodes[ i ].setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );\n\t\t\t}\n\t\t}\n\t}\n\n    cancelFrame(body, event) {\n\n\t\tif( event.target !== body ) {\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tvar map = body.getAttribute( 'map' ),\n\t\tclose = body._close,\n\t\tdynamic = this.getData( 'ltPropDynamic' );\n\n\t\twindow.cancelAnimationFrame( this.getData( 'rAFMap' )[ map ] );\n\t\tbody.style.overflow = close ? 'hidden' : 'auto';\n\n\t\tif( dynamic && !close ) {\n\t\t\tbody.style.height = 'auto';\n\t\t}\n\n\t\twindow.clearTimeout( body._callbackId );\n\n\t\tbody._callbackId = setTimeout( function() {\n\t\t\tif( close ) {\n\t\t\t\tthis.execNonRetCalls( [ 'onAfterClose', this ] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.execNonRetCalls( [ 'onAfterOpen', this ] );\n\t\t\t}\n\t\t}.bind( this ), 100 );\n\n\t\tif( close ) {\n\t\t\tthis.doAfterCloseWork( body );\n\t\t}\n\n\t}\n\n    setEvent(body) {\n\t\tif( body ) {\n\t\t\tbody.addEventListener( 'transitionend', this.cancelFrame.bind( this, body ) );\n\t\t}\n\t}\n\n    calculateHeight(body, index) {\n\t\tvar isStyle = body.style.height;\n\n\t\tthis.getData( 'heights' )[ index ] = {};\n\n\t\tif( !isStyle ) {\n\t\t\tthis.getData( 'heights' )[ index ].height = body.getBoundingClientRect().height - parseFloat( window.getComputedStyle( body ).paddingTop ) - parseFloat( window.getComputedStyle( body ).paddingBottom ) + 'px';\n\t\t\tthis.getData( 'heights' )[ index ].conf = true;\n\t\t}\n\t\telse {\n\t\t\tthis.getData( 'heights' )[ index ].height = isStyle;\n\t\t\tthis.getData( 'heights' )[ index ].conf = false;\n\t\t}\n\t}\n\n    getYieldElement() {\n\t\tvar item = this.$node.querySelector( 'lyte-accordion-item' ),\n\t\tres;\n\n\t\tif( item ) {\n\t\t\tres = item.parentElement;\n\t\t}\n\n\t\treturn res || this.$node.querySelector( 'lyte-yield' );\n\t}\n\n    readHeights() {\n\t\tif( !this.$node ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tvar node = this.getYieldElement(), \n\t\tnodes = node.children, i = 0, body,\n\t\tdynamic = this.getData( 'ltPropDynamic' );\n\n\t\tfor( ; i < nodes.length; i++ ) {\n\t\t\tif( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbody = nodes[ i ].querySelector( 'lyte-accordion-body' );\n\t\t\tif( !body ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.setEvent( body );\n\t\t\t// For now it looks like all the accordion-items must be specified at the start\n\t\t\tif( !dynamic ) {\n\t\t\t\tthis.calculateHeight( body, i );\n\t\t\t}\n\n\t\t\tif( \n\t\t\t\tnodes[ i ].classList.contains( 'lyteAccordionActive' ) \n\t\t\t\t&& this.getData( 'ltPropExclusive' ) \n\t\t\t) {\n\t\t\t\tthis.flag = i;\n\t\t\t}\n\t\t}\n\t}\n\n    maintainHeightOrder(body, index) {\n\t\tvar dynamic = this.getData( 'ltPropDynamic' );\n\n\t\t/* When setting height transitionend was fired in safari but not in other browsers */\n\t\tbody._close = false;\n\t\tbody.style.height = dynamic ? \n\t\t\t\t\t\t\t\t'auto' : \n\t\t\t\t\t\t\t\t!this.getData( 'heights' )[ index ].conf ? \n\t\t\t\t\t\t\t\t\tthis.getData( 'heights' )[ index ].height :\n\t\t\t\t\t\t\t\t\tthis.getData( 'ltPropHeight' ) ? \n\t\t\t\t\t\t\t\t\t\tthis.getData( 'ltPropHeight' ) : \n\t\t\t\t\t\t\t\t\t\tthis.getData( 'heights' )[ index ].height\n\t}\n\n    writeHeights() {\n\t\tif( !this.$node ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tvar node = this.getYieldElement(), nodes = node.children,\n\t\texclusive = this.getData( 'ltPropExclusive' ), i = 0, body, header, ariaValue;\n\n\t\tfor( ; i < nodes.length; i++ ) {\n\t\t\tif( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbody = nodes[ i ].querySelector( 'lyte-accordion-body' );\n\t\t\tif( !body ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// No point setting this for dynamic but we are letting it go for now\n\t\t\t// because we may want to introduce an attribute to open the accordion from\n\t\t\t// the html\n\t\t\tbody.setAttribute( 'map', i );\n\n\t\t\tif( !nodes[ i ].classList.contains( 'lyteAccordionActive' ) ) {\n\t\t\t\t/* When setting height transitionend was fired in safari but not in other browsers */\n\t\t\t\tbody._close = true;\n\t\t\t\tbody.style.height = '0px';\n\t\t\t}\n\t\t\telse if( exclusive ) {\n\t\t\t\tif( this.flag != i ) {\n\t\t\t\t\t/* When setting height transitionend was fired in safari but not in other browsers */\n\t\t\t\t\tbody._close = true;\n\t\t\t\t\tnodes[ i ].classList.remove( 'lyteAccordionActive' );\n\t\t\t\t\tbody.style.height = '0px';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Doing this to achieve this precedence: inline style > ltPropHeight > boundingClientRect\n\t\t\t\t\tthis.maintainHeightOrder( body, i );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.maintainHeightOrder( body, i );\n\t\t\t}\n\n\t\t\theader = window._lyteAccordion.findHeader( body );\n\n\t\t\tif( header ) {\n\t\t\t\theader.setAttribute( 'aria-expanded', !body._close );\n\t\t\t}\n\n\t\t\tbody.setAttribute( 'aria-hidden', !!body._close );\n\n\t\t\tif( body._close ) {\n\t\t\t\tbody.classList.add( 'lyteAccordionBodyHide' );\n\t\t\t}\n\n\t\t}\n\n\t\tthis.didConnectCalled = true;\n\t}\n\n    executeAfterRender() {\n\t\tif( !this.$node ) {\n\t\t\treturn ;\n\t\t}\n\t\tthis.execNonRetCalls( [ 'afterRender', this ] );\n\t}\n\n    attachScrolls(item) {\n\t\tif( !this.$node ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tvar node = this.getYieldElement(), nodes = item ? [ item ] : node.children,\n\t\ti = 0, body;\n\n\t\tfor( ; i < nodes.length; i++ ) {\n\t\t\tif( nodes[ i ].tagName !== 'LYTE-ACCORDION-ITEM' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbody = nodes[ i ].querySelector( 'lyte-accordion-body' );\n\t\t\tif( !body ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbody.style.overflow = 'auto';\n\t\t}\n\t}\n\n    getAllHeights() {\n\t\tthis.setData( 'heights', {} );\n\n\t\t// A hack to make sure our attachScrolls happens before readHeights\t\n\t\t$L.fastdom.measure( this.attachScrolls, this );\n\t\t$L.fastdom.measure( this.readHeights, this );\n\t\t$L.fastdom.mutate( this.writeHeights, this );\n\t\t$L.fastdom.measure( this.executeAfterRender, this );\n\t\t\n\t}\n\n    didConnect() {\n\t\tthis.setData( 'rAFMap', {} );\t\t\n\t\tthis.getAllHeights()\n\t}\n\n    initializeItem(item) {\n\t\tthis.flag = undefined;\n\n\t\tif( !this.getData( 'rAFMap' ) ) {\n\t\t\tthis.setData( 'rAFMap', {} );\n\t\t}\n\n\t\tthis.attachScrolls( item );\n\t\tthis.readItemHeight( item );\n\t\tthis.writeItemHeight( item );\n\n\t}\n\n    readItemHeight(item) {\n\t\tvar index = this.getItemIndex( item ),\n\t\tdynamic = this.getData( 'ltPropDynamic' ),\n\t\tbody = item.querySelector( 'lyte-accordion-body' );\n\n\t\tif( !body ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tthis.setEvent( body );\n\t\t// For now it looks like all the accordion-items must be specified at the start\n\t\tif( !dynamic ) {\n\t\t\tthis.calculateHeight( body, index );\n\t\t}\n\n\t\t// if( \n\t\t// \titem.classList.contains( 'lyteAccordionActive' ) \n\t\t// \t&& this.getData( 'ltPropExclusive' ) && this.isAlreadyOpen()\n\t\t// ) {\n\t\t// \tthis.flag = index;\n\t\t// }\n\t}\n\n    writeItemHeight(item) {\n\t\tvar body = item.querySelector( 'lyte-accordion-body' ),\n\t\tindex = this.getItemIndex( item ),\n\t\texclusive = this.getData( 'ltPropExclusive' ),\n\t\topenAccordion;\n\n\t\tif( !body ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tbody.setAttribute( 'map', index );\n\n\t\tif( !item.classList.contains( 'lyteAccordionActive' ) ) {\n\t\t\t/* When setting height transitionend was fired in safari but not in other browsers */\n\t\t\tbody._close = true;\n\t\t\tbody.style.height = '0px';\n\t\t}\n\t\t// else if( exclusive ) {\n\t\t// \t// if( this.flag != index ) {\n\t\t// \t\t/* When setting height transitionend was fired in safari but not in other browsers */\n\t\t// \t\tbody._close = true;\n\t\t// \t\titem.classList.remove( 'lyteAccordionActive' );\n\t\t// \t\tbody.style.height = '0px';\n\t\t// \t// }\n\t\t// \t// else {\n\t\t// \t// \t// Doing this to achieve this precedence: inline style > ltPropHeight > boundingClientRect\n\t\t// \t// \tthis.maintainHeightOrder( body, index );\n\t\t// \t// }\n\t\t// }\n\t\telse /* if( !exclusive ) */ {\n\t\t\tif( exclusive ) {\n\t\t\t\topenAccordion = this.getOpenAccordion();\n\n\t\t\t\tif( openAccordion ) {\n\t\t\t\t\topenAccordion.close();\n\t\t\t\t}\n\n\t\t\t\tthis.maintainHeightOrder( body, index );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.maintainHeightOrder( body, index );\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n    getOpenAccordion() {\n\t\tvar items = this.getYieldElement().children,\n\t\tbody;\n\n\t\tfor( var i = 0; i < items.length; i++ ) {\n\t\t\tbody = items[ i ].querySelector( 'lyte-accordion-body' )\n\t\t\tif( body && body._close === false  ) {\n\t\t\t\treturn items[ i ];\n\t\t\t}\n\t\t}\n\t}\n\n    isAlreadyOpen() {\n\t\tvar items = this.getYieldElement().children,\n\t\tbody;\n\n\t\tfor( var i = 0; i < items.length; i++ ) {\n\t\t\tbody = items[ i ].querySelector( 'lyte-accordion-body' )\n\t\t\tif( body && body._close === false  ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n    getItemIndex(item) {\n\t\tvar index = 0;\n\n\t\twhile( item.previousElementSibling ) {\n\t\t\titem = item.previousElementSibling;\n\n\t\t\tif( item.tagName === 'LYTE-ACCORDION-ITEM' ) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n    getConfiguration() {\n\t\tvar config = {};\n\t\t\n\t\tconfig.transition = this.getData( 'ltPropDuration' )\n\t\tconfig.height = this.getData( 'ltPropHeight' )\n\t\tconfig.exclusive = this.getData( 'ltPropExclusive' )\n\t\treturn config;\n\t}\n\n    static observers() {\n        return {\n            nestedClassObserver: function() {\n                var accordion = this.$node,\n                nested = this.getData( 'ltPropNested' );\n\n                if( nested ) {\n                    accordion.classList.add( 'lyteAccordionNested' );\n                }\n                else {\n                    accordion.classList.remove( 'lyteAccordionNested' );\n                }\n            }.observes( 'ltPropNested' ).on( 'didConnect' )\n        };\n    }\n}\n\nwindow._lyteAccordion = {\n\n\t_lyteAccordionHeaderID: 0,\n\n\t_lyteAccordionBodyID: 0,\n\n\tgenerateHeaderID: function() {\n\t\treturn 'lyte_accordion_header_' + _lyteAccordion._lyteAccordionHeaderID++;\n\t},\n\n\tgenerateBodyID: function() {\n\t\treturn 'lyte_accordion_body_' + _lyteAccordion._lyteAccordionBodyID++;\n\t},\n\n\tfindHeader: function( body ) {\n\t\twhile( body \n\t\t\t&& body.tagName !== 'LYTE-ACCORDION-HEADER' \n\t\t) {\n\t\t\tbody = body.previousElementSibling;\n\t\t}\n\n\t\treturn body;\n\t},\n\n\tfindProperParentS: function( elm ) {\n\t\tvar properparent, stack = [], found = false, i;\n\n\t\twhile( elm.tagName != \"LYTE-YIELD\" && elm.tagName != 'HTML' ) {\n\t\t\tproperparent = elm;\n\t\t\tstack.push( elm );\n\t\t\telm = elm.parentElement;\n\n\t\t\t// Clicking on a node and it gets detached by one of the bottom event listeners before it comes here\n\t\t\tif( !elm ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tfor( i = stack.length - 1; i > -1; i-- ) {\n\t\t\tif( stack[ i ].tagName === 'LYTE-ACCORDION-HEADER' \n\t\t\t\t|| ( stack.length === 1 && stack[ i ].tagName === 'LYTE-ACCORDION-ITEM' ) \n\t\t\t) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( !found ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// May need to add a check here\n\t\treturn properparent.children[ 0 ];\n\n\t},\n\n\tfindProperParent: function( element ) {\n\t\tvar properparent;\n\n\t\tif( !element ) {\n\t\t\treturn ;\n\t\t}\n\n\t\twhile( element.tagName != \"LYTE-YIELD\" && element.tagName != 'HTML' ) {\n\t\t\tproperparent = element;\n\t\t\telement = element.parentElement;\n\n\t\t\t// Clicking on a node and it gets detached by one of the bottom event listeners before it comes here\n\t\t\tif( !element ) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\t\t// May need to add a check here\n\t\tif( ( properparent.children[ 0 ] || {} ).tagName === 'LYTE-ACCORDION-HEADER' ) {\n\t\t\treturn properparent.children[ 0 ];\n\t\t}\n\n\t}\n};\n\ndocument.addEventListener( 'click', function( event ) {\n\tvar elementClicked = _lyteAccordion.findProperParentS( event.target ), \n\tparent, temp, childs, flag, i = 0, sibling, component, configuration, transition,\n\topenElement, bodyElement, returnval, itsStyle, activeElement;\n\n\tif( !elementClicked ) {\n\t\treturn ;\n\t}\n\n\tparent  = elementClicked;\n\n\twhile(\n\t\tparent.tagName != 'HTML' \n\t\t&& parent.tagName != 'LYTE-ACCORDION'\n\t) {\n\t\tparent = parent.parentElement;\n\n\t\tif( !parent ) {\n\t\t\treturn ;\n\t\t}\n\t}\n\n\t// This is a safety check because it is generally guaranteed to be a LYTE-ACCORDION Element\n\tif( parent.tagName == 'HTML' ) {\n\t\treturn ;\n\t}\n\n\ttemp  = parent.querySelector( 'lyte-accordion-item' ).parentElement || parent.querySelector( 'lyte-yield' );\n\tchilds = temp.children;\n\tflag = true;\n\n\t// why is this here??\n\tfor( ; i < childs.length; i++ ) {\n\t\tif( childs[ i ].querySelector( 'lyte-accordion-header' ) == elementClicked ) {\n\t\t\tflag = false\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( flag ) {\n\t\treturn ;\n\t}\n\n\t/* sibling - The lyte-accordion-body tag of current clicked accordion item */\n\n\tsibling = temp.children[ i ].querySelector( 'lyte-accordion-body' );\n\tcomponent = temp.closest( 'lyte-accordion' ).component;\n\tconfiguration = component.getConfiguration();\n\ttransition = configuration.transition;\n\n\t/* When they haven't provided a lyte-accordion-body tag */\n\tif(\n\t\t!sibling \n\t\t|| sibling.tagName != 'LYTE-ACCORDION-BODY'\n\t) {\n\t\t// Close accordion\n \t\tif( \n \t\t\tconfiguration \n \t\t\t&& configuration.exclusive \n \t\t\t&& ( openElement = component.getOpenAccordion() )\n \t\t\t&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) )\n \t\t ) {\n \t\t\t\n \t\t\tbodyElement.style.transitionDuration = transition;\n \t\t\tif( component.getMethods( 'onBeforeClose' ) ) {\n \t\t\t\treturnval = component.execAndCheck( 'onBeforeClose', event );\n\t \t\t\tif( returnval ){\n\t \t\t\t\tcomponent.initiateClose( bodyElement, function( e ) {\n\t \t\t\t\t\tthis.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );\n\t \t\t\t\t}, event );\n\t \t\t\t}\n\t \t\t\telse {\n\t \t\t\t\treturn ;\n\t \t\t\t} \t\t\t\n\t \t\t}\n\t \t\telse {\n\t \t\t\tcomponent.initiateClose( bodyElement, function( e ) {\n\t \t\t\t\tthis.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );\n\t \t\t\t}, event );\t\t\n\t \t\t}\n \t\t}\n\n\n \t\tif( temp.children[ i ].classList.contains( 'lyteAccordionActive' ) ) {\n \t\t\ttemp.children[ i ].classList.remove( 'lyteAccordionActive' )\n \t\t}\n \t\telse {\n \t\t\ttemp.children[ i ].classList.add( 'lyteAccordionActive' )\n \t\t}\n\n \t\t$L.fastdom.measure( function() {\n \t\t\tcomponent.execNonRetCalls( [ 'onChanged', event, _lyteAccordion.findProperParent( event.target ).parentElement, component ] );\n \t\t} )\n \t\t\n\t\treturn ;\n\t}\n\n\titsStyle = window.getComputedStyle( sibling ).height;\n \tif( transition ) {\n \t\tsibling.style.transitionDuration = transition;\n\n \t\t// Added so that it slides the first time as well\n \t\tif( ( openElement = component.getOpenAccordion() )\n \t\t\t&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) ) ) {\n \t\t\t \tbodyElement.style.transitionDuration = transition;\n \t\t}\n \t}\n\n \tactiveElement = component.getOpenAccordion();\n\n \t// Close the already opened accordion-item in exclusive accordion. \n\tif( \n\t\tconfiguration \n\t\t&& configuration.exclusive \n\t\t&& activeElement \n\t\t&& activeElement != sibling.parentElement\n\t) {\t\n\t\tif( \n\t\t\t( bodyElement = activeElement.querySelector( 'lyte-accordion-body' ) )\n\t\t\t&& component.getMethods( 'onBeforeClose' ) \n\t\t) {\n\t\t\treturnval = component.execAndCheck( 'onBeforeClose', event );\n\t \t\tif( returnval ) {\n\t \t\t\tcomponent.initiateClose( bodyElement, function( e ) {\n\t \t\t\t\tthis.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );\n\t \t\t\t}, event );\n\t \t\t}\n\t \t\telse {\n\t \t\t\treturn ;\n\t \t\t} \t\t\t\n\t\t}\n\t \telse if( ( bodyElement = activeElement.querySelector( 'lyte-accordion-body' ) ) ) {\n\t \t\tcomponent.initiateClose( bodyElement, function( e ) {\n\t \t\t\tthis.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );\n\t \t\t}, event );\n\t \t}\n\n\t \t// If the element has no bodyelement you still need to remove it.\n \t\tif( activeElement.classList.contains( 'lyteAccordionActive' ) ) {\n \t\t\tactiveElement.classList.remove( 'lyteAccordionActive' )\n \t\t}\n\t\t\n\t}\n\t\n\t// itsStyle.height = '0px' -> Meaning it is closed\n\tif( itsStyle == '0px' ) {\n\t \t\n\t \tif( component.getMethods( 'onBeforeOpen' ) ) {\n\t \t\treturnval = component.execAndCheck( 'onBeforeOpen', event );\n\n\t \t\t// Get configuration again incase user sets height in onBeforeOpen\n\t \t\tconfiguration = component.getConfiguration();\n\t \t\tif( returnval ) {\n\t \t\t\tcomponent.initiateOpen( sibling, configuration, event );\n\t \t\t}\n\t \t\telse {\n\t \t\t\treturn ;\n\t \t\t}\t \t\t\n\t \t}\n\t \telse {\n\t \t\tcomponent.initiateOpen( sibling, configuration, event );\n\t \t}\n\t }\n\n\t // It is opened so close it\n\t else {\n\t \tif( component.getMethods( 'onBeforeClose' ) ) {\n\t \t\treturnval = component.execAndCheck( 'onBeforeClose', event );\n\t \t\tif( returnval ) {\n\t \t\t\tcomponent.initiateClose( sibling, function( e ) {\n\t \t\t\t\tvar ret =  _lyteAccordion.findProperParent( e.target );\n\t \t\t\t\tthis.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );\n\t \t\t\t\tthis.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );\n\t \t\t\t}, event );\n\t \t\t}\n\t \t\telse{\n\t \t\t\treturn;\n\t \t\t}\n\t \t}\n\t \telse {\n\t \t\tcomponent.initiateClose( sibling, function( e ) {\n\t \t\t\tvar ret =  _lyteAccordion.findProperParent( e.target );\n\t \t\t\tthis.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );\n\t \t\t\tthis.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );\n\t \t\t}, event );\n\t \t}\n\t }\n}, true );\n\ndocument.addEventListener( 'keydown', function( event ) {\n\tvar keyCode = event.keyCode, header = document.activeElement,\n\taccordion = header, comp;\n\n\tif( header.tagName !== 'LYTE-ACCORDION-HEADER' ) {\n\t\treturn ;\n\t}\n\n\tif( keyCode === 13\n\t\t|| keyCode === 32\n\t) {\n\n\t\twhile( accordion\n\t\t\t&& accordion.tagName !== 'LYTE-ACCORDION'\n\t\t\t&& accordion.tagName !== 'HTML' \n\t\t) {\n\t\t\taccordion = accordion.parentElement;\n\t\t}\n\n\t\tif( accordion.tagName !== 'LYTE-ACCORDION' ) {\n\t\t\treturn ;\n\t\t}\n\n\t\tcomp = accordion.component;\n\t\tevent.preventDefault();\n\n\t\tswitch( keyCode ) {\n\t\t\tcase 13:\n\t\t\tcase 32:\n\t\t\t\tcomp.toggleCurrentPanel( header );\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n} );\n\n/**\n * @customElement lyte-accordion-item\n */\n/**\n * @customElement lyte-accordion-header\n */\n/**\n * @customElement lyte-accordion-body\n */\n\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-item' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-item' ] = true;\n\n    class LyteAccordionItemCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ 'lyte-shortcut' ]; \n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n            var that = lyteNode , comp = lyteNode;\n\n            if( lyteNode._hasConnectedCallbackFired ) {\n\t\t\t\treturn ;\n\t\t\t}\n\n            lyteNode._hasConnectedCallbackFired = true;\n\n            while(\n\t\t\t\tcomp.tagName != 'HTML' \n\t\t\t\t&& comp.tagName != 'LYTE-ACCORDION'\n\t\t\t) {\n\t\t\t\tcomp = comp.parentElement;\n\n\t\t\t\tif( !comp ) {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\n            // This is a safety check because it is generally guaranteed to be a LYTE-ACCORDION Element\n            if( comp.tagName == 'HTML' ) {\n\t\t\t\treturn ;\n\t\t\t}\n\n            comp = comp.component;\n\n            lyteNode.open = function() {\n\t\t\t\tif( !that.classList.contains( 'lyteAccordionActive' ) ) {\n\t\t\t\t\tthat.click();\n\t\t\t\t}\n\t\t\t}\n\n            lyteNode.close = function( immediate ) {\n\n\t\t\t\tthat._immediate = immediate;\n\n\t\t\t\tif( that.classList.contains( 'lyteAccordionActive' ) ) {\n\t\t\t\t\tthat.click();\n\t\t\t\t}\n\n\t\t\t\tthat._immediate = false;\n\t\t\t}\n\n            if( comp.didConnectCalled ) {\n\t\t\t\tcomp.initializeItem( lyteNode );\n\t\t\t}\n        }\n\n        attributeChangedCallback(attributeName, oldValue, newValue, namespace) {\n            var lyteNode = this.$node;\n            if( typeof window.shortcut == \"function\" ){\n\t         \tif( !newValue ) {\n\t            \treturn ;\n\t          \t}\n\n\t          \tnewValue = JSON.parse( newValue )\n\t          \tif( !newValue.key ){\n\t            \treturn ;\n\t          \t}\n\n\t          \tvar newKey = newValue.key, type = newValue.type, wait = newValue.wait;\n\t          \tif( !oldValue ){\n\t            \toldValue = {};\n\t          \t}\n\n\t          \twindow.shortcut.push( {\n\t            \tnewKey: newKey,\n\t            \ttype: type,\n\t            \twait: wait,\n\t            \toldKey: oldValue.key,\n\t            \tvalue: lyteNode\n\t         \t} )\n\t      \t}\n        }\n    }\n\n    LyteAccordionItemCustomElements.register(\"lyte-accordion-item\");\n}\n\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-header' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-header' ] = true;\n\n    class LyteAccordionHeaderCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ ];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n            var id = lyteNode.getAttribute( 'id' );\n\n            lyteNode.setAttribute( 'role', 'button' );\n\n            if( !lyteNode.hasAttribute( 'tabindex' ) ) {\n\t\t\t\tlyteNode.setAttribute( 'tabindex', '0' );\n\t\t\t}\n\n            if( !id ) {\n\t\t\t\tlyteNode.setAttribute( 'id', _lyteAccordion.generateHeaderID() );\n\t\t\t}\n        }\n    }\n\n    LyteAccordionHeaderCustomElements.register(\"lyte-accordion-header\");\n}\n\nif( !window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-body' ] ) {\n    window._lyteUiUtils.registeredCustomElements[ 'lyte-accordion-body' ] = true;\n\n    class LyteAccordionBodyCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ ];\n        }\n\n        connectedCallback() {\n            var lyteNode = this.$node;\n            var id = lyteNode.getAttribute( 'id' ), \n\t\t\thead = _lyteAccordion.findHeader( lyteNode );\n\n            lyteNode.setAttribute( 'role', 'region' );\n\n            if( !id ) {\n\t\t\t\tid = _lyteAccordion.generateBodyID();\n\t\t\t\tlyteNode.setAttribute( 'id', id );\n\t\t\t}\n\n            if( head ) {\n\t\t\t\thead.setAttribute( 'aria-controls', id );\n\t\t\t\tlyteNode.setAttribute( 'aria-labelledby', head.getAttribute( 'id' ) );\n\t\t\t}\n        }\n    }\n\n    LyteAccordionBodyCustomElements.register(\"lyte-accordion-body\");\n}\n\n/**\n * @syntax yielded\n * <lyte-accordion>\n *     <template is=\"registerYield\" yield-name=\"yield\">\n *         <lyte-accordion-item>\n *             <lyte-accordion-header>\n *                 HEADER 1\n *             </lyte-accordion-header>\n *             <lyte-accordion-body>\n *                 CONTENT 1\n *             </lyte-accordion-body>\n *         </lyte-accordion-item>\n *         <lyte-accordion-item>\n *             <lyte-accordion-header>\n *                 HEADER 2\n *             </lyte-accordion-header>\n *             <lyte-accordion-body>\n *                 CONTENT 2\n *             </lyte-accordion-body>\n *         </lyte-accordion-item>\n *     </template>\n * </lyte-accordion>\n */\nexport { LyteAccordionComponent };\n"],"names":[],"sourceRoot":""}