(self["webpackChunkerm"] = self["webpackChunkerm"] || []).push([["vendors-node_modules_zoho_lyte-ui-component_components_javascript_lyte-table_js"],{

/***/ 9543647:
/*!**********************************************************************************!*\
  !*** ./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-table.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LyteTableComponent": () => (/* binding */ LyteTableComponent)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/@slyte/core/index.js */ 76928134);
/* harmony import */ var _node_modules_zoho_lyte_ui_component_mixins_lyte_table_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-ui-component/mixins/lyte-table-utils.js */ 53716543);
/* harmony import */ var _node_modules_zoho_lyte_ui_component_mixins_lyte_table_sortable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-ui-component/mixins/lyte-table-sortable.js */ 38957034);
/* harmony import */ var _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-ui-component/components/component.js */ 40876002);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-dom/modules/lyte-dom-utils.js */ 92838254);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_zoho_lyte_ui_component_plugins_lyte_scrollbar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-ui-component/plugins/lyte-scrollbar.js */ 19998358);
/* harmony import */ var _node_modules_zoho_lyte_ui_component_plugins_lyte_scrollbar_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_zoho_lyte_ui_component_plugins_lyte_scrollbar_js__WEBPACK_IMPORTED_MODULE_5__);

var _ = {};

(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__._defineProperty)(_, {
    "prop": function() {
        return _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop;
    },

    "Component": function() {
        return _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__.Component;
    },

    "LyteUiComponentComponentRegistry": function() {
        return _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__.LyteUiComponentComponentRegistry;
    },

    "LyteTableSortableMixin": function() {
        return _node_modules_zoho_lyte_ui_component_mixins_lyte_table_sortable_js__WEBPACK_IMPORTED_MODULE_2__.LyteTableSortableMixin;
    },

    "LyteTableUtilsMixin": function() {
        return _node_modules_zoho_lyte_ui_component_mixins_lyte_table_utils_js__WEBPACK_IMPORTED_MODULE_3__.LyteTableUtilsMixin;
    }
});







/* @Slicer.otherframeworkStart */


class LyteTableComponent extends (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.includeMixins)([_node_modules_zoho_lyte_ui_component_mixins_lyte_table_utils_js__WEBPACK_IMPORTED_MODULE_3__.LyteTableUtilsMixin, _node_modules_zoho_lyte_ui_component_mixins_lyte_table_sortable_js__WEBPACK_IMPORTED_MODULE_2__.LyteTableSortableMixin], _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__.Component) {
    constructor() {
        super();
    }

    init() {
        var uA = window.navigator.userAgent,
        cb = "beforeRender",
        __this = this,
        $node = __this.$node,
        __window = window,
        add = "addEventListener",
        ns = '_tableResize';
        
        __this._dir = window._lyteUiUtils.getRTL();
        __this.isIE11Lyte = /rv:11/ig.test( uA );
        __this.isEdgeLyte = /Edge/ig.test( uA );
        __this._browser = __this.isIE11Lyte || __this.isEdgeLyte || uA.match( 'Safari' );

        /**
         * @method beforeRender
         * @version 1.0.1
         */

        __this.getMethods( cb ) && __this.executeMethod( cb, $node );

        /**
         * @utility scrollTable
         * @version 1.0.4
         */

        $node.scrollTable = function( x, y ){
            var scrollElem = ( __this.scrollDiv = __this.scrollDiv || $node.querySelector( 'div.lyteTableScroll' ) ),
            undef = void 0,
            evt = new Event( 'scroll', { bubbles: true } );

            if( x != undef ){
                scrollElem.scrollLeft = x;
            }

            if( y != undef ){
                scrollElem.scrollTop = y;
            }

            evt._byFunc = true;
            scrollElem.dispatchEvent( evt );

            if( !__this.__from_collapse ){
                __this.update_collapse( true );
            }
        }
        /**
         * @utility updateCollapse
         * @version 3.92.0
         */
        $node.updateCollapse = __this.update_collapse.bind( __this );

        if( !__window[ ns ] ){
            __window[ ns ] = true;

            var fn = window.resizeTable;

            __window[ add ]( 'resize', fn, true );
            __window[ add ]( 'orientationchange', fn, true );
        }

        /**
         * @utility toggleRows
         * @version 1.0.3
         */

         $node.toggleRows = function( val ){
            var name = val ? 'remove' : "add",
            __tags = this.ltProp('tags');

            Array.from( this.querySelectorAll( __tags.tbody + ' ' + __tags.tr + '.lytePreventInfiniteScroll' ) ).forEach( function( item ){
                item.classList[ name ]( 'lyteHidden' );
            });
         }

    }

    rtlfunc(lft, bcr, ww) {
        if( this._dir && lft != 'top' && lft != 'clientY' ){
            if( bcr ){
                if( lft == 'right' ){
                    return ww - bcr.left;
                } else if( lft == 'clientX' ){
                    return ww - bcr[ lft ];
                }
                return ww - bcr.right;
            } else if( lft == 'left' ){
                return 'right';
            } else if( lft == "right" ){
                return "left";
            }
        }
        return bcr ? bcr[ lft ] : lft;
    }

    didDestroy() {
        var __this = this,
        __data = __this.data,
        scrolldiv = __this.scrollDiv,
        $node = __this.$node,
        _window = window,
        iso = __this._intersectionObs;

        if( _window._tableResize && document.body.getElementsByTagName( 'lyte-table' ).length == 0 ){
            var rel = "removeEventListener";

            _window[ rel ]( 'resize', window.resizeTable, true );
            _window[ rel ]( 'orientationchange', window.resizeTable, true );

            delete _window._tableResize;
        }

        if( __data.ltPropNavigation ){
           window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __data.ltPropTags.table )[ 0 ], 'unbind' );
        }

        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.clear( this.__collpse_fdom );
        delete this.__collpse_fdom;

        if( iso ){
            __this._setmeasure && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.clear( __this._setmeasure );
            iso.disconnect();

            delete __this.reset;
            delete __this._intersectionObs;
            delete __this._intersections;
        }

        !__data.ltPropPreventScrollbar && scrolldiv && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( scrolldiv ).removeScroll();

        delete __this.scrollDiv; delete __this._dummy; delete __this._dummy1; delete __this.resizeComponent; delete __this.targetElem; delete __this._dummyTr;
        delete $node.setValue; delete $node.scrollTable;
    }

    didConnect() {
        var __data = this.data,
        ltPropInfiniteScroll = __data.ltPropInfiniteScroll, 
        secData = __data.secondaryData,
        // ltPropResize = __data.ltPropResize,
        $node = this.$node,
        __tags = __data.ltPropTags;

        // if( __data.ltPropYield && (ltPropResize.vertical || ltPropResize.horizontal)) {
        //     this.resizeComponentAppend();
        // }
        try {
            var scrollDiv = $node.querySelector('div.lyteTableScroll');
            // scrollDiv._overlay = scrollDiv.getElementsByTagName( 'lyte-overlaydiv' )[ 0 ];
            this.scrollDiv = scrollDiv;
            scrollDiv.comp = this;
            scrollDiv._infiniteScroll = ltPropInfiniteScroll;
            if ( !__data.ltPropPreventScrollbar && (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().prototype.scroll) ) {
                _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()(scrollDiv).scroll( __data.ltPropScrollbarOption);
                var scrollbar = $node.querySelector('.lyteScrollContainer.lyteScrollContainerY');
                var header = $node.getElementsByTagName( __tags.th )[ 0 ], hgt;
                _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.measure(function () {
                    var fg = this._dir;
                    // while applying scroll plugin vertical scrollbar needs some offset for enabling the virtual of only body part is scrolling. If it is zero we have to set height of the header as offset
                    if (header && scrollbar && scrollbar.offsetTop == 0) {
                        hgt = header.getBoundingClientRect().height;
                        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.mutate(function () {
                            scrollbar.style.top = hgt + 'px';
                            if (fg) {
                                $node.classList.add('lyteRTL')
                            }
                        }.bind(this))
                    }
                    _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.mutate(function () {
                        __data.ltPropDualResize && $node.classList.add('lyteDualResize')
                        if (this.getMethods('afterRender')) {
                            this.executeMethod('afterRender', this.$node);
                        }
                    }.bind(this))
                }.bind(this))
            } else {
                if (this.getMethods('afterRender')) {
                    /**
                     * @method afterRender
                     * @version 1.0.1
                     */
                    this.executeMethod('afterRender', this.$node);
                }
            }
        } catch (err) {
        }
        if (ltPropInfiniteScroll) {
            $node.classList.add('infinitescroll')
            /**
             * @utility setValue
             * @version 1.0.2
             */
            $node.setValue = function (ret) {
                if (this._stopScroll) {
                    this.appendAddData1.call(this, ret)
                }
            }.bind(this)

            /**
             * @utility removeRow
             * @version 2.2.17
             */

            $node.removeRow = function (row) {
                this.removeRow(row);
            }.bind(this);

            /**
             * @utility scrollToRecord
             * @version 2.2.19
             */

            $node.scrollToRecord = this.scrollToRecord.bind(this);

            /**
             * @utility insertRow
             * @version 2.2.19
             */

            $node.insertRow = this.insertRow.bind(this);
        }

        if( __data.ltPropNavigation ){
            window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __tags.table )[ 0 ] );
        }
    }

    // width calculation for positioning
    columnWidth(fixedColumn, i, j) {

        var width = 0;
        j = j || 0;

        for( ; j < i; j++ ){
            width += fixedColumn[ j ].property.width;
        }

        return width;
    }

    heightCalc(rows, upper, hgtLimit) {
        var hgt = 0, j = upper;
        for( ; j > 0; j-- ){
            hgt += rows[ j ];
            if( hgtLimit < hgt ){
                break;
            }
        }
        return [ hgt, j ];
    }

    topElem(elem) {
        var __final;

        if( this.isIE11Lyte || this.isEdgeLyte ){
            __final = elem.getElementsByTagName( this.data.ltPropTags.td )[ 0 ];
        } else {
            __final = elem;
        }
        return __final ? __final.getBoundingClientRect() : {};
    }

    cellSet(elem, value) {
        var __elem;
        if( this.isIE11Lyte || this.isEdgeLyte ){
            __elem = Array.from( elem.getElementsByTagName( this.data.ltPropTags.td ) );
        } else {
           __elem = [ elem ];
        }

        if( value ){
            __elem.forEach( function( item ){
                item.style.transform = value;
            });
        }
        return __elem[ 0 ].style.transform;
    }

    scrollTable(event, obj) {
        // fastdom has been removed here due to delay causes error in calculation of data in ie edge safari
        var b = event.yScroll, 
        __tags = this.data.ltPropTags,
        ltPropData = this.getData('ltPropData'), 
        ltPropContent = this.getData('ltPropContent'), 
        scrollDiv = this.scrollDiv, 
        divClientRect = obj.tbodyClient, 
        tableClient = obj.$nodeClient, 
        table = this.$node.querySelector( __tags.table ),
        head = this.$node.getElementsByTagName( __tags.th )[ 0 ], 
        neglected = obj.neglected, 
        compNeg = obj.compNeg;
        head = head ? (head.property ? head.property.height : head.getBoundingClientRect().height) : 0;
        var topElem = obj.topElem, 
        top1 = obj.topElemClient;

        if (table.style.height.indexOf('px') == -1) {
            table.style.height = divClientRect.height + 'px';
            this._rowHgt = parseInt(top1.height * 10) / 10;
            this._step = parseInt((divClientRect.height - this._rowHgt * neglected.length) * 10) / 10;
        }
        if( !this._dummy ){
            this.createDummy( obj.tbody );
        }
        if (b == undefined && !scrollDiv.classList.contains('eventBinded')) {
            var prevScroll = parseFloat(this._dummy.style.transform.match(/[\d|.]+/ig)[0]),
                currScroll = scrollDiv.scrollTop
            if (currScroll > prevScroll) {
                b = 1
            } else {
                b = -1
            }
        }

        var __boundary = this._boundary,
        __dummy = this._dummy.style,
        __dummy1 = ( this._dummy1 || {} ).style,
        __rowHgt = this._rowHgt;

        if (b > 0) {
            if (parseFloat(tableClient.top + head) >= parseFloat(top1.bottom)) {
                if( __boundary.bottom <= ltPropContent.length - 2 ) {
                    var diff = Math.max(parseInt((tableClient.top + head - top1.bottom) / __rowHgt ), 1);
                    if( __boundary.bottom + diff > ltPropContent.length - 1) {
                        diff = ltPropContent.length - 1 - __boundary.bottom
                    }
                    for (var i = 0; i < diff; i++) {
                        __boundary.bottom += 1;
                        if (i >= diff - ltPropData.length) {
                            this.$component.set(ltPropData[this._top], { body: ltPropContent[__boundary.bottom], index: __boundary.bottom })
                            topElem.dataOrder = __boundary.bottom;
                        }
                        __boundary.top = __boundary.bottom - ltPropData.length + 1;
                        if (this.cellSet(topElem)) {
                            this.regex(topElem)
                        } else {
                            this.cellSet(topElem, "translateY(" + (this._step) + 'px)')
                        }
                        __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\d|.]+/ig)[0]) + __rowHgt ) + 'px)'
                        __dummy.height = Math.max(parseFloat( __dummy.height) - __rowHgt, 0) + 'px';
                        if (this._browser) {
                            __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\d|.]+/ig)[0]) + __rowHgt ) + 'px)'
                        }
                        this._bottom = this._top;
                        this._top = (this._top + 1) % ltPropData.length;
                        if ( __boundary.bottom >= ltPropContent.length) {
                            __boundary.bottom = ltPropContent.length - 1;
                            this._top = (this._top + 1) % ltPropData.length;
                            break
                        }
                        topElem = this.nthoftype.call(this, obj.tbody, this._top + compNeg.length, true)
                    }
                } else {
                    this.scrollEndMethod1();
                }
            }

        } else if (b < 0) {
            var bottmElem = obj.bottmElem, bottom = obj.bottmElemClient;
            if (tableClient.bottom <= bottom.top) {
                var mat = this.cellSet(bottmElem).match(/[\d|.]+/ig);
                if (!mat || (mat && mat[0] == '0')) {
                    return
                }
                var diff = parseInt(Math.max(parseFloat((bottom.top - tableClient.bottom) / __rowHgt ), 0)),
                    minDiff = Math.max(diff - 1 - this._boundary.top, 0)
                for (var i = diff - 1; i >= 0 && diff != 0; i--) {
                    if ( __boundary.top == 0) {
                        break;
                    }
                    __boundary.top -= 1;
                    if (i <= ltPropData.length - 1 + minDiff) {
                        this.$component.set(ltPropData[this._bottom], { body: ltPropContent[ __boundary.top], index: __boundary.top })
                        bottmElem.dataOrder = __boundary.top;
                    }
                    __boundary.bottom = __boundary.top + ltPropData.length - 1;
                    if (this.cellSet(bottmElem)) {
                        this.regex(bottmElem, true)
                    }
                    __dummy.height = (parseFloat( __dummy.height) + __rowHgt ) + 'px';
                    __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\d|.]+/ig)[0]) - __rowHgt ) + 'px)'
                    if (this._browser) {
                        __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\d|.]+/ig)[0]) - __rowHgt ) + 'px)'
                    }
                    this._top = this._bottom;
                    this._bottom = (ltPropData.length + this._bottom - 1) % ltPropData.length;
                    if (__boundary.top == -1) {
                        __boundary.top = 0;
                        __boundary.bottom = __boundary.top + ltPropData.length - 1;
                        break
                    }
                    bottmElem = this.nthoftype.call(this, obj.tbody, this._bottom + compNeg.length, true)
                }
            }
        }
    }

    createDummy(tbody) {
        var dummy = document.createElement( this.data.ltPropTags.tr );
        dummy.classList.add('dummy');
        tbody.appendChild(dummy)
        dummy.setAttribute('style', 'transform:translateY(0px);height:0px')
        this._dummy = dummy;
        if (this._browser) {
            var dummy1 = document.createElement('div');
            dummy1.classList.add('dummy');
            this.scrollDiv.appendChild(dummy1)
            dummy1.setAttribute('style', 'transform:translateY(0px);height:5px')
            this._dummy1 = dummy1;
        }
    }

    regex(elem, flag) {
        if( this.isIE11Lyte || this.isEdgeLyte ){
            var cells = elem.getElementsByTagName( this.data.ltPropTags.td ),
            __length = cells.length;

            for( var i = 0; i < __length; i++ ){
                this.regex1( cells[ i ], flag );
            }
        } else {
            this.regex1( elem, flag );
        }
    }

    regex1(elem, flag) {
        var __style = elem.style,
        __transform = __style.transform,
        rgx = /[\d|.]+/ig,
        __step = this._step;

        if( flag ) {
            __style.transform = __transform.replace( rgx, function( arg ) { return Math.max( parseFloat( arg ) - __step, 0 ).toFixed( 3 ) });
        } else {
            __style.transform = __transform.replace( rgx, function( arg ) { return ( parseFloat( arg ) + __step ).toFixed( 3 ) });
        }
    }

    scrollEndMethod1() {
        if( this._stopScroll ) {
            return
        }
        this._stopScroll = true;
        if (this.getMethods('scrollEnd')) {
            /**
             * @method scrollEnd
             * @version 1.0.0
             */
            this.appendAddData1(this.executeMethod('scrollEnd'))
        }
    }

    appendAddData1(ret) {
        if (ret) {
            if (ret.then) {
                Promise.resolve(ret).then(function (arg) {
                    if (arg) {
                        this.apd1.call(this, arg);
                    }
                }.bind(this), function () {
                    console.log( 'error at scroll end promise' );
                }.bind(this));
            } else {
                this.apd1.call(this, ret)
            }
        }
    }

    apd1(ret) {
        var __data = this.data,
        ltPropContent = __data.ltPropContent, 
        ltPropData = __data.ltPropData,
        La = this.$addon.arrayUtils;

        this._prevent = true
        if( ret.constructor == Array ){
            La( ltPropContent, 'concat', ret );
        } else if( ret.constructor == Object ) {
            La( ltPropContent, 'push', ret );
        }
        delete this._prevent;
        delete this._stopScroll;
    }

    nthoftype(tbody, index, fg) {
        var arr = [],
        rows = tbody.getElementsByTagName( this.data.ltPropTags.tr );

        if( fg ){
            return rows[ index ];
        }

        var __length = rows.length;

        for( var i = 0; i < __length; i++ ) {
            var __cur = rows[ i ];
            if( !__cur.classList.contains('dummy')) {
                arr.push( this.get_children( __cur )[ index ] );
            }
        }
        return arr;
    }

    scroll(event) {

        // cant use fastdom because of jerk in ie edge safari browser
        var component = this.comp,
            // headerList =component.$node.querySelectorAll( 'lyte-th' ),
            // scrollleft and top are required for process like fixing columns and infinite scroll. If scroll is dispatched by plugin event object contains these properties or it is calculated
        obj = this._wheelObj || { bcr: {} };

        if( component.__ignore_scroll && component.__allow_scroll !== true ){
            return;
        }

        this._scrollLeft = obj.scrollLeft != undefined ? obj.scrollLeft : this.scrollLeft;
        this._scrollTop = obj.scrollTop != undefined ? obj.scrollTop : this.scrollTop;
        
        var direction = this._direction,
        __is_not_sticky = !component.data.ltPropStickyTable;

        __is_not_sticky && component.scrollCheck.call(this, event, obj);

        if (this._scrollLeft == 0 && direction != 'rtl' && component.getData('ltPropInfiniteScroll')) {
            var ary = component.getData('columns');
            component.$addon.arrayUtils(ary, 'remove', 0, ary.length);
            
            if( __is_not_sticky ){
                var fixedd = this.getElementsByClassName( 'lyteTableFixed' ),
                __length = fixedd.length;

                for( var i = 0; i < __length; i++ ) {
                    var __cur = fixedd[ i ];

                    __cur.style.left = '0px';
                    __cur.classList.remove('lyteTableFixed');
                }
            }
        }
        if (component.data.ltPropInfiniteScroll) {
            component.scrollTable.call(component, event, obj)
        }
        delete this._scrollLeft; delete this._scrollTop;
    }

    // fixed column checks and removals
    scrollCheck(event, obj) {
        var component = this.parentElement.component,
        __tags = component.data.ltPropTags,
        table = this.getElementsByTagName( __tags.table )[0], scrollDiv = this,
            scrollTop = this._scrollTop, scrollLeft = this._scrollLeft,
            scrollDir = component.getData('ltPropScroll'),
            direction = this._direction,
            tbody = table.getElementsByTagName( __tags.tbody )[0],
            thead = this.getElementsByTagName( __tags.thead )[0],
            ths = [],
            headerList = [],
            fixedColumn = [];

        if (thead) {
            ths = thead.getElementsByTagName( __tags.th );
        }

        if ((scrollTop != this.prevScollTop || event._byFunc) && scrollDir.vertical) {
            var colsNos = ths;
            if (colsNos.length) {
                for (var i = 0; i < colsNos.length; i++) {
                    colsNos[i].classList.add('tableRowFixed')
                    // colsNos[i].style.top = (scrollTop) + 'px';
                    component.transform(true, colsNos[i], scrollTop)
                }
                if (!scrollTop) {
                    for (var i = 0; i < colsNos.length; i++) {
                        colsNos[i].classList.remove('tableRowFixed');
                    }
                }
            }
        }
        // for horizontal scroll    
        if ((scrollLeft != this.prevScollLeft || event._byFunc) && scrollDir.horizontal) {
            var columns = component.data.columns, head = [];
            if (thead) {
                var headRows = Array.apply(Array, thead.getElementsByTagName( __tags.tr )),
                    headRowCopy = Array.apply(Array, thead.getElementsByClassName('lyteRowCopy'));
                head = headRows.concat(headRowCopy);
            }

            var ltPropFixedColumnClass = component.data.ltPropFixedColumnClass || '';
            if (head.length) {
                headerList = head[0].getElementsByTagName( __tags.th );
                for (var n = 0; n < headerList.length; n++) {
                    headerList[n].classList.contains('lyteFixedColumn') && fixedColumn.push(headerList[n]);
                }
            }
            // fastdom removed due to jerk in ie edge chrome browser
            for (var i = columns.length; i < fixedColumn.length; i++) {
                if (((fixedColumn[i].property.right + component.columnWidth.call(component, fixedColumn, i) > (obj.scrollDivClient.right)) && direction == 'rtl') || ((fixedColumn[i].property.left < (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, i))) && direction != 'rtl')) {
                    var width = fixedColumn[i].property.width
                    var order = fixedColumn[i].order
                    if (order + 1 < headerList.length) {
                        !fixedColumn[i].classList.contains('lyteTableFixed') && fixedColumn[i].classList.add('lyteTableFixed')
                        columns.push(fixedColumn[i])
                        for (var zz = 1; zz < head.length; zz++) {
                            var colex = head[zz].getElementsByTagName( __tags.th )[order];
                            colex && !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed')
                        }
                        var colls = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')' )*/
                        for (var k = 0; k < colls.length; k++) {
                            !colls[k].classList.contains('lyteTableFixed') && colls[k].classList.add('lyteTableFixed')
                            if (ltPropFixedColumnClass) {
                                colls[k].classList.add(ltPropFixedColumnClass)
                            }
                        }
                    }
                }
            }
            for (var n = columns.length - 1; n >= 0; n--) {
                var j = columns.length - 1;
                if ((scrollLeft == 0 && !(window.chrome && direction == 'rtl')) || ((((parseFloat((headerList[columns[j].order + 1].property.right + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1)).toFixed(2)) <= parseFloat(obj.scrollDivClient.right.toFixed(2))) || (headerList[columns[j].order + 1].property.right + 2 < columns[j].property.left)) && direction == 'rtl') || ((headerList[columns[j].order + 1].property.left >= (obj.scrollDivClient.left + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1))) && (columns[j].property.left >= (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, columns.length - 1))) && direction != 'rtl'))) {
                    // var innerElem = headerList[columns[j].order].querySelector( 'lyte-th-data' );
                    headerList[columns[j].order].classList.contains('lyteTableFixed') && headerList[columns[j].order].classList.remove('lyteTableFixed');
                    if (ltPropFixedColumnClass) {
                        headerList[columns[j].order].classList.remove(ltPropFixedColumnClass)
                    }
                    // columns[j].style.removeProperty('left');
                    component.transform(false, columns[j], 0)
                    for (var zz = 0; zz < head.length; zz++) {
                        var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];
                        if (colex) {
                            colex.classList.contains('lyteTableFixed') && colex.classList.remove('lyteTableFixed');
                            // colex.style.removeProperty('left');
                            component.transform(false, colex, 0)

                        }
                    }
                    var currCols = /*component.isIE11Lyte ?*/ component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/;
                    for (var z = 0; z < currCols.length; z++) {
                        // currCols[z].style.removeProperty('left');
                        component.transform(false, currCols[z], 0)
                        currCols[z].classList.contains('lyteTableFixed') && currCols[z].classList.remove('lyteTableFixed')
                        if (ltPropFixedColumnClass) {
                            currCols[z].classList.remove(ltPropFixedColumnClass)
                        }
                    }
                    component.$addon.arrayUtils(columns, 'removeAt', j)
                }
                else {
                    break;
                }
            }
            for (var j = 0; j < columns.length; j++) {
                //positioning on scroll
                var left, cells = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/,
                    uA = window.navigator.userAgent.toLowerCase();
                if (j == 0) {
                    if (direction == 'rtl') {
                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {
                            left = scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                        else if (uA.indexOf('edge') != -1 || uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1) {
                            left = -scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                        else {
                            left = scrollLeft - 1 - (obj.scrollWidth) + obj.scrollDivClient.width + (component.columnWidth.call(component, headerList, columns[j].order, 0))
                        }
                    }
                    else {
                        left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))
                    }
                }
                else {
                    if (direction == 'rtl') {
                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {
                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)
                        }
                        else {
                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1);
                        }
                    }
                    else {
                        left = component.transform(!1, columns[j - 1]) /*parseInt(columns[j - 1].style.left)*/ - component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)
                    }
                }
                for (var x = 0; x < cells.length; x++) {
                    !cells[x].classList.contains('lyteTableFixed') && cells[x].classList.add('lyteTableFixed');
                    //cells[x].style.left = left + 'px';
                    component.transform(false, cells[x], left)
                }
                // columns[j].style.left = left + 'px';
                component.transform(false, columns[j], left)
                for (var zz = 0; zz < head.length; zz++) {
                    var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];
                    if (colex) {
                        !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed');
                        // colex.style.left = left + 'px';
                        component.transform(false, colex, left)
                    }
                }
            }
        }
        this.prevScollLeft = scrollLeft;
        this.prevScollTop = scrollTop;
    }

    transform(flag, elem, value) {
        var transform = (elem.style.transform || 'translateX(0px) translateY(0px)'),
            transX = parseFloat(/translateX\((.+)/.exec(transform)[1]),
            transY = parseFloat(/translateY\((.+)/.exec(transform)[1]);

        if (value != undefined) {
            if (!flag) {
                elem.style.transform = "translateY(" + transY + 'px) ' + 'translateX(' + value + 'px)';
            } else {
                elem.style.transform = "translateY(" + value + 'px) ' + 'translateX(' + transX + 'px)';
            }
        } else {
            return parseFloat(flag ? transY : transX);
        }
    }

    borderChange() {
        if (this.data.ltPropBorder) {
            this.$node.classList.add('border');
        }
        else {
            this.$node.classList.remove('border');
        }
    }

    widthObs() {
        this.$node.querySelector( this.data.ltPropTags.table ).style.width = this.data.ltPropWidth;
    }

    heightObs() {
        this.$node.querySelector( this.data.ltPropTags.table ).style.height = this.data.ltPropHeight;
    }

    sortable() {
        var row = this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];
        if( row ){
            var ns = "remove";

            if( this.data.ltPropColumnSortable ){
                this.colSort = this.sortableColumns.bind( this );
                ns = "add";
            }

            if( ns ){
                var rel = ns + "EventListener",
                fn = this.colSort;

                row[ rel ]( "mousedown", fn );
                row[ rel ]( "touchstart", fn );
                row.parentNode.classList[ ns ]( 'sortableTable' );
            }
        }
    }

    composePath(event) {
        var arr = [], 
        __target = event.target,
        node = __target.correspondingElement || __target;
        while( node && node.tagName != 'HTML' ){
            arr.push( node );
            node = node.parentNode;
        }
        return arr;
    }

    sortableColumns(event) {
        var __tags = this.data.ltPropTags,
        target = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), __tags.th + ':not(.lyteTableFixed)');
        if (target && this.$node.contains(target)) {
            var ret, isTch = event.type == "touchstart";
            if (this.getMethods('onBeforeSelect')) {
                /**
                 * @method onBeforeSelect
                 * @version 1.0.3
                 */
                ret = this.executeMethod('onBeforeSelect', target, event, this.$node)
            }
            if (ret != false) {
                var evt = isTch ? event.touches[0] : event
                this._ww = window.innerWidth;
                this.mousemove = this.sortableMouseMove.bind(this);
                this.offLeft = this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.rtlfunc.call(this, 'left', target.getBoundingClientRect(), this._ww);
                this.colHead = target;
                this._thisBccr = this.$node.getBoundingClientRect()
                target.classList.add('lyteStickyTableColumnSortSelect')
                document.documentElement.addEventListener(isTch ? "touchmove" : 'mousemove', this.mousemove);
                this.mouseup = this.sortableMouseup.bind(this);
                document.documentElement.addEventListener(isTch ? "touchend" : 'mouseup', this.mouseup);
                this.flag = true;
                event.preventDefault();
                if (this.getMethods('onSelect')) {
                    /**
                     * @method onSelect
                     * @version 1.0.3
                     */
                    this.executeMethod('onSelect', target, event, this.$node)
                }
            }
        }
    }

    horiScroll(dummyDiv, ww) {
        var lt = this.rtlfunc.call(this, 'left'), IE = this.isIE11Lyte || this.isEdgeLyte,
            isEvt, check1, check2;
        if (/mousemove|touchmove/i.test(dummyDiv.type)) {
            isEvt = true;
        }
        if (isEvt) {
            if (this._reqId) {
                return;
            }

            var __bcr = this.__bcr;

            check1 = this.rtlfunc( 'clientX', dummyDiv, ww ) > Math.min( this.rtlfunc( 'right', __bcr, ww), ww - 2 );
            check2 = this.rtlfunc( 'clientX', dummyDiv, ww ) <= Math.max( 0, this.rtlfunc('left', __bcr, window.innerWidth ) );
        } else {
            check1 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;
            check2 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;
        }

        if (check1) {
            this.scrollDiv.scrollLeft += 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)
            if (isEvt) {
                var __value = 2 * ( this._dir ? -1 : 1 );
                this.__clientX -= __value;

                if( this.data.ltPropFixResizeCursor ){
                    this.__trans_value += __value
                }
            }
            this._reqId = window.requestAnimationFrame(function () {
                delete this._reqId;
                this.horiScroll(dummyDiv, ww)
            }.bind(this))
        } else if (check2) {
            if (isEvt) {
                var __value =  2 * ( this._dir ? -1 : 1 );
                this.__clientX += __value;
                
                if( this.data.ltPropFixResizeCursor ){
                    this.__trans_value -= __value
                }
            }
            this.scrollDiv.scrollLeft -= 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)
            this._reqId = window.requestAnimationFrame(function () {
                delete this._reqId;
                this.horiScroll(dummyDiv, ww);
            }.bind(this))
        } else {
            window.cancelAnimationFrame(this._reqId);
            delete this._prevent;
        }
    }

    sortableMouseMove(event) {
        var isTch = event.type == "touchmove", evt = event;
        if (isTch && evt.touches.length != 1) {
            return
        } else if (isTch) {
            evt = evt.touches[0]
        }
        if (this.flag && this._timeout == undefined) {
            var target = this.colHead, xscroll;
            var clientRect = target.getBoundingClientRect();
            var div = document.createElement('div');
            div.classList.add('lyteTableSortHelper');
            div.innerText = this.colHead.innerText;
            this._xxoff = xscroll = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? -1 : 1);
            var yscroll = window.pageYOffset || document.documentElement.scrollTop
            div.style.height = clientRect.height + 'px';
            div.style.width = clientRect.width + 'px';
            div.style[this.rtlfunc.call(this, 'left')] = (xscroll + this.rtlfunc.call(this, 'left', clientRect, this._ww)) + 'px';
            div.style.top = (yscroll + clientRect.top) + 'px';
            this._timeout = setTimeout(function () {
                window._lyteUiUtils.appendChild( document.body, div );
                this.flag = false;
            }.bind(this), 100)
        }
        var dummyDiv = document.querySelector('div.lyteTableSortHelper')
        if (dummyDiv) {
            var lft = this._dir ? "right" : "left", ww = window.innerWidth;
            var newLeft = Math.max(Math.min((this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.offLeft), this.rtlfunc.call(this, 'right', this._thisBccr, this._ww) - parseFloat(dummyDiv.style.width)), this.rtlfunc.call(this, 'left', this._thisBccr, this._ww));
            // if( ( newLeft > parseFloat( dummyDiv.style[ lft ] - this._xxoff ) ) || ( newLeft < parseFloat( dummyDiv.style[ lft ] ) - this._xxoff ) ){
            if ((parseFloat(newLeft) > this.rtlfunc('left', this._thisBccr, ww)) && ((parseFloat(newLeft) + parseFloat(dummyDiv.style.width)) < this.rtlfunc('right', this._thisBccr, ww))) {
                window.cancelAnimationFrame(this._reqId);
                delete this._prevent; delete this._scrollDir
            }
            if (this._prevent) {
                return
            }
            dummyDiv.style[lft] = (newLeft + this._xxoff) + 'px';
            this._prevent = true
            this.horiScroll(dummyDiv, ww)
            if (this.getMethods('onDrag')) {
                /**
                 * @method onDrag
                 * @version 1.0.3
                 */
                this.executeMethod('onDrag', this.colHead, dummyDiv, event, this.$node)
            }
        }
        event.preventDefault();
        event.stopPropagation();
    }

    sortableMouseup(event) {
        if (!this.flag) {
            var __tags = this.data.ltPropTags,
            isTch = event.type == "touchend", dummyDiv = document.getElementsByClassName('lyteTableSortHelper')[0], clientRect = dummyDiv.getBoundingClientRect(), x = clientRect.left + clientRect.width / 2 + 2, y = clientRect.top + clientRect.height / 2,
                adjCol = this.closestFind.call(this, document.elementsFromPoint ? document.elementsFromPoint(x, y) : this.elementsFromPointCal.call(this, x, y), __tags.th + ':not(.lyteTableFixed)'),
                tbody = this.$node.getElementsByTagName( __tags.tbody )[0];
            if (adjCol != this.colHead && adjCol) {
                var Heads = this.colHead.parentElement.getElementsByTagName( __tags.th ),
                    colOrder = Array.prototype.indexOf.call(Heads, this.colHead),
                    adjOrder = Array.prototype.indexOf.call(Heads, adjCol),
                    ltPropHeader = this.data.ltPropHeader, ret;
                if (this.getMethods('onBeforeDrop')) {
                    /**
                     * @method onBeforeDrop
                     * @version 1.0.3
                     */
                    ret = this.executeMethod('onBeforeDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)
                }
                if (ret != false) {
                    if (!ltPropHeader.length) {
                        window._lyteUiUtils.insertBefore(adjOrder > colOrder ? adjCol.nextElementSibling : adjCol, this.colHead);
                        var colGrp = /*this.isIE11Lyte ? */this.nthoftype.call(this, tbody, colOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( colOrder + 1) +')' )*/;
                        var AdjColGrp = /*this.isIE11Lyte ?*/ this.nthoftype.call(this, tbody, adjOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( adjOrder + 1) +')' )*/;
                        for (var i = 0; i < colGrp.length; i++) {
                            window._lyteUiUtils.insertBefore(adjOrder > colOrder ? AdjColGrp[i].nextElementSibling : AdjColGrp[i], colGrp[i]);
                        }
                    }
                    else {
                        var flag = adjOrder > colOrder ? true : false;
                        var temp = this.$addon.arrayUtils(ltPropHeader, 'removeAt', colOrder), newOrder = Array.prototype.indexOf.call(adjCol.parentElement.getElementsByTagName( __tags.th ), adjCol);
                        this.$addon.arrayUtils(ltPropHeader, 'insertAt', colOrder < adjOrder ? (newOrder + 1) : newOrder, temp);
                        var newCol = adjCol.parentElement.getElementsByTagName( __tags.th, adjCol.parentElement)[colOrder < adjOrder ? (newOrder + 1) : newOrder];
                        if (adjCol.classList.contains('tableRowFixed')) {
                            newCol.classList.add('tableRowFixed');
                            newCol.style.top = adjCol.style.top;
                        }
                    }
                    if (this.getMethods('onDrop')) {
                        /**
                         * @method onDrop
                         * @version 1.0.3
                         */
                        this.executeMethod('onDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)
                    }
                }
            } else {
                this.getMethods( 'onRelease' ) && this.executeMethod( 'onRelease', this.colHead, event, this.$node );
            }
            document.body.removeChild(dummyDiv);
        } else {
            clearTimeout(this._timeout)
        }
        document.documentElement.removeEventListener(isTch ? "touchend" : 'mouseup', this.mouseup);
        document.documentElement.removeEventListener(isTch ? "touchmove" : 'mousemove', this.mousemove);
        this.colHead.classList.remove('lyteStickyTableColumnSortSelect')
        window.cancelAnimationFrame(this._reqId)
        delete this.mouseup; delete this._xxoff;
        delete this.mousemove;
        delete this.offLeft;
        delete this.colHead;
        delete this.flag;
        delete this._timeout;
        delete this._thisBccr; delete this._ww;
        delete this._reqId; delete this._prevent; delete this._scrollDir
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
    }

    elementsFromPointCal(x, y) {
        var arr = [], element = document.elementFromPoint(x, y);
        while (element != document && element != document.documentElement && element != document.body && element != this.$node) {
            element.style.pointerEvents = 'none';
            arr.push(element);
            element = document.elementFromPoint(x, y);
        }
        for (var i = 0; i < arr.length; i++) {
            arr[i].style.pointerEvents = 'initial';
        }
        return arr;
    }

    // resizeComponentAppendObs: function () {
    //     if (this.data.ltPropYield) {
    //         this.resizeComponentAppend.call(this);
    //     }
    // }.observes('ltPropResize', 'ltPropResize.{}'),

    // resizeComponentAppend: function () {
    //     var ltPropResize = this.data.ltPropResize, scrdiv = this.$node.getElementsByTagName('lyte-table-structure')[0],
    //         tRz = scrdiv.getElementsByTagName('lyte-table-resize')[0], vrz = scrdiv.getElementsByTagName('lyte-table-vertical-resize')[0],
    //         hrz = scrdiv.getElementsByTagName('lyte-table-horizontal-resize')[0];
    //     if (ltPropResize.vertical || ltPropResize.horizontal) {
    //         if (!tRz) {
    //             var comp = document.createElement('lyte-table-resize')
    //             scrdiv.appendChild(comp)
    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this));
    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
    //         }
    //     } else if (tRz) {
    //         scrdiv.removeChild(tRz)
    //     }
    //     if (ltPropResize.vertical) {
    //         if (!vrz) {
    //             var comp = document.createElement('lyte-table-vertical-resize')
    //             scrdiv.appendChild(comp)
    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))
    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
    //         }
    //     }
    //     else if (vrz) {
    //         scrdiv.removeChild(vrz)
    //     }
    //     if (ltPropResize.horizontal) {
    //         if (!hrz) {
    //             var comp = document.createElement('lyte-table-horizontal-resize')
    //             scrdiv.appendChild(comp)
    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))
    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));
    //         }
    //     }
    //     else if (hrz) {
    //         scrdiv.removeChild(hrz)
    //     }
    // },

    data(arg1) {
        
        var default_values = window._lyteUiUtils.getDefault( 'lyte-table' );

        return Object.assign(super.data({
            //user data
            /**
             * @componentProperty {object[]} ltPropContent
             * @version 1.0.0
             * @default []
             */
            ltPropContent: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("array", { "default": [] }),
            /**
             * @componentProperty {object[]} ltPropHeader
             * @version 1.0.0
             * @default []
             */
            ltPropHeader: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("array", { "default": [] }),
            /**
             * @componentProperty {string} ltPropId=''
             * @version 1.0.0
             */
            ltPropId: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropClass=''
             * @version 1.0.0
             */
            ltPropClass: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("string", { "default": default_values.class || '' }),
            /**
             * @componentProperty {boolean} ltPropBorder=false
             * @version 1.0.0
             */
            ltPropBorder: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("boolean", { "default": default_values.border || false }),
            /**
             * @componentProperty {string} ltPropHeaderLabelKey=''
             * @version 1.0.0
             */
            ltPropHeaderLabelKey: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropBodyLabelKey=''
             * @version 1.0.0
             */
            ltPropBodyLabelKey: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("string", { "default": '' }),
            /**
             * @componentProperty {string} ltPropWidth=100%
             * @version 1.0.0
             */
            ltPropWidth: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { 'default': default_values.width || '100%' }),
            /**
             * @componentProperty {string} ltPropHeight=100%
             * @version 1.0.0
             */
            ltPropHeight: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { 'default': default_values.height || '100%' }),
            /**
             * @typedef {object} tableResize
             * @property {boolean} horizontal
             * @property {boolean} vertical
             */

            /**
             * @componentProperty {tableResize} ltPropResize
             * @version 1.0.0
             * @default {}
             */
            ltPropResize: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('object', { 'default': default_values.resize || {} }),
            /**
             * @componentProperty {string} ltPropFixedColumnClass=''
             * @version 1.0.0
             */
            ltPropFixedColumnClass: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { 'default': default_values.fixedColumnClass || '' }),
            /**
             * @componentProperty {boolean} ltPropYield=false
             * @version 1.0.0
             */
            ltPropYield: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { 'default': default_values.yield || false }),
            /**
             * @typedef {object} tableScroll
             * @property {boolean} horizontal=true
             * @property {boolean} vertical=true
             */
            /**
             * @componentProperty {tableScroll} ltPropScroll
             * @default {"horizontal":true,"vertical":true}
             */
            ltPropScroll: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('object', { 'default': default_values.scroll || { horizontal: true, vertical: true } }),
            /**
             * @componentProperty {boolean} ltPropColumnSortable=false
             * @version 1.0.0
             */
            ltPropColumnSortable: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { 'default': default_values.columnSortable || false }),
            /**
             * @typedef {object} tableScrollbar
             * @property {left | right} verticalPosition=left
             * @property {top | bottom} horizontalPosition=bottom
             * @property {string} containerClass
             * @property {string} handlerClass
             * @property {string} horizontalContainerClass
             * @property {string} horizontalHandlerClass
             * @property {string} verticalContainerClass
             * @property {string} verticalHandlerClass
             * @property {boolean} preventVertical
             * @property {boolean} preventHorizontal
             * @property {number} keyStep=30
             * @property {hover | always | scroll} showOn=scroll
             * @property {number} wheelSpeed=1
             * @property {boolean} preventOnEnd=true
             * @property {object} offset={"x":0,"y":0}
             * @property {boolean} nested
             * @property {number} max=Infinity
             * @property {number} min=-Infinity
             */
            /**
             * @componentProperty {tableScrollbar} ltPropScrollbarOption
             * @version 1.0.0
             * @default {}
             */
            ltPropScrollbarOption: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('object', { 'default': default_values.scrollbarOption || {} }),
            /**
             * @componentProperty {boolean} ltPropDualResize=false
             * @version 1.0.5
             */
            ltPropDualResize: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { default: default_values.dualResize || false }),

            // scroll table test data
            /**
             * @experimental ltPropData
             */
            ltPropData: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)("array", { "default": [] }),
            /**
             * @componentProperty {boolean} ltPropInfiniteScroll=false
             * @version 1.0.0
             */
            ltPropInfiniteScroll: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { 'default': default_values.infiniteScroll || false }),
            /**
             * @componentProperty {string} ltPropCellHeight=20px
             * @version 1.0.2
             */
            ltPropCellHeight: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { default: default_values.cellHeight || '20px' }),
            /**
             * @componentProperty {number} ltPropContentLength
             * @version 1.0.2
             */
            ltPropContentLength: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('number', { default_values : default_values.contentLength || void 0 }),
            /**
             * @componentProperty {boolean} ltPropPreventScrollbar=false
             * @version 1.0.0
             */
            ltPropPreventScrollbar: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { default: default_values.preventScrollbar || false }),

            /**
             * @componentProperty {string} ltPropRole=""
             * @version 3.45.0
             */

            ltPropRole : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'string', { default : default_values.role || "" } ),

            // sticky table props
            /**
             * @componentProperty {boolean} ltPropStickyTable=false
             * @version 3.53.0
             */
            ltPropStickyTable : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : default_values.stickyTable || false } ),
            /**
             * @componentProperty {number} ltPropScrollStep=2
             * @version 3.53.0
             */
            ltPropScrollStep : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'number', { default : default_values.scrollStep || 2 } ),
            /**
             * @componentProperty {boolean} ltPropPreventTableModify=true
             * @version 3.53.0
             */
            ltPropPreventTableModify : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : default_values.preventTableModify == false ? false : true } ),
            /**
             * @componentProperty {string} ltPropSortDummyColumClass=""
             * @version 3.53.0
             */
            ltPropSortDummyColumClass : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'string', { default : default_values.sortDummyColumnClass || "" } ),

            /**
             * @componentProperty {boolean} ltPropNavigation=false
             * @version 3.51.2
             */
            ltPropNavigation : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : default_values.navigation || false } ),

            /**
             * @componentProperty {boolean} ltPropReset=false
             * @version 3.53.0
             */

            ltPropReset : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : false } ),
            /**
             * @typedef {object} tableTags
             * @property {string} table="lyte-table-structure"
             * @property {string} thead="lyte-thead"
             * @property {string} tbody="lyte-tbody"
             * @property {string} tr="lyte-tr"
             * @property {string} td="lyte-td"
             * @property {string} th="lyte-th"
             */

            /**
             * @componentProperty {tableTags} ltPropTags
             * @version 3.91.0 
             */

            ltPropTags : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'object', { default : default_values.tags || { table : "lyte-table-structure", thead : "lyte-thead", tbody : "lyte-tbody", td : "lyte-td", th : "lyte-th", tr : "lyte-tr" } } ),

            ltPropSortable : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean' , { default : default_values.sortable || false }),

            ltPropContainment : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string' , { default : default_values.containment || '' }),

            lyteUnbound: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean', { default: false }),

            ltPropFromListview : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('boolean' , {default : false} ),

            /**
             * @componentProperty {boolean} ltPropFixResizeCursor=false
             * @version 3.95.0
             */

            ltPropFixResizeCursor : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : default_values.fixResizeCursor || false } ),

            // system data
            columns: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('array', { 'default': [] }),
            nonFixedColumn: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('array', { 'default': [] }),
            minWidth1: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { 'default': '' }),
            minWidth2: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('string', { 'default': '' }),
            secondaryData: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('array', { 'default': [] }),
            boundary: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('object', { 'default': {} }),
            rowHeights: (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)('array', { 'default': [] }),
            fromListView : (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.prop)( 'boolean', { default : false } )
        }), arg1);
    }

    resize_fun(evt) {
        var isTch = evt.type == "touchstart",
        __evt = evt,
        touches = evt.touches;

        if( isTch ){
            if( touches.length > 1 ){
                return;
            }
            __evt = touches[ 0 ];
        }

        evt.preventDefault();

        var __this = this,
        __bcr = __this.__bcr,
        __elem = __this.__elem,
        x_inc = ( __this.__clientX - ( __this.__clientX = __evt.clientX ) ) * ( __this._dir ? -1 : 1 ),
        y_inc = __this.__clientY - ( __this.__clientY = __evt.clientY ),
        original_x_inc = x_inc,
        __min1 = __this.__min1,
        __min2 = __this.__min2,
        __max1 = __this.__max1,
        __max2 = __this.__max2,
        __width = parseFloat( __elem.style.width ),
        new_width = __width - x_inc,
        new_height,
        __next = __elem.nextElementSibling,
        new_width2,
        cb = "onResizeMove",
        table = __this.__table,
        __resize = __this.data.ltPropResize,
        __dir = __this.__dir,
        is_hgt_modify = /vert|both/i.test( __dir || '' ),
        $node = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __this.$node );

        if( __dir ){
            if( !__resize.horizontal ){
                x_inc = 0;
            }

            if( !__resize.vertical ){
                y_inc = 0;
            }
        }

        if( __max1 && new_width > __max1 ){
            x_inc = __max1 - __width;
        } else if( __min1 && new_width < __min1 ){
            x_inc = __width - __min1;
        }

        if( !is_hgt_modify && __min2 != void 0 ){
            var __width2 = parseFloat( __next.style.width ),

            new_width2 = __width2 + x_inc;

            if( __max2 && new_width2 > __max2 ){
                x_inc = __width2 - __max2;
            } else if( __min2 && new_width2 < __min2 ){
                x_inc = __min2 - __width2;
            }

            new_width2 = __width2 + x_inc;
        } else {
            __next = void 0;
        }

        if( is_hgt_modify ){
            var __height = parseFloat( __elem.style.height );
            new_height = __height - y_inc;

            if( __max2 && new_height > __max2 ){
                y_inc = __max1 - __height;
            } else if( __min2 && new_height < __min2 ){
                y_inc = __height - __min2;
            }

            new_height = __height - y_inc;
        }

        if( original_x_inc && __this.data.ltPropFixResizeCursor && /lyte-th/i.test( __elem.tagName ) ){
            var __diff = original_x_inc - x_inc,
            trans_value = __this.__trans_value;

            if( __diff ){
                __this.__trans_value += __diff;
            } else if( trans_value ) {
                if( ( trans_value > 0 && x_inc < 0 ) || ( trans_value < 0 &&  x_inc > 0 ) ){
                    if( __next ){
                        new_width2 -= x_inc;
                    }

                    if( Math.abs( trans_value ) < Math.abs( x_inc ) ){
                        x_inc += trans_value;
                        __this.__trans_value = 0;
                    } else {
                        __this.__trans_value += x_inc;
                        x_inc = 0;
                    }
                }
            }
        }

        new_width = __width - x_inc;

        if( table ){
           _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( table ).css( 'width', ( parseFloat( table.style.width ) - x_inc ) + 'px' );

        } 

        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __elem ).css( 'width', new_width + 'px' );
        __next && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __next ).css( 'width', new_width2 + 'px' );

        if( __dir ){
            var ret = $node.css( 'maxWidth', new_width + 'px' );
            if( new_height ){
                ret.css( 'maxHeight', new_height + 'px' );
                _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __elem ).css( 'height', new_height + 'px' );
            }
        }

        window.cancelAnimationFrame( __this._reqId );
        delete __this._reqId;

        __this.horiScroll( evt, __this.__ww );

        __this.data.ltPropStickyTable && __this._setLeftForInterSection();

        __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node );
    }

    resize_up(evt) {
        var isTch = evt.touches,
        __doc = document,
        __fn = 'removeEventListener',
        cb = 'onResizeEnd',
        __elem = this.__elem;

        __doc[ __fn ]( isTch ? 'touchmove' : 'mousemove', this.__mmove, true );
        __doc[ __fn ]( isTch ? 'touchend' : 'mouseup', this.__mup, true );

        [ '__dir', '__ww', '__min2', '__min1', '__max1', '__max2', '__clientX', '__clientY', '__elem', '__bcr', '__table' ].forEach( function( item ){
            delete this[ item ];
        }.bind( this ) );

        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( this.$node ).removeClass( 'resizing lyteTableResizing' );
        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __elem ).removeClass( 'resizeSelect lyteTableResizeSelect' );

        this.clearfdm();

        /**
         * @method onResizeEnd
         * @version 1.0.3
         */

        this.getMethods( cb ) && this.executeMethod( cb, __elem, this.$node, evt );
    }

    static actions(arg1) {
        return Object.assign(super.actions({

            tableResize : function( evt, from ){
                var isTch = evt.type == "touchstart",
                __evt = evt,
                touches = evt.touches;

                if( isTch ){
                    if( touches.length > 1 ){
                        return
                    }
                    __evt = touches[ 0 ];
                }

                var  __this = this,
                __data = __this.data,
                __tags = __data.ltPropTags,
                table = __this.$node.getElementsByTagName( __tags.table )[ 0 ],
                __elem = from ? table : evt.target.parentNode,
                cb = "onBeforeResizeSelect";

                if( __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node ) == false ){
                    return;
                }

                var tag = __elem.tagName,
                is_dual = __data.ltPropDualResize,
                fastdom = (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom),
                __maxwidth = table.style.maxWidth,
                __minWidth = table.style.minWidth,
                __maxheight = table.style.maxHeight,
                __layout = table.style.tableLayout,
                $table = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( table ),
                __width = __elem.offsetWidth,
                is_cell = tag.toLowerCase() == __tags.th,
                nextelem = is_cell ? __elem.nextElementSibling : void 0,
                __next_width = nextelem ? nextelem.offsetWidth : 0,
                table_width = table.offsetWidth,
                scroll_elem = __this.scrollDiv,
                sL = scroll_elem.scrollLeft,
                is_vert = /vert|both/i.test( from || '' ),
                table_height = is_vert ? ( table.offsetHeight + 'px' ): table.style.height,
                $$node = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __this.$node ),
                table_style = window.getComputedStyle( table ),
                is_fixed = table_style.tableLayout == "fixed",
                read_value = table_style.getPropertyValue( 'max-width' ),
                max_width_read = is_cell || (  /px/i.test( read_value ) ? parseFloat( read_value ) : Infinity );

                __this.__ignore_scroll = true;

                __this.__bcr = __this.$node.getBoundingClientRect();
                __this.__ww = window.innerWidth;
                __this.__dir = from;

                __this.__trans_value = 0;

                if( is_cell && /%|px/i.test( table_style.minWidth ) ){
                    var __arr = [];

                    Array.from( __this.get_children( __elem.parentNode ) ).forEach( function( item ){
                        __arr.push({
                            node : item,
                            width : item.style.width || ( item.offsetWidth + 'px' )
                        });
                    });

                    __arr.forEach( function( item ){
                        item.node.style.width = item.width;
                    });
                }

                $table.css( {
                    maxWidth :  '0px',
                    tableLayout : "auto",
                    minWidth : "auto"
                });

                if( is_vert ){
                    $table.css( 'maxHeight', '0px' );
                }

                $$node.addClass( 'lyteTableInitialResize' );

                __this.__fd1 = fastdom.measure( function(){
                    var __style = window.getComputedStyle( __elem ),
                    actual_min = parseFloat( __style.getPropertyValue( 'min-width' ) ),
                    minWidth1 = Math.min( __width, Math.max( __elem.offsetWidth, actual_min ) ),
                    maxWidth1 = is_cell ? parseFloat( __style.getPropertyValue( 'max-width' ) ) : max_width_read,
                    minWidth2,
                    maxWidth2;

                    if( minWidth1 == 0 ){
                        minWidth1 = 50;
                    }

                    if( is_cell && is_fixed ){
                        minWidth1 = Math.min( minWidth1, actual_min );
                    }

                    if( maxWidth1 < minWidth1 ){
                        maxWidth1 = minWidth1;
                    }

                    if( is_cell ){
                        if( !is_dual ){
                            if( nextelem ){
                                var next_style = window.getComputedStyle( nextelem ),
                                actual_min_next = parseFloat( next_style.getPropertyValue( 'min-width' ) );

                                minWidth2 = Math.min( __next_width, Math.max( nextelem.offsetWidth, actual_min_next ) );
                                maxWidth2 = parseFloat( next_style.getPropertyValue( 'max-width' ) );

                                if( minWidth2 == 0 ){
                                    minWidth2 = 50;
                                }

                                if( is_fixed ){
                                    minWidth2 = Math.min( minWidth2, actual_min_next );
                                }

                                if( maxWidth2 < minWidth2 ){
                                    maxWidth2 = minWidth2;
                                }
                            }
                        } else {
                            __this.__table = table;
                        }
                    } else if( is_vert ){
                        maxWidth2 = parseFloat( __style.getPropertyValue( 'max-height' ) );
                        minWidth2 = parseFloat( __style.getPropertyValue( 'min-height' ) );
                    }

                    __this.__fd2 = fastdom.mutate( function(){
                        __this.__min1 = minWidth1;
                        __this.__min2 = minWidth2;
                        __this.__max1 = maxWidth1;
                        __this.__max2 = maxWidth2;

                        __this.__clientX = __evt.clientX;
                        __this.__clientY = __evt.clientY;

                        __this.__elem = __elem;

                        $table.css( {
                            maxWidth : __maxwidth,
                            width : table_width + 'px',
                            maxHeight : __maxheight,
                            height : table_height,
                            tableLayout : __layout,
                            minWidth : __minWidth
                        });

                        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __elem ).addClass( 'resizeSelect lyteTableResizeSelect' ).css( 'width', __width + 'px' );
                        nextelem && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( nextelem ).css( 'width', __next_width + 'px' );

                        delete __this.__ignore_scroll;
                        scroll_elem.scrollLeft = sL;

                        var __doc = document,
                        __fn = "addEventListener";

                        __doc[ __fn ]( isTch ? 'touchmove' : "mousemove", __this.__mmove = __this.resize_fun.bind( __this ), true );
                        __doc[ __fn ]( isTch ? 'touchend' : "mouseup", __this.__mup = __this.resize_up.bind( __this ), true );

                        $$node.addClass( 'resizing lyteTableResizing' ).removeClass( 'lyteTableInitialResize' );

                        __this.getMethods( cb = "onResizeSelect" ) && __this.executeMethod( cb, __elem, evt, __this.$node );
                    });
                });


                evt.preventDefault();
                evt.stopPropagation();
                evt.stopImmediatePropagation();
            },

            rowMouseDown : function( evt ){
                if( this.data.ltPropSortable && (evt.button == 0 || (evt.touches && evt.touches.length==1) ) ){      
                        this.rowMouseDown( evt );
                }
            }
            
        }), arg1);
    }

    clearfdm() {
        var __fastdom = (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom);

        [ '__fd1', '__fd2' ].forEach( function( item ){
            var __cur = this[ item ];

            if( __cur ){
                __fastdom.clear( __cur );
                delete this[ item ];
            }
        }.bind( this ) );
    }

    arrayFrom(nodeList) {
        if (Array.from) {
            return Array.from(nodeList)
        }
        return Array.apply(Array, nodeList);
    }

    closestFind(path, query) {
        var elements = this.arrayFrom.call(this, document.querySelectorAll(query));
        for (var i = 0; i < path.length; i++) {
            if (Array.prototype.indexOf.call(elements, path[i]) != -1) {
                return path[i];
            }
        }
        return null;
    }

    findDomIndex(order) {
        var data = this.data.ltPropData;
        for (var i = 0; i < data.length; i++) {
            if (data[i].index == order) {
                return i;
            }
        }
        return -1;
    }

    insertRow(index, insertData) {
        var boundary = this._boundary,
            top = boundary.top,
            bottom = boundary.bottom,
            content = this.data.ltPropContent,
            data = this.data.ltPropData,
            _contentLength = this.data.ltPropContentLength;

        this._prevent = true;

        this.$addon.arrayUtils(content, 'insertAt', index, insertData);

        if (index <= bottom) {
            var start = Math.max(top, index);

            for (var i = start; i <= bottom; i++) {
                var domIndex = this.findDomIndex(i);
                this.$component.set(data[domIndex], { index: data[domIndex].index, body: content[i] });
            }
        }

        if( this.data.ltPropContentLength > content.length || this.data.ltPropContentLength > data.length ) {
            var _length = data.length;

            this.$addon.arrayUtils( data, 'push', {
                index : _length,
                body : content[ _length ],
                checked : false
            });

            boundary.bottom++;
            this._bottom++;

            if( this._rowHgt ){
                this._step = this._rowHgt * data.length;
            }
        }

        delete this._prevent;
    }

    removeRow(dataIndex) {
        var tags = this.data.ltPropTags,
        rows = this.arrayFrom(_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( tags.tbody + ' ' + tags.tr + ':not(.dummy)', this.$node));

        if (dataIndex.constructor != Number) {
            dataIndex = dataIndex.dataOrder || rows.indexOf(dataIndex);
        }

        var domIndex = this.findDomIndex(dataIndex),
            boundary = this._boundary,
            top = boundary.top,
            bottom = boundary.bottom,
            content = this.data.ltPropContent,
            data = this.data.ltPropData,
            removed = false;

        this._prevent = true;

        if (domIndex != -1) {
            if (bottom == content.length - 1) {
                for (var i = dataIndex; i <= bottom; i++) {
                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;
                    if (i + 1 == content.length) {
                        this.regex(rows[cIndex], true);

                        if ( this._dummy ) {
                            var _style = this._dummy.style;
                            _style.transform = 'translateY(' + ( parseFloat( _style.transform.match( /[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';
                            
                            if ( this._dummy1 ) {
                                var _style1 = this._dummy1.style;
                                _style1.transform = 'translateY(' + ( parseFloat( _style1.transform.match( /[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';
                            }
                        }
                        if( content[ top - 1 ] ){
                            this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[top - 1] });
                            rows[ cIndex ].dataOrder = top - 1;
                        }
                    } else {
                        this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });
                        rows[cIndex].dataOrder--;
                    }
                }
                if( content.length - 1 == data.length - 1 ){
                    this.$addon.arrayUtils( data , 'pop' );
                    removed = true;
                }else if( boundary.top >= dataIndex){
                    boundary.top--;
                } 
                if(this._top != 0){
                    this._top = (this._top -1 + data.length) % data.length;
                }
                this._bottom = (this._bottom - 1 + data.length) % data.length;
                boundary.bottom--;
                boundary.top!=0 && boundary.top--;
 
            } else {
                for (var i = dataIndex; i <= bottom; i++) {
                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;
                    this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });
                }
                if (this._dummy) {
                    var _style = this._dummy.style;
                    _style.height = Math.max( 0, parseFloat( _style.height ) - this._rowHgt ) + 'px';
                }
            }
            this.$addon.arrayUtils(content, 'removeAt', dataIndex);
        } else {
            this.$addon.arrayUtils(content, 'removeAt', dataIndex);
            if (dataIndex < top) {

                for (var i = top; i <= bottom; i++) {
                    var cIndex = (this._top + i - top + rows.length) % rows.length;
                    this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i == content.length ? (top - 1) : i] });
                    if (i == bottom) {
                        this.regex(rows[cIndex], true);
                        this._bottom = (this._bottom - 1 + data.length) % data.length;
                        this._top = (this._top - 1 + data.length) % data.length;
                    }
                }

                boundary.bottom--;
                boundary.top--;

                var _style = this._dummy.style;
                _style.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style.transform.match(/[\d|.]+/ig)[ 0 ] ) - this._rowHgt ) ) + 'px)';
                if (this._dummy1) {

                    var _style1 = this._dummy1.style;
                    _style1.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style1.transform.match( /[\d|.]+/ig )[ 0 ] ) - this._rowHgt ) ) + 'px)';
                }

            } else if (dataIndex > bottom) {
                if (this._dummy) {
                    this._dummy.style.height = Math.max(0, parseFloat(this._dummy.style.height) - this._rowHgt) + 'px';
                }
            }

            if( content.length < this.data.ltPropContentLength && !removed ){
                    Lyte.arrayUtils( data, 'pop' );
            }
        }

        delete this._prevent;
    }

    scrollToRecord(rowIndex, isImmediate, scrollTop) {
        var content = this.data.ltPropContent,
            contentLength = content.length;

        if (rowIndex == undefined || rowIndex < 0 || rowIndex >= contentLength) {
            return;
        }

        if (!this._rowHgt) {
            this.$node.scrollTable();
        }

        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.clear(this._scrollToRecord);

        isImmediate ? this.processScrollToRecord( rowIndex , scrollTop ) : this._scrollToRecord = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.measure(this.processScrollToRecord.bind(this, rowIndex));

        // this.processScrollToRecord( rowIndex );
    }

    processScrollToRecord(rowIndex, _scrollTop) {
        var boundary = this._boundary,
        top = boundary.top,
        bottom = boundary.bottom,
        content = this.data.ltPropContent,
        data = this.data.ltPropData,
        contentLength = data.length,
        __length = content.length,
        step = this._step,
        rowHeight = this._rowHgt,
        scrollDiv = this.scrollDiv,
        offsetHeight = scrollDiv.offsetHeight,
        scrollHeight = scrollDiv.scrollHeight,
        scrollTop = scrollDiv.scrollTop,
        possible_per_view = Math.floor( offsetHeight / rowHeight ),
        scrollPosition = Math.max(0, Math.min(rowIndex, __length - Math.min( contentLength, possible_per_view ) ) ),
        newScrollTop = scrollPosition * rowHeight,
        scrollToSet,
        __tags = this.data.ltPropTags;

        if( content.length <= contentLength ){
            scrollToSet = Math.max( 0, Math.min( scrollHeight - offsetHeight, rowIndex * rowHeight ) );
        } else if( bottom - possible_per_view >= rowIndex ) {
            scrollToSet = newScrollTop;
        } else {
            if (scrollPosition != rowIndex) {
                newScrollTop += (step - offsetHeight);
                var thead = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __tags.thead, this.$node).get(0);
                if (thead) {
                    newScrollTop += thead.offsetHeight;
                }
            }

            var scrollHeight = scrollDiv.scrollHeight,
            maxScrollTop = scrollHeight - offsetHeight,
            diff = step - offsetHeight,
            rows = this.arrayFrom(_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __tags.tbody + ' ' + __tags.tr + ':not(.dummy)', this.$node)),
            fact = Math.floor(scrollPosition / contentLength),
            newscrollPosition = scrollPosition % contentLength;

            for (var i = 0; i < contentLength; i++) {
                var cIndex = scrollPosition + i,
                domIndex = cIndex % contentLength,
                dom = rows[ domIndex ],
                iteration = fact /*+ (i < newscrollPosition ? 1 : 0)*/;

                if( cIndex >= __length ){
                    if( scrollPosition % contentLength < domIndex ){
                        iteration--;
                    }
                    cIndex -= contentLength;
                } else {
                    if( scrollPosition % contentLength > domIndex ){
                        iteration++;
                    }
                }

                this.$component.set(data[domIndex], { index: cIndex, body: content[cIndex] });

                this.cellSet(dom, "translateY(0px)")
                for (var j = 0; j < iteration; j++) {
                    this.regex(dom);
                }
            }

            if( !this._dummy ){
                this.createDummy( this.$node.querySelector( __tags.tbody ) );
            }

            var boundary_top = Math.min( scrollPosition, __length - contentLength );

            this._dummy.style.transform = 'translateY(' + ( boundary_top * rowHeight ) + 'px)';
            if (this._dummy1) {
                this._dummy1.style.transform = 'translateY(' + ( boundary_top * rowHeight) + 'px)';
            }
            scrollToSet = newScrollTop;
            boundary.top = boundary_top;
            boundary.bottom = boundary_top + contentLength - 1;
            this._top = boundary_top % contentLength;
            this._bottom = ( boundary_top + contentLength - 1) % contentLength;
        }

        var scrollFn = function (  ) {
            scrollDiv.querySelector( 'lyte-table-structure' ).style.height = ( contentLength * rowHeight ) + 'px';
            scrollDiv.scrollTop = scrollToSet;
        }
        if( _scrollTop != void 0 ){
            scrollToSet = _scrollTop;
            scrollFn();
        }else{
            window.requestAnimationFrame( scrollFn );
        }
        
    }

    calculateRowHeight() {
        let tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody );
        let tr = tbody[0].children[0];
        let rowHeight = tr && tr.getBoundingClientRect().height;

        return this._rowHgt = rowHeight;
    }

    update_aria(cell) {
        var row = cell.parentNode,
        index = this.get_children( row ).indexOf( cell ),
        table = row.parentNode.parentNode,
        sA = "setAttribute",
        role = "role",
        __tags = this.data.ltPropTags;

        table[ sA ]( role, this.data.ltPropRole );
        
        Array.from( this.get_children( table ) ).forEach( function( item ){

            if( /^div$/i.test( item.tagName || "" ) ){
                return;
            }

            item[ sA ]( role, "rowgroup" );

            var name = item.tagName.toLowerCase() == __tags.thead ? 'columnheader' : 'cell';

            Array.from( this.get_children( item ) ).forEach( function( row ){
                row[ sA ]( role, 'row' );

                var __cell = this.get_children( row )[ index ];

                if( __cell ){
                    __cell[ sA ]( role, name );
                }
            }.bind( this ) );
        }.bind( this ) );
    }

    get_children(__elem) {
        var elems = __elem.length != void 0 ? Array.from( __elem ) : [ __elem ],
        ret = [];

        elems.forEach( function( item ){
            Array.from( item.children ).forEach( function( __item ){
                if( !/template/i.test( __item.tagName ) ){
                    ret.push( __item );
                }
            });
        });

        return ret;
    }

    get_nth_cell(row, index) {
        var children = this.get_children( row ),
        __len = children.length,
        __count = 0;

        if( this.data.ltPropFromListview ){
            return children[ index ];
        }
        for( var i = 0; i < __len; i++ ){
            var __cell = children[ i ];
            if( __count == index ){
                return __cell;
            } else if( __count > index ){
                break;
            }

            __count += ( __cell.colSpan || 1 );
        }
    }

    update_collapse(frm_update) {
        if( this.__from_collapse ){
            return;
        }
        var cells = Array.from( this.$node.getElementsByClassName( 'lyteHeaderCellCollapsed' ) );
        cells.forEach( function( item ){
            this.toggle_column( item, true, frm_update );
        });
    }

    toggle_column(__cell, to_collapse, frm_update) {
        var __index = Array.from( __cell.parentNode.children ).indexOf( __cell ),
        header_cls = "lyteHeaderCellCollapsed",
        body_cls = "lyteCellCollapsed",
        tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody ),
        rows = this.get_children( tbody ),
        __is_sticky = this.data.ltPropStickyTable;

        __cell.classList[ to_collapse ? 'add' : "remove" ]( header_cls );

        rows.forEach( function( item, index ){
            var __elem = this.get_nth_cell( item, __index );

            if( __elem ){
                if( !index ){
                    if( to_collapse ){
                        __elem.rowSpan = rows.length;
                    } else {
                        __elem.rowSpan = 1;
                    }
                    __elem.classList[ to_collapse ? "add" : "remove" ]( "lyteCollapseFirstCell" );
                }

                __elem.classList[ to_collapse ? "add" : "remove" ]( body_cls );
            }
        }.bind( this ) );

        if( !this.__from_collapse && !frm_update && ( __is_sticky || __cell.classList.contains( 'lyteTableFixed' ) ) ){
            _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.clear( this.__collpse_fdom );
            this.__from_collapse = true;
            this.__collpse_fdom = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default().fastdom.measure( function(){
                delete this.__collpse_fdom;
                this.$node[ __is_sticky ? "reset" : "scrollTable" ]();
                delete this.__from_collapse;
            }.bind( this ) );
        }
    }

    collapse_column(__cell) {
        this.toggle_column( __cell, true );
    }

    expand_column(__cell) {
        this.toggle_column( __cell );
    }

    static observers(arg1) {
        return Object.assign(super.observers({
            initProcess1 : function( arg ){
                var __this = this,
                __data = __this.data,
                is_reset = arg && arg.item == "ltPropReset";

                if( __this._prevent ){
                    return
                }

                if( is_reset && arg.newValue == false ){
                    return;
                }

                if( __data.ltPropInfiniteScroll ){
                    var table = __this.$node.getElementsByTagName( __data.ltPropTags.table )[ 0 ],
                    content = __data.ltPropContent || [],
                    __length = content.length,
                    len = Math.min( __data.ltPropContentLength || __length, __length ),
                    data = [];

                    if( __length == 0 && !arg ){
                        return;
                    }

                    if( table ){
                        table.style.height = "auto";
                    }

                    for( var i = 0; i < len; i++ ){
                        data[ i ] = {
                            body : content[ i ],
                            checked : false,
                            index : i
                        };
                    }

                    if( __data.fromListView ){
                        var act_data = __data.ltPropData,
                        arr_util = this.$addon.arrayUtils,
                        obj_util = this.$addon.objectUtils;

                        data.forEach( function( item, index ){
                            var __cur = act_data[ index ];

                            if( __cur ){
                                obj_util( __cur, 'add', 'body', item.body );
                                obj_util( __cur, 'add', 'index', item.index );
                                obj_util( __cur, 'add', 'checked', item.checked );
                            }else {
                                arr_util( act_data, 'insertAt', item.index, item );
                            }
                        });

                        arr_util( act_data, 'splice', data.length, act_data.length - data.length );

                    } else {
                        this.setData( 'ltPropData', data );
                    }

                    var __dummy = __this._dummy,
                    __dummy1 = __this._dummy1,
                    __scrolldiv = __this.scrollDiv,
                    __translate = "translateY(0px)";

                    delete __this._stopScroll;

                    if( arg ){
                        __dummy && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __dummy ).css({
                            height : 0,
                            transform : __translate
                        });

                        __dummy1 && _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __dummy1 ).css( 'transform', __translate );

                        __scrolldiv.scrollTop = 0;
                        __scrolldiv.scrollLeft = 0;
                    }

                    __this._boundary = {
                        top : __this._top = 0,
                        bottom : __this._bottom = Math.max( len - 1, 0 )
                    };
                }

                if( is_reset ){
                    this.setData( arg.item, false );
                }
            }.observes( 'ltPropContent.[]', 'ltPropReset' ).on( 'init' ),

            // border 

            borderChangeObs: function () {
                this.borderChange.call(this);
            }.observes('ltPropBorder').on('didConnect'),

            widthObsObs: function () {
                this.widthObs.call(this);
            }.observes('ltPropWidth').on('didConnect'),

            heightObsObs: function () {
                this.heightObs.call(this);
            }.observes('ltPropHeight').on('didConnect'),

            sortableObs: function () {
                !this.data.ltPropStickyTable && this.sortable();
            }.observes('ltPropColumnSortable').on('didConnect')
        }), arg1);
    }

    includes() {
        return [_node_modules_zoho_lyte_ui_component_mixins_lyte_table_utils_js__WEBPACK_IMPORTED_MODULE_3__.LyteTableUtilsMixin, _node_modules_zoho_lyte_ui_component_mixins_lyte_table_sortable_js__WEBPACK_IMPORTED_MODULE_2__.LyteTableSortableMixin];
    }

    _() {
        _;
    }
}

LyteTableComponent._template = "<template tag-name=\"lyte-table\"> <div class=\"lyteTableScroll\" onmousedown=\"{{action('rowMouseDown',event)}}\" ontouchstart=\"{{action('rowMouseDown',event)}}\"> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{expHandlers(ltPropSortable,'&amp;&amp;',ltPropInfiniteScroll)}}\" is=\"case\" lc-id=\"lc_id_0\"> <div class=\"lyteTableSortablePlaceholder lyteTableSortablePlaceholderHidden\"></div> </template></template> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{expHandlers(ltPropYield,'==',false)}}\" is=\"case\" lc-id=\"lc_id_0\"> <lyte-table-structure id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" role=\"{{ltPropRole}}\"> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{ltPropHeaderLabelKey}}\" is=\"case\" lc-id=\"lc_id_0\"> <lyte-colgroup> <template items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\" is=\"for\" _new=\"true\"> <lyte-col></lyte-col> </template> </lyte-colgroup> <lyte-thead role=\"rowgroup\"> <lyte-tr role=\"row\"> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{ltPropHeader.length}}\" is=\"case\" lc-id=\"lc_id_0\"><template items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\" is=\"for\" _new=\"true\"> <lyte-th id=\"{{list.id}}\" class=\"{{list.class}}\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\" role=\"columnheader\"> {{unescape(list[ltPropHeaderLabelKey])}} </lyte-th> </template> </template></template> </lyte-tr> </lyte-thead> </template></template> <lyte-tbody role=\"rowgroup\" class=\"{{if(ltPropSortable,'lyteTableWithSortableRow')}}\"> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{ltPropInfiniteScroll}}\" is=\"case\" lc-id=\"lc_id_0\"> <template is=\"for\" items=\"{{ltPropData}}\" item=\"list\" index=\"indexVal\"> <lyte-tr id=\"{{list.body.id}}\" class=\"{{list.body.class}}\" role=\"row\" aria-rowindex=\"{{list.index}}\"> <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\" index=\"index\"> <lyte-td role=\"cell\" aria-colindex=\"{{index}}\"> <div style=\"height: {{ltPropCellHeight}}\"> {{unescape(lyteUiGetValue(list.body,header[ltPropBodyLabelKey]))}} </div> </lyte-td> </template> </lyte-tr> </template> </template><template default=\"\"> <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"> <lyte-tr id=\"{{list.id}}\" class=\"{{list.class}}\" role=\"row\"> <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\" index=\"index\"> <lyte-td role=\"cell\" aria-colindex=\"{{index}}\">{{unescape(lyteUiGetValue(list,header[ltPropBodyLabelKey]))}}</lyte-td> </template> </lyte-tr> </template> </template></template> </lyte-tbody> </lyte-table-structure> </template><template case=\"{{ltPropInfiniteScroll}}\" is=\"case\" lc-id=\"lc_id_1\"> <lyte-yield yield-name=\"yield\" lt-prop-data=\"{{ltPropData}}\"></lyte-yield> </template><template default=\"\"> <lyte-yield yield-name=\"yield\"></lyte-yield> </template></template> </div> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{expHandlers(ltPropResize.vertical,'||',ltPropResize.horizontal)}}\" is=\"case\" lc-id=\"lc_id_0\"> <lyte-table-resize ontouchstart=\"{{action('tableResize',event,'both')}}\" onmousedown=\"{{action('tableResize',event,'both')}}\"></lyte-table-resize> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{ltPropResize.vertical}}\" is=\"case\" lc-id=\"lc_id_0\"> <lyte-table-vertical-resize ontouchstart=\"{{action('tableResize',event,'vert')}}\" onmousedown=\"{{action('tableResize',event,'vert')}}\"></lyte-table-vertical-resize> </template></template> <template is=\"switch\" l-c=\"true\" _new=\"true\"><template case=\"{{ltPropResize.horizontal}}\" is=\"case\" lc-id=\"lc_id_0\"> <lyte-table-horizontal-resize ontouchstart=\"{{action('tableResize',event,'hori')}}\" onmousedown=\"{{action('tableResize',event,'hori')}}\"></lyte-table-horizontal-resize> </template></template> </template></template> </template>";;
LyteTableComponent._dynamicNodes = [{"t":"a","p":[1]},{"t":"s","p":[1,1],"c":{"lc_id_0":{"dN":[],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{}},"hd":true,"co":["lc_id_0"],"in":2,"sibl":[1]},{"t":"s","p":[1,3],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1],"cn":"lc_id_0"},{"t":"s","p":[1,1],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1,1],"cn":"lc_id_0"},{"t":"f","p":[1,1],"dN":[{"t":"cD","p":[1],"in":0}],"dc":[0],"hc":true,"trans":true,"in":4,"sibl":[3],"cn":"lc_id_0"},{"t":"cD","p":[1],"in":3,"sibl":[2],"cn":"lc_id_0"},{"t":"s","p":[3,1,1],"c":{"lc_id_0":{"dN":[{"t":"a","p":[0],"cn":"lc_id_0"},{"t":"f","p":[0],"dN":[{"t":"a","p":[1]},{"t":"tX","p":[1,1]},{"t":"cD","p":[1],"in":0}],"dc":[0],"hc":true,"trans":true,"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{"dc":[0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":2,"sibl":[1],"cn":"lc_id_0"},{"t":"cD","p":[3,1],"in":1,"sibl":[0],"cn":"lc_id_0"},{"t":"cD","p":[3],"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{"dc":[4,3,2,1,0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":3,"sibl":[2],"cn":"lc_id_0"},{"t":"a","p":[1,3],"cn":"lc_id_0"},{"t":"s","p":[1,3,1],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1],"cn":"lc_id_0"},{"t":"f","p":[1],"dN":[{"t":"a","p":[1]},{"t":"a","p":[1,1]},{"t":"f","p":[1,1],"dN":[{"t":"a","p":[1]},{"t":"a","p":[1,1],"a":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'height: '","ltPropCellHeight"]}}}},{"t":"tX","p":[1,1,1]},{"t":"cD","p":[1],"in":0}],"dc":[0],"hc":true,"trans":true,"in":1,"sibl":[0]},{"t":"cD","p":[1],"in":0}],"dc":[1,0],"hc":true,"trans":true,"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{"dN":[{"t":"a","p":[1],"cn":"default"},{"t":"f","p":[1],"dN":[{"t":"a","p":[1]},{"t":"a","p":[1,1]},{"t":"f","p":[1,1],"dN":[{"t":"a","p":[1]},{"t":"tX","p":[1,0]},{"t":"cD","p":[1],"in":0}],"dc":[0],"hc":true,"trans":true,"in":1,"sibl":[0]},{"t":"cD","p":[1],"in":0}],"dc":[1,0],"hc":true,"trans":true,"in":0,"cn":"default"}]},"dc":{"lc_id_0":{"dc":[0],"hc":true,"trans":true},"default":{"dc":[0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":2,"sibl":[1],"cn":"lc_id_0"},{"t":"cD","p":[1,3],"in":1,"sibl":[0],"cn":"lc_id_0"},{"t":"cD","p":[1],"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true},"lc_id_1":{"dN":[{"t":"a","p":[1],"cn":"lc_id_1"},{"t":"i","p":[1],"in":0,"cn":"lc_id_1"}],"cdp":{"t":"a","p":[1]},"dcn":true}},"d":{"dN":[{"t":"i","p":[1],"in":0,"cn":"default"}]},"dc":{"lc_id_0":{"dc":[3,2,1,0],"hc":true,"trans":true},"lc_id_1":{"dc":[0],"hc":true,"trans":true},"default":{"dc":[0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0","lc_id_1"],"hc":true,"trans":true,"in":1,"sibl":[0]},{"t":"s","p":[3],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1],"cn":"lc_id_0"},{"t":"cD","p":[1],"in":2,"sibl":[1],"cn":"lc_id_0"},{"t":"s","p":[3],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1],"cn":"lc_id_0"},{"t":"cD","p":[1],"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{"dc":[0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":1,"sibl":[0],"cn":"lc_id_0"},{"t":"s","p":[5],"c":{"lc_id_0":{"dN":[{"t":"a","p":[1],"cn":"lc_id_0"},{"t":"cD","p":[1],"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{"dc":[0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":0,"cn":"lc_id_0"}],"cdp":{"t":"a","p":[0]},"dcn":true}},"d":{},"dc":{"lc_id_0":{"dc":[2,1,0],"hc":true,"trans":true}},"hd":true,"co":["lc_id_0"],"hc":true,"trans":true,"in":0},{"type":"dc","trans":true,"hc":true,"p":[1,0]}];;

LyteTableComponent._observedAttributes = [
    "ltPropContent",
    "ltPropHeader",
    "ltPropId",
    "ltPropClass",
    "ltPropBorder",
    "ltPropHeaderLabelKey",
    "ltPropBodyLabelKey",
    "ltPropWidth",
    "ltPropHeight",
    "ltPropResize",
    "ltPropFixedColumnClass",
    "ltPropYield",
    "ltPropScroll",
    "ltPropColumnSortable",
    "ltPropScrollbarOption",
    "ltPropDualResize",
    "ltPropData",
    "ltPropInfiniteScroll",
    "ltPropCellHeight",
    "ltPropContentLength",
    "ltPropPreventScrollbar",
    "ltPropRole",
    "ltPropStickyTable",
    "ltPropScrollStep",
    "ltPropPreventTableModify",
    "ltPropSortDummyColumClass",
    "ltPropNavigation",
    "ltPropReset",
    "ltPropTags",
    "ltPropSortable",
    "ltPropContainment",
    "lyteUnbound",
    "ltPropFromListview",
    "ltPropFixResizeCursor",
    "columns",
    "nonFixedColumn",
    "minWidth1",
    "minWidth2",
    "secondaryData",
    "boundary",
    "rowHeights",
    "fromListView"
];

if (!window._lyteUiUtils.registeredCustomElements['lyte-th']) {
    window._lyteUiUtils.registeredCustomElements['lyte-th'] = true;

    /**
     * @customElement lyte-th,lyte-td
     */
    class LyteThCustomElements extends _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__.LyteUiComponentComponentRegistry.CustomElements {
        lookups() {
            return [{
                component: _node_modules_zoho_lyte_ui_component_components_component_js__WEBPACK_IMPORTED_MODULE_1__.LyteUiComponentComponentRegistry
            }];
        }

        constructor() {
            super();
        }

        static get observedAttributes() {
            return [ 'fixed', 'resize', 'icon', 'sticky-position', "collapse" ];
        }

        getTable() {
            var lyteNode = this.$node;
            var query = "lyte-table";
            return (lyteNode.__table || (lyteNode.__table = lyteNode.closest ? lyteNode.closest( query ) : _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( lyteNode ).closest( query ).get( 0 )));
        }

        getSticky() {
            var lyteNode = this;
            var __sticky = lyteNode.__is_sticky;
            return __sticky == void 0 ? ( lyteNode.__is_sticky = lyteNode.getTable().ltProp( 'stickyTable' ) ) : __sticky;
        }

        connectedCallback() {
            var lyteNode = this;
            var table = lyteNode.getTable(),
            $node = lyteNode.$node;

            if( table && table.ltProp( 'role' ) && table.ltProp( 'yield' ) ){
                table.component.update_aria( $node );
            }

            if( $node.parentNode.previousElementSibling ){
                lyteNode.$node.classList.add( "lyteTableSecondaryHeader" );
            }
        }

        attributeChangedCallback(attr, oldVal, newVal) {
            var lyteNode = this.$node;

            var $node = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( lyteNode );

            switch (attr) {
                case 'fixed': {
                    var is_enable = newVal == "enable";

                    $node[ ( is_enable ? 'add' : "remove" ) + 'Class' ]( 'lyteFixedColumn' );
                    if( this.getSticky() ){
                        lyteNode.__table.component.checkIntersection.call( lyteNode, is_enable );
                    }
                }
                    break;
                case 'resize': {
                    var ns = 'lyte-tablehead-resize';
                    if( newVal == "enable" ){
                        var thead = document.createElement( ns ),
                        __add = "addEventListener",
                        fn = this.resize;

                        thead[__add]('mousedown', fn);
                        thead[__add]('touchstart', fn);

                        lyteNode.appendChild( thead );
                    } else {
                        var thead = lyteNode.getElementsByTagName( ns )[ 0 ];
                        if( thead ){
                            lyteNode.removeChild( thead );
                        }
                    }
                }
                break;
                case 'icon' : {
                    $node[ ( newVal == "disable" ? 'add' : "remove" ) + 'Class' ]( 'lytePreventIcon' );
                }
                break;
                case 'sticky-position' : {
                    if( $node.attr( 'fixed' ) == "enable" && this.getSticky() ){
                        var is_enable = newVal == "right",
                        __table = lyteNode.__table.component,
                        fn = is_enable ? 'add' : "remove",
                        __class = 'lyteTableRightFixed';

                        if( !is_enable && !$node.hasClass( __class ) ){
                            return;
                        }   

                        __table.stickyFunction( lyteNode, false, fn + 'Class', __class );
                        __table.checkIntersection.call( lyteNode, is_enable, true );
                    }
                }
                break;
                case 'collapse' : {
                    var __table = this.getTable();

                    if( __table ){
                        if( newVal == "true" ){
                            __table.component.collapse_column( lyteNode );
                        } else if( oldVal == "true" ){
                            __table.component.expand_column( lyteNode );
                        }
                    }
                }
                break;
            }
        }

        resize(event) {
            var lyteNode = this;
            if (lyteNode.parentNode.classList.contains('lyteTableFixed')) {
                return;
            }
            var table = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()(event.target).closest('lyte-table')[0];
            table.component.getActions("tableResize").call(table.component, event);
        }

        disconnectedCallback() {
            var lyteNode = this.$node;
            if( lyteNode.__is_sticky ){
                lyteNode.__table.component.disconnectedCallback.call( lyteNode );
            }
            delete lyteNode.__table;
        }

        _() {
            _;
        }
    }

    LyteThCustomElements.options = {clone : {allCallbacks : false}};

    LyteThCustomElements.register("lyte-th");

    window.resizeTable = function(evt) {
        if (evt && evt.type == 'resize' && _lyteUiUtils.isMobile) {
            return;
        }

        var fn = function( item ){
            var __elem = item.component.scrollDiv,
            $elem = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_4___default()( __elem );
            __elem && $elem.resetScrollbar && $elem.resetScrollbar();
        },
        is_orient = evt && evt.type == "orientationchange";

        Array.from(document.body.getElementsByTagName('lyte-table')).forEach(function (item) {
            if (is_orient) {
                setTimeout(fn.bind(this, item), 500);
            } else {
                fn(item);
            }
        });
    };
}


/**
 * @syntax nonYielded
 *   <lyte-table  lt-prop-content='[{"cityName" : "Agra","serialNo" : "1"},{"cityName" : "Mysore", "serialNo" : "2"}]' lt-prop-header='[{"data" : "From", "bodyData" : "cityName"},{"data" : "No", "bodyData" : "serialNo"}]' lt-prop-header-label-key='data' lt-prop-body-label-key='bodyData' >
 *   </lyte-table>
 */

/**
 * @syntax yielded
 * <lyte-table lt-prop-yield="true">
 *      <template is="registerYield" yield-name="yield">
 *          <lyte-table-structure>
 *             <lyte-thead>
 *                <lyte-tr>
 *                   <lyte-th>From</lyte-th>
 *                   <lyte-th>No</lyte-th>
 *                   <lyte-th>Name</lyte-th>
 *                </lyte-tr>
 *             </lyte-thead>
 *             <lyte-tbody>
 *                <lyte-tr>
 *                   <lyte-td>Agra</lyte-td>
 *                   <lyte-td>1</lyte-td>
 *                   <lyte-td>Tajmahal</lyte-td>
 *                </lyte-tr>
 *                <lyte-tr>
 *                   <lyte-td>Mysore</lyte-td>
 *                   <lyte-td>2</lyte-td>
 *                   <lyte-td>Mysorepalace</lyte-td>
 *                </lyte-tr>
 *             </lyte-tbody>
 *          </lyte-table-structure>
 *      </template>
 *  </lyte-table>
 */

/**
 * @syntax Infinite scroll
 * @attribute ltPropYield=true
 * @attribute ltPropInfiniteScroll=true
 *  <lyte-table style = 'height: 350px;' lt-prop-infinite-scroll = true lt-prop-yield = true lt-prop-content = {{contentJSON}} scroll-end = {{method('someMethod')}}>
 *   <template is = 'registerYield' yield-name = 'yield'>
 *       <lyte-table-structure>
 *           <lyte-thead>
 *               <lyte-tr>
*                  <lyte-th> From </lyte-th>
*                  <lyte-th> No </lyte-th>
*                  <lyte-th> Name </lyte-th>
 *              </lyte-tr>
 *           </lyte-thead>
 *           <lyte-tbody>
 *             <lyte-tr>
 *               <lyte-td> Agra </lyte-td>
 *               <lyte-td> 1 </lyte-td>
 *               <lyte-td> Taj Mahal </lyte-td>
 *             </lyte-tr>
 *              <lyte-tr>
 *               <lyte-td> Mysore </lyte-td>
 *               <lyte-td> 2 </lyte-td>
 *               <lyte-td> Mysore palace </lyte-td>
 *             </lyte-tr>
 *           </lyte-tbody>
 *       </lyte-table-structure>
 *   </template>
 *  </lyte-table>
 */


LyteTableComponent.register("lyte-table", {
    hash: "LyteTableComponent_18",
    refHash: "C_lyte-ui-component_@zoho/lyte-ui-component_2"
});
 


/***/ }),

/***/ 38957034:
/*!****************************************************************************!*\
  !*** ./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-sortable.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LyteTableSortableMixin": () => (/* binding */ LyteTableSortableMixin)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 76928134);
/* harmony import */ var _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/@slyte/core/index.js */ 20917581);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-dom/modules/lyte-dom-utils.js */ 92838254);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__);

var _ = {};

(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__._defineProperty)(_, {
    "Mixin": function() {
        return _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__.Mixin;
    }
});




let LyteTableSortableMixin = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomClass)(function(arg1, overrides, LyteTableSortableMixin) {
    class _LyteTableSortableMixin extends (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.getClass)([_node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__.Mixin], arg1, LyteTableSortableMixin) {
        rowMouseDown(evt) {
                     
               var _this = this ,
                   tags = _this.data.ltPropTags,
                   tr = evt.target.closest(tags.tr) , 
                   tbody = tr.closest(tags.tbody);
               if( tbody != void 0 ){
                   var table = tbody.closest('lyte-table'),
                       index = Array.from( tr.parentElement.children ).indexOf( tr ),
                       actual_index = index ,
                       cur_index = actual_index  ,
                       data = _this.data.ltPropData , 
                       isFirst = true , 
                       trTransform = tr.style.transform ,
                       content = _this.data.ltPropContent ,
                       boundary = _this._boundary , 
                       isTouch = Boolean(evt.touches),
                       hasContainment = Boolean(_this.data.ltPropContainment) ,
                       containElem = hasContainment ? _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()(_this.$node).find(_this.data.ltPropContainment)[0] : undefined,
                       containElemClient = containElem != void 0 ? containElem.getBoundingClientRect() : undefined , 
                       placeholder = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()(this.$node).find( '.lyteTableSortablePlaceholder' ).get(0),
                       outOfBound = false, yRelatedToElement , reachedTop , reachedEnd , diff = void 0;

                   if(tr.parentElement.tagName.toLowerCase() == _this.data.ltPropTags.tbody){
                       if( this.getMethods( 'onRowSelect' ) ){
                           let ret = this.executeMethod( 'onRowSelect' , evt  , data[actual_index].index  , actual_index , _this.$node );
                           if( ret === false ){
                               return;
                           }
                       } 

                       evt.preventDefault();

                       placeholder.classList.remove( 'lyteTableSortablePlaceholderHidden' );
                   
                       var findElement = function ( isPrev , isMouseUp ){
                           if( isMouseUp ){
                               let arr = Array.from(tbody.children);
                               for( let i = 0 ; i < arr.length ; i++ ){
                                   let cur = arr[i];
                                   if( cur.classList.contains('lyteTableRowSorting') ){
                                       return i;
                                   }
                               }
                           }else{
                               let curIndex =_this.data.ltPropData[cur_index].index ,
                                   findIndex = isPrev ? getIndex(  curIndex == 0 ? data.length-1 : curIndex - 1 ) :
                                                        curIndex == data.length-1 ? curIndex == content.length-1 ? undefined : 0 : getIndex(curIndex + 1 ),
                                   arr = Array.from( tbody.children );
                               if(findIndex == undefined){
                                   return;
                               }
                               for( let i = 0, j = 0 ; i < arr.length ; i ++ ){
                                   let cur = arr[i];
                                   if( !(cur.classList.contains('dummy')) ){
                                       if( j == findIndex ){
                                           return arr[i];
                                       }
                                       j++
                                   }
                               }
                           }
                       },
                       makeElementDraggable = function(){
                           var width = []
                           Array.from( tr.children ).forEach( function(td){
                               width.push( window.getComputedStyle(td).width );
                           }); 
                           tr.classList.add('lyteTableRowSorting'); 
                       },
                       getIndex = function( index ){
                           var find = function(obj){
                               return obj.index === index;
                           }
                           return _this.data.ltPropData.findIndex(  find );
                       },
                       checkLimit = function (num){
                           return 0 <= num && num < _this.data.ltPropData.length ;
                       },
                       changePlaceHolder = function( _tr ){
                           placeholder.style.transform = "";
                           if( _tr.style.transform ){
                               placeholder.style.transform = _tr.style.transform;
                           }
                           placeholder.style.top = _tr.offsetTop + "px";
                           placeholder.style.left = _tr.offsetLeft + "px";
                           placeholder.style.width = _tr.offsetWidth + "px";
                           placeholder.style.height = _tr.offsetHeight + "px";
                       };
                   
                       changePlaceHolder( tr );
                       makeElementDraggable();
                   
                       var initialY = isTouch ? evt.touches[0].clientY : evt.clientY;
                            
                       var mouseup = function(event){
                           let currentIndex = findElement( false , true ) ,
                           scrollTop = _this.scrollDiv.scrollTop;
                           evt.preventDefault();

                           placeholder.classList.add( 'lyteTableSortablePlaceholderHidden' );
                       
                               if(_this.getMethods( 'onBeforeRowDrop' )){
                                   var ret = _this.executeMethod( 'onBeforeRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node  );
                               } 

                               if(ret === false){
                                   let removeIndex = cur_index , 
                                       cur_data = Object.assign( {} , data[removeIndex] );

                                   _this.removeRow(data[removeIndex].index);
                                   _this.insertRow(data[actual_index].index , cur_data.body);

                                   if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){
                                       _this.scrollToRecord( data[removeIndex].index , true , scrollTop );
                                   }
                               }
                               tr.style.transform = trTransform;
                               tr.classList.remove('lyteTableRowSorting')

                               _this.getMethods( 'onRowDrop' ) && _this.executeMethod( 'onRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node );
                           
                               let elem = tbody.children[getIndex(actual_index)];
                               if(elem){
                                   elem.style.top = ""; elem.style.right = "";
                               }
                           
                           
                           document.removeEventListener( isTouch ? 'touchmove' : 'mousemove', mousemove)
                           document.removeEventListener( isTouch ? 'touchend' : 'mouseup', mouseup);
                       },

                       parseNum = function (number){
                           let match = number.match(/-?\d+(\.\d+)?/);
                           return match ? parseFloat(match[0]) : 0
                       },
                       isInRange = function( tr , y , isUp){
                           let client = tr.getBoundingClientRect() ,
                               topCheck = containElemClient.top < client.top ,
                               bottomCheck = ( client.top + client.height ) < (containElemClient.top + containElemClient.height );

                           if( isUp == void 0 ){ return topCheck && bottomCheck }

                           reachedTop = false; reachedEnd = false;

                           if( !topCheck ) { 
                                reachedTop = true; }
                           else if( !bottomCheck ) { reachedEnd = true; }

                           if( reachedTop ){ 
                               topCheck = !isUp && ( ( containElemClient.top < y ) && ( y < containElemClient.top + containElemClient.height-diff ) ) && diff >= 0;
                           }else if( reachedEnd ){
                               bottomCheck = isUp && ( containElemClient.top < y && y < (containElemClient.top + containElemClient.height ) ) && diff <= 0
                           }
                            return topCheck && bottomCheck 

                       },
                       fixTop = function ( isUp , returnBoundElem , getDiff){
                           var trClient = tr.getBoundingClientRect(),
                               _diff , transformY ,
                               top = _this._top , bottom = _this._bottom , 
                               contentLength = data.length;

                       
                           _diff = isUp ? containElemClient.top - trClient.top : 
                                        (containElemClient.top + containElemClient.height) - (trClient.top + trClient.height);
                           if( getDiff === true ){ 
                               diff = -_diff;
                               return;
                           };
                           transformY = parseNum( tr.style.transform );
                           tr.style.transform = ""; _this.transform( true , tr , transformY + _diff );
                           trClient = tr.getBoundingClientRect();


                           if( !returnBoundElem ) { return; }

                           let reachedEnd = false;

                           for (let i = isUp ? top : bottom ; isUp ? i < (top+contentLength) : (reachedEnd ? i > bottom + 1 : i >= 0) ; isUp ? i++ : i--) {
                               i = isUp ? i%contentLength : i;
                               const element = tbody.children[i] ,
                                     elemClient = element.getBoundingClientRect();

                               if(isUp ? ( elemClient.top >= ( containElemClient.top ) ) : (elemClient.top < (containElemClient.top+containElemClient.height))){
                                   if( isUp ? trClient.top <= elemClient.top : trClient.top >= elemClient.top ){
                                       if(cur_index != i){
                                           return i;
                                       }
                                       return;
                                    }
                               }


                               if( !isUp && i == 0 ){
                                   reachedEnd = true;
                                   i = contentLength;
                               }
                           }
                       
                       }
                   
                       var mousemove = function( event ){
                           isTouch ? null : event.preventDefault();
                           var y = isTouch ? event.touches[0].clientY : event.clientY ;

                           y = (y < 0) ? 0 : y;

                           var isUp = ( initialY > y) , isDown = ( initialY < y ),
                               isRange , targetIndex , 
                               neighbour = isDown ? findElement( false ) : isUp ? (cur_index == 0 && boundary.top == 0) ? undefined : findElement( true ) : undefined ,
                               check = false;
                           
                           
                           
                           if(isUp || isDown) {

                               let _transform = tr.style.transform;
                               tr.style.transform = "translateY(" + (parseNum(tr.style.transform || "") + ( diff != void 0 ? diff : 0 )- (initialY - y)) + "px)";

                               if(hasContainment){
                                   diff = diff != void 0 ? diff - (initialY - y) : void 0;
                                   isRange = isInRange( tr , y , isUp );
                                   if(!isRange && !outOfBound){
                                       fixTop( isUp , false , true );
                                       check = true ;
                                   }
                               }

                               tr.style.transform = _transform;


                              if( isFirst && _this.getMethods('onRowDragStart') ){
                                  _this.executeMethod( 'onRowDragStart' , event , data[cur_index].index , cur_index , _this.$node );
                              }


                          
                              if( hasContainment && isRange){
                                  if(  outOfBound ){
                                      tr.style.transform = "translateY(" + (parseNum(tr.style.transform || "") + ( diff )) + "px)";
                                      diff = void 0;
                                      outOfBound = false;
                                  }else{
                                      tr.style.transform = "translateY(" + (parseNum(tr.style.transform || "") - (initialY - y)) + "px)";
                                      outOfBound = false;
                                  }
                              }else if( hasContainment && !outOfBound) {
                                  outOfBound = true ;
                                  targetIndex = fixTop( isUp , true );
                              }else if(!hasContainment){
                                  tr.style.transform = "translateY(" + (parseNum(tr.style.transform || "") - (initialY - y)) + "px)";
                              }

                              isFirst = false;  
                              var trClient = tr.getBoundingClientRect();

                              if( (neighbour != void 0 && !outOfBound) || (targetIndex != void 0) ){
                                   let isExceeds = targetIndex == void 0 ? isDown ? ( neighbour.getBoundingClientRect().top < trClient.top ) :
                                                   isUp ?   ( neighbour.getBoundingClientRect().top > trClient.top ) : false : false;

                                   if( (neighbour != void 0 && isExceeds) || (targetIndex != void 0)){
                                       let curData = Object.assign( {} , _this.data.ltPropData[cur_index] ) , 
                                           heightDiff = parseNum(tr.style.transform) - parseNum(trTransform) + ( (isDown ? -1 : 1 ) * tr.offsetHeight ) ,
                                           _curIndex = data[cur_index].index, 
                                           hasTarget = targetIndex != void 0;

                                       tr.style.setProperty('transform' , trTransform ) ;
                                       let scrollTop = _this.scrollDiv.scrollTop;

                                       clearTimeout(_this._ignoreTimeout)
                                       _this.__ignore_scroll = true;

                                       let insertIndex = ( targetIndex != void 0 ? data[targetIndex].index : isDown ? _curIndex+1 : _curIndex-1  ),
                                           removeIndex = _curIndex!=void 0 ? _curIndex : cur_index;

                                       _this.removeRow( removeIndex );
                                       _this.insertRow( insertIndex , curData.body );


                                       if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){
                                           if( _this._rowHgt == undefined ){
                                               _this.__allow_scroll = true;
                                           }
                                           _this.scrollToRecord( _curIndex, true , scrollTop );
                                           _this.__allow_scroll = false;
                                       }

                                       if( hasTarget ){
                                           tr.classList.remove('lyteTableRowSorting');
                                           tr = tbody.children[targetIndex];

                                           changePlaceHolder( tr );

                                           trTransform = tr.style.transform;
                                           tr.classList.add('lyteTableRowSorting');
                                           fixTop(isUp);
                                           cur_index = targetIndex;
                                       }else{
                                           tr = tbody.children[getIndex(removeIndex)] ; neighbour = tbody.children[getIndex(insertIndex)];

                                           changePlaceHolder( neighbour );

                                           tr.classList.remove('lyteTableRowSorting');
                                           neighbour.classList.add('lyteTableRowSorting');
                                           trTransform = neighbour.style.transform;
                                           cur_index = isDown ? checkLimit( cur_index + 1 ) ? cur_index + 1 : 0 : checkLimit( cur_index - 1 ) ? cur_index - 1 : data.length-1;
                                           neighbour.style.transform = "translateY(" + ( ( isDown ? ( cur_index == 0 ) : ( cur_index == data.length - 1 ) ) ?  (parseNum(neighbour.style.transform) + heightDiff ) : heightDiff + parseNum(trTransform) ) + "px)";
                                           tr = neighbour; 
                                       }


                                       index = isDown ? (index + 1) : (index - 1);

                                       _this._ignoreTimeout = setTimeout(() => {
                                           _this.__ignore_scroll = false;
                                       }, 100);
                                   }

                              }
                           }                   
                       
                        initialY =  y;
                       }
                   
                       document.addEventListener( 'mousemove' , mousemove , evt );
                       document.addEventListener( 'mouseup' , mouseup , evt);

                       document.addEventListener( 'touchmove' , mousemove , false );
                       document.addEventListener( 'touchend' , mouseup , false);
                   }   
               }
     
       }

        _() {
            _;
        }
    }

    return overrides(_LyteTableSortableMixin);
});



LyteTableSortableMixin.register({
    hash: "LyteTableSortableMixin_5",
    refHash: "@zoho/lyte-ui-component_3"
});



/***/ }),

/***/ 53716543:
/*!*************************************************************************!*\
  !*** ./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-utils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LyteTableUtilsMixin": () => (/* binding */ LyteTableUtilsMixin)
/* harmony export */ });
/* harmony import */ var _slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @slyte/core/src/lyte-utils */ 76928134);
/* harmony import */ var _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/@slyte/core/index.js */ 20917581);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../node_modules/@zoho/lyte-dom/modules/lyte-dom-utils.js */ 92838254);
/* harmony import */ var _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2__);

var _ = {};

(0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__._defineProperty)(_, {
    "Mixin": function() {
        return _node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__.Mixin;
    }
});




let LyteTableUtilsMixin = (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomClass)(function(arg1, overrides, LyteTableUtilsMixin) {
    class _LyteTableUtilsMixin extends (0,_slyte_core_src_lyte_utils__WEBPACK_IMPORTED_MODULE_0__.getClass)([_node_modules_slyte_core_index_js__WEBPACK_IMPORTED_MODULE_1__.Mixin], arg1, LyteTableUtilsMixin) {
        getScrollDiv() {
            return this.$node.getElementsByClassName( 'lyteTableScroll' )[ 0 ];
        }

        registerInterSection(scrollDiv) {
             this._intersectionObs = new window.IntersectionObserver( this.intersection.bind( this ), { threshold : [ 1 ], root : scrollDiv } )
        }

        detectBrowsers() {
            var userAgent = window.navigator.userAgent
            this._isSafari = /safari/ig.test( userAgent );
            this._FF = /firefox/ig.test( userAgent );
            this._chrome = /Chrome/i.test( userAgent ) && /Google Inc/i.test( window.navigator.vendor );
        }

        getHeaderWidths(headerCells) {
            return headerCells.map( function( cell ){
                return cell.getBoundingClientRect().width;
            });
        }

        getTbody() {
            return this._tbody || this.$node.getElementsByTagName( this.data.ltPropTags.tbody );
        }

        getThead() {
            return this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];
        }

        getRows() {
            return this.$node.getElementsByTagName( this.data.ltPropTags.tr );
        }

        makeFixedColumn(rows, index, left, value) {

            rows.forEach( function( row ){
                var _$L = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( row );
                if( !_$L.hasClass( 'dummy' ) ) {
                    _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( this.get_nth_cell( row, index ) ).css( left, value ).addClass( 'lyteFixedColumn' );
                }
            }.bind( this ) );
        }

        observe(intersection) {
            if( !intersection._observed ){
                this._intersectionObs.observe( intersection );
                intersection._observed = true;
            }
        }

        _setLeftForInterSection(reset) {

            var fastdom = (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom),
            __this = this;


            fastdom.clear( __this._setmeasure );

            __this._setmeasure = fastdom.measure( function(){

                var __tags = __this.data.ltPropTags,
                th_rows = Array.from( __this.$node.querySelectorAll( __tags.thead + ' ' + __tags.tr ) ),
                accumulatedTop = 0;

                th_rows.forEach( function( row, ___index ){
                    var headerCells = __this.get_children( row ),
                    __length = headerCells.length - 1;

                    if( __length + 1 ){
                        var width = __this.getHeaderWidths( headerCells ),
                        top_to_set = accumulatedTop,
                        check_right = true,
                        left = __this.rtlfunc( 'left' );

                        accumulatedTop += row.getBoundingClientRect().height;

                        fastdom.mutate( function(){
                            var tbody = __this.getTbody(),
                            rows = ___index ? [] : __this.get_children( tbody ),
                            intersectionDivs = [],
                            accumulatedWidth = 0,
                            accumulatedLeft = 0,
                            fn = function( cell, index ){
                                var intersection = cell._horizontalIntersectionDiv,
                                __index = check_right ? index : ( __length - index );

                                if( intersection ){
                                    var _hasClass = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( cell ).hasClass( 'lyteTableRightFixed' );
                                    if( ( check_right && _hasClass ) || ( !check_right && !_hasClass ) ){
                                        intersection = void 0;
                                    }
                                }

                                if( intersection ){
                                    intersectionDivs.push( intersection );
                                    intersection.style[ left ] = accumulatedLeft + 'px';
                                    cell.style[ left ] = accumulatedWidth + 'px';

                                    __this.throwEvent( "intersectionSet", cell, left, accumulatedWidth );

                                    __this.makeFixedColumn( rows, __index, left, accumulatedWidth );

                                    accumulatedWidth += width[ __index ];

                                    __this.observe( intersection );

                                    if( intersection._sticked && reset ){
                                        __this.addFixedClass( cell );
                                    }
                                } else {
                                    accumulatedLeft +=  width[ __index ];
                                }

                                if( ___index ){
                                    cell.style.top = top_to_set + 'px';
                                }
                            };

                            headerCells.forEach( fn );
                            check_right = false;
                            left = __this.rtlfunc( 'right' );
                            accumulatedLeft = 0;
                            accumulatedWidth = 0;

                            headerCells.reverse().forEach( fn );

                             ___index ? void 0 : ( __this._intersections = intersectionDivs );
                        });
                    }
                }); 
            });
        }

        intersection(intersections) {
            
            intersections.forEach( function( intersection ){
                this.singleIntersection( intersection );
            }.bind( this ) );
        }

        singleIntersection(intersection) {
            var cell = intersection.target._cell,
            __this = this,
            ns = intersection.intersectionRatio ? 'processUnfix' : 'processFix';

            __this._fixedWidth = __this._fixedWidth || 0;
            __this._rightFixedWidth = __this._rightFixedWidth || 0;
            __this[ ns ]( cell, intersection );
        }

        common_fn(cell, intersection, __remove) {
            var __this = this;

            __this[ __remove ? 'removeFixedClass' : 'addFixedClass' ]( cell );
            intersection.target._sticked = !__remove;
            __this[ __remove ? 'callUnfix' : "callFix" ]( cell );

            if( cell.parentNode.previousElementSibling ){
                return;
            }

            _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom.measure( function(){
                var bcr = cell._bcr || cell.getBoundingClientRect(),
                ns = cell.classList.contains( 'lyteTableRightFixed' ) ? '_rightFixedWidth' : "_fixedWidth";

                if( ( __this[ ns ] += ( bcr.width * ( __remove ? -1 : 1 ) ) ) < 0 && __remove ){
                    __this[ ns ] = 0;
                }
            });
        }

        processUnfix(cell, intersection) {
            this.common_fn( cell, intersection, true );
        }

        processFix(cell, intersection) {
            this.common_fn( cell, intersection );
        }

        execute(cb) {
            return this.getMethods( cb ) && this.executeMethod.apply( this, arguments );
        }

        callUnfix(cell) {
            this.execute( 'onUnFix', cell, this.$node );
        }

        callFix(cell) {
            this.execute( 'onFix', cell, this.$node );
        }

        callDrop(selectedCell, next, startIndex, endIndex, header, evt) {
            this.execute( 'onDrop', selectedCell, next, startIndex, endIndex, header, evt, this.$node );
        }

        callRelease(evt, selectedCell) {
           this.execute( 'onRelease', evt, selectedCell, this.$node );
        }

        callOnBeforeSelect(selectedCell, ev, index) {
            return this.execute( 'onBeforeSelect', selectedCell, ev, this.$node, index ) == false;
        }

        callOnSelect(selectedCell, ev, index) {
            return this.execute('onSelect', selectedCell, ev, this.$node, index ) === false;
        }

        stickyFunction(cell, isCss, property, value) {
            var index = this.getIndex( cell ),
            tbody = this.getTbody(),
            rows = cell.parentNode.previousElementSibling ? [] : this.get_children( tbody ),
            fnName = isCss ? 'css' : property,
            fnValue = value;

            if( isCss ){
                fnValue = {};
                fnValue[ property ] = value;
            }

            _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( cell )[ fnName ]( fnValue );

            rows.forEach( row => {
                _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( this.get_nth_cell( row, index ) )[ fnName ]( fnValue );
            });
        }

        removeFixedClass(cell) {
            this.stickyFunction( cell, false, 'removeClass', 'lyteTableFixed' );
        }

        addFixedClass(cell) {
            this.stickyFunction( cell, false, 'addClass', 'lyteTableFixed' );
        }

        removeSticky(cell) {
            var is_right = cell.classList.contains( 'lyteTableRightFixed' );

            this.stickyFunction( cell, true, this.rtlfunc( is_right ? 'right' : 'left' ), '' );
            this.stickyFunction( cell, false, 'removeClass', 'lyteFixedColumn' );
        }

        makeSticky(cell) {
            var __left = this.rtlfunc( 'left' );

            this.stickyFunction( cell, true, __left, cell.style[ __left ] );
        }

        stickyScroll(evt) {
            var __target = evt.target;

            if( __target == this.scrollDiv ){
                var __intersections = this._intersections;

                if( __intersections.length  ){
                    _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom.measure( function(){
                        var scrollTop = __target.scrollTop;
                        _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom.mutate( function(){
                           __target.closest( 'lyte-table' ).style.setProperty( '--lyte-table-intersection', scrollTop + 'px' );
                        });
                    });
                }
            }
        }

        sortablemousedown(ev) {
            var evt = ev,
            isTch,
            __target = ev.target;

            if( /lyte-tablehead-resize/i.test( __target.tagName ) || ev.button != 0 ){
                return
            }

            if( /touch/i.test( ev.type ) ){
                if( ev.touches.length > 1 ){
                    return;
                }
                isTch = true;
                evt = ev.touches[ 0 ];
            }
            var target = __target,
            selectedCell = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( target ).closest( this.data.ltPropTags.th ).get( 0 ),
            index = this.getIndex( selectedCell );

            if( _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( selectedCell ).hasClass( 'lyteTableFixed' ) ){
                return;
            }

            if( this.callOnBeforeSelect( selectedCell, ev, index ) ){
                return;
            }

            this._ww = window.innerWidth;

            // no need to pass this._ww inside rtlfunc. its already available inside it == > here only its available in this. In other places i am passing. So i need to pass here too. Here i am storing because of window dimension wont change during mousemove. So no need to measure that in mousemove
            var clientX = this.rtlfunc( 'clientX', evt, this._ww ),
            offleft = 0,
            tbody = this.getTbody(),
            thead = this.getThead(),
            cells = [],
            rows = this.get_children( tbody ),
            scrollDiv = this.getScrollDiv(),
            scrollTop = scrollDiv.scrollTop;

            this._elem = selectedCell;

            this._originalIndex = index;
            this._sortmousemove = this.sortmousemove.bind( this );
            this._sortmouseup = this.sortmouseup.bind( this );
            this._currentIndex = index;
            this._tbody = tbody;
            this._cells = cells;
            this._affectedIndex = [];

            this._scrolldivBcr = scrollDiv.getBoundingClientRect();
            this._scrollwidth = scrollDiv.scrollWidth;

            this._prevx = clientX;
            this._originalDiv = scrollDiv;
            this._originalDiv._sL = scrollDiv.scrollLeft;

            var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),
            rowBcr = selectedCell.parentNode.getBoundingClientRect(),
            __dir = this._dir;

            headerCells.forEach( function( cell, index, originalArray ){
                var previousCell = ( originalArray[ index - 1 ] || {} )._bcr,
                cellBcr = cell.getBoundingClientRect(),
                __width = cellBcr.width;

                // Feels like this calculation might not be needed. ===> Actual position( If not sticked ) and sticked positions will be different. here i am calculating Actual position. getBounding will give sticked position

                if( index == 0 ){
                    if( __dir ){
                        var __right = rowBcr.right;
                        cell._bcr = { left : __right - __width, right : __right, width : __width };
                    } else {
                        var __left = rowBcr.left;
                        cell._bcr = { left : __left, right : __left + __width, width : __width };
                    }
                } else {
                    if( __dir ){
                        var __left = previousCell.left;
                        cell._bcr = { left : __left - __width, right : __left, width : __width };
                    } else {
                        var __right = previousCell.right;
                        cell._bcr = { left : __right, right : __right + __width, width : __width };
                    }
                }
            });

            // don't understand this part either ==> converting event client value with respect to right( in rtl )
            
            this._xoffset = clientX - this.rtlfunc( 'right', selectedCell._bcr, this._ww );

            if( !this.data.ltPropPreventTableModify ){
                var height = 0;

                rows.every( function( row ){
                    var cell = this.get_nth_cell( row, index ),
                    cellHeight = cell.getBoundingClientRect().height;
                    height += cellHeight;

                    if( height < scrollTop - rowBcr.height ){
                        return true;
                    }

                     cell._translateX = 0;
                     cells.push( cell );
                     // may this can be this._currentEndIndex ===> its just virtual movement. So i named this as transformed index
                     cell._transformedindex = index;
                     cell.classList.add( 'lyteStickyTableColumnSortSelect' );

                     if( height >= this._scrolldivBcr.height + scrollTop ){
                        return false;
                    }
                    return true;
                }.bind( this ) );

                selectedCell._translateX = offleft;
                cells.push( selectedCell );
                selectedCell._transformedindex = index;
            } else {
                selectedCell._transformedindex = index;
            }

            document.addEventListener( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );
            document.addEventListener( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );
            this.$node.classList.add( 'lyteTableSortSelected' );
            selectedCell.classList.add( 'lyteStickyTableColumnSortSelect' );
            ev.preventDefault();

            this.callOnSelect( selectedCell, ev, index );
        }

        isIncrement(increment, isRightEdge) {
            return increment > 0 || ( increment == 0 && isRightEdge );
        }

        isDecrement(increment, isRightEdge) {
            return increment < 0 || ( increment == 0 && isRightEdge === false );
        }

        getTd(cell, increment, isRightEdge) {
            // what is transformedindex ==> while moving columns are interchanged. here transformed index is virtual new index
            var transindex = cell._transformedindex,
            __index = -1,
            ori_index = this._originalIndex;

            if( this.isIncrement( increment, isRightEdge ) ){
                if( ori_index <= transindex ){
                    __index = transindex + 1;
                } else{
                    __index = transindex;
                }
            } else if( this.isDecrement( increment, isRightEdge ) ) {
                if( ori_index < transindex ){
                    __index = transindex;
                } else {
                    __index = transindex - 1;
                }
            }

            return this.get_nth_cell( cell.parentNode, __index );

        }

        findFromClosest(evt, cell) {
            var __tags = this.data.ltPropTags,
            closestCell = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( evt.target ).closest( __tags.th + ', ' + __tags.td ).get( 0 );
            if( this.isHeader( closestCell ) ){
                var index = this.getIndex( closestCell );
                closestCell = this.get_nth_cell( cell.parentNode, index );
            }
            return this.$node.contains( closestCell ) ? closestCell : undefined;
        }

        isHeader(cell) {
            return cell && ( cell.tagName.toLowerCase() == this.data.ltPropTags.td );
        }

        isSortEnabled() {
            return this._elem;
        }

        isMoved() {
            return this._moved;
        }

        getIndex(cell) {
            return Array.from( this.get_children( cell.parentNode ) ).indexOf( cell );
        }

        getClassForFake() {
            return 'lyteTableSortHelper ' + this.data.ltPropSortDummyColumClass;
        }

        createFakeColum(cell) {
            var __doc = document,
            __element = __doc.documentElement,
            originaldiv = __doc.createElement( 'div' ),
            div = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( originaldiv ),
            cellObj = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( cell ),
            bcr = cell.getBoundingClientRect(),
            xscroll = __element.scrollLeft,
            yscroll = __element.scrollTop,
            cb = "onFakeColumnCreate";

            cellObj.data( 'sortElement', originaldiv );
            originaldiv._bcr = { left : bcr.left, right : bcr.right, width : bcr.width };
            originaldiv._translateX = bcr.left;
            originaldiv._translateY = bcr.top;

            div.attr( 'style', cellObj.attr( 'style' ) );
            div.text( cell.textContent )
                .addClass( this.getClassForFake() )
                .data( 'relatedElement', cell )
                .css({ 
                        height : bcr.height, 
                        width : bcr.width,
                        left : xscroll * ( this._dir ? -1 : 1 ),
                        top : yscroll,
                        pointerEvents : "none",
                        transform : 'translate(' + originaldiv._translateX + 'px,' + originaldiv._translateY + 'px)'
                    });


            this.getMethods( cb ) && this.executeMethod( cb, originaldiv, cell, this.$node );

            __doc.body.appendChild( originaldiv );
            this._moved = true;
        }

        sortmousemove(ev, allowAtSame, isRightEdge) {
            if( !this.isSortEnabled() ){
                return;
            }

            var evt = ev,
            ww = this._ww,
            // maybe the rtlfunc needs a better name ==> its a old function can't change its name right now
            clientX = this.rtlfunc( 'clientX', evt, ww ),
            left = this.rtlfunc( 'left' ),
            selectedCell = this._elem,
            tbody = this.getTbody(),
            cells = this._cells,

            // don't understand the xoffset == > initial mouse position during mousedown. Increment calculated based on this
            xoffset = this._xoffset,
            preventable = this.data.ltPropPreventTableModify;

            // evt = this.getProperEvent() ==> if touch length is more than one i need to stop the function. if i write this as additional function it again leads to write one more function. Right now i can't write this as a fucntion
            if( /touch/i.test( ev.type ) ){
                if( ev.touches.length > 1 ){
                    return;
                }
                evt = ev.touches[ 0 ];
            }

            if( preventable && !this.isMoved() ){
                return this.createFakeColum( selectedCell );
            }

            if( this._prevx == evt.clientX && !allowAtSame ){
                return;
            }

            window.$selectedCell = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( selectedCell );

            if( this.getMethods( 'onBeforeDrag' ) && this.executeMethod( 'onBeforeDrag', selectedCell, $selectedCell.data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex ) === false ){
                return;
            }

            this._prevx = evt.clientX;

            var fakeCell = $selectedCell.data( 'sortElement' ),
            // won't div._bcr be present? In one type it wont present
            bcr = preventable ? fakeCell._bcr : selectedCell._bcr,
            increment = ( clientX - this.rtlfunc( 'right', bcr, ww ) - xoffset ),
            is_increment = this.isIncrement( increment, isRightEdge ),
            is_decrement = this.isDecrement( increment, isRightEdge ),

            closestCell = preventable ? this.findFromClosest( evt, selectedCell ) : this.getTd( selectedCell, increment, isRightEdge ),

            closestbcr = closestCell ? closestCell._bcr : {},

            newone, closestCellIndex, 

            scrollLeft = this._originalDiv._sL,

            fact = this._dir ? -1 : 1,

            interchangeprevent, 
            offLeft = 0,
            cb = 'onBeforeInterChange',
            __affectedIndex = this._affectedIndex;

            if( selectedCell == closestCell && !fakeCell ){
                closestCell = undefined;
            }

            if( closestCell && this.isSortEnabled() ){
                closestCellIndex = this.getIndex( closestCell );

                if( closestCellIndex != this._originalIndex || preventable ){
                    var allow = false,
                    close_index = closestCell._transformedindex,
                    transindex = !isNaN( close_index ) ? close_index : closestCellIndex,
                    __limit = this.rtlfunc( 'left', closestbcr, ww ) + closestbcr.width * 0.5,
                    __transformedindex = selectedCell._transformedindex;

                    if( fakeCell && selectedCell == closestCell ){
                        transindex = closestCellIndex;
                    } 
                    
                    if( is_increment ) {
                        if( this.rtlfunc( 'right', bcr, ww ) + increment > __limit ){
                            allow = transindex > __transformedindex;
                        }
                    } else if( is_decrement ){
                        if( this.rtlfunc( 'left', bcr, ww ) + increment < __limit ){
                            allow = transindex < __transformedindex;
                            if( allow && ( closestCell._horizontalIntersectionDiv || {} )._sticked ){
                                allow = false;
                            }
                        }
                    }
                    if( allow ){
                        if( !preventable ){
                            newone = __affectedIndex.indexOf( closestCellIndex ) == -1;
                            if( newone ){
                                offLeft = 0;
                                __affectedIndex.push( closestCellIndex );
                            }
                        }
                    } else {
                        closestCell = undefined;
                    }
                }
            } else {
                closestCell = undefined;
            }
            if( closestCell && this.getMethods( cb ) ){
                interchangeprevent = this.executeMethod( cb, ev, selectedCell, closestCell, this.$node ) === false;
                if( interchangeprevent && newone ){
                    this.$addon.arrayUtils( __affectedIndex, 'removeAt', __affectedIndex.indexOf( closestCellIndex ) );
                }
            }

            if( preventable ){
                fakeCell.style.transform = 'translate( ' + ( fakeCell._translateX += ( increment * fact ) ) + 'px,' + fakeCell._translateY + 'px)';
                if( closestCell && !interchangeprevent ){
                    if( closestCell != selectedCell ){
                       var __fact = 0;
                       if( is_decrement ){
                         __fact = -1;
                       } else if( is_increment ){
                         __fact = 1;
                       }
                       selectedCell._transformedindex += __fact;
                    }
                }
            } else {
                cells.forEach( function( cell, indexVal ){
                    cell.style.transform = "translateX(" + ( cell._translateX += ( increment * fact ) ) + "px)";
                    // if( !this.isSortEnabled() ){
                        cell.classList.add( 'lyteStickyTableColumnMoving' );
                    // }
                    if( closestCell && !interchangeprevent ){
                        var newcell = this.get_nth_cell( cell.parentNode, closestCellIndex ),
                        __fact = 0,
                        ___ns = '_transformedindex';

                        if( newone ){
                            newcell.classList.add( 'lyteStickyTableColumnSortAnimate' );
                            newcell._translateX = 0;
                        }
                        newcell.style.transform = "translateX(" + ( newcell._translateX += ( bcr.width * ( this.isIncrement( increment, isRightEdge ) ? -1 : 1 ) * fact ) ) + "px)";

                        if( newcell[ ___ns ] == undefined ){
                            newcell[ ___ns ] = closestCellIndex;
                        }

                        if( is_decrement ){
                            __fact = 1;
                        } else if( is_increment ){
                            __fact = -1;
                        }

                        newcell[ ___ns ] += __fact;
                        cell[ ___ns ] -= __fact
                    }
                }.bind( this ));
            }

            if( fakeCell ){
                var __fakecell = fakeCell._bcr;

                __fakecell.left += ( increment* fact );
                __fakecell.right += ( increment * fact );
            } else {
                var __selected_bcr = selectedCell._bcr;

                __selected_bcr.left += ( increment * fact );
                __selected_bcr.right += ( increment * fact );
                if( closestCell && !interchangeprevent ){
                    var close_bcr = closestCell._bcr;

                    close_bcr.left += ( bcr.width * ( is_increment ? -1 : 1 ) * fact );
                    close_bcr.right += ( bcr.width * ( is_decrement ? -1 : 1 ) * fact );
                }
            }
            this.clearFastdom();

            this.sorthorizontalscroll( { left : bcr.left, width : bcr.width, right :  bcr.right }, scrollLeft, is_increment );

            if( closestCell ){
                this.callInterChange( ev, selectedCell, closestCell );
            }
            this.callDrag( selectedCell, ev );
            this._moved = true;
        }

        callInterChange(ev, selectedCell, closestCell) {
            this.execute( 'onInterChange', ev, selectedCell, closestCell, this.$node );
        }

        callDrag(selectedCell, ev) {
            this.execute( 'onDrag', selectedCell, _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( selectedCell ).data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex );
        }

        clearFastdom() {
            var fastdom = (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom);
            fastdom.clear( this._reqId );
            fastdom.clear( this._measure );
            delete this._measure;
            delete this._reqId;
        }

        sorthorizontalscroll(bcr, scrollLeft, isIncrement) {
            var left = this.rtlfunc( 'left' ),
            ww = this._ww,
            _scrolldivBcr = this._scrolldivBcr,
            _scrollwidth = this._scrollwidth,
            _thisBccr = this._thisBccr,
            _originalDiv = this._originalDiv,
            _FF = this._FF,
            _dir = this._dir,
            _chrome = this._chrome,
            _isSafari = this._isSafari,
            isLeft = !isIncrement && ( this.rtlfunc( 'left', bcr, ww ) < Math.max( this._fixedWidth + this.rtlfunc( 'left', _scrolldivBcr, ww ), 0 ) ),
            isRight = isIncrement && ( ( this.rtlfunc( 'left', bcr, ww ) + bcr.width ) > Math.min( this.rtlfunc( 'right', _scrolldivBcr, ww ), ww ) ),
            selectedCell = this._elem;

            if( _FF && isRight ){
                // is this like checking if currentEndIndex is on the last node? == > firefox behaves weirdly. If we keep moving scrollwidth gradully increases. So if it reaches its end i am returning false

                if( selectedCell._transformedindex == this.get_children( selectedCell.parentNode ).length - 1 ){
                    if( _dir ){
                         // why scrollwidth + scrollleft <= widthofscrolldiv? - Firefox rtl behaviour
                         if( _scrollwidth + window.sL <= _thisBccr.width ){
                            return;
                        }
                    } if( window.sL + _thisBccr.width >= _scrollwidth ){
                        return;
                    }
                }
            }

            var value;

            if( isLeft ){
                value = scrollLeft - this.getCrctScrollValue();
                if( _dir ){
                    if( _chrome ){
                        // why does this Math.min need to be taken ==> In Rtl scrollLeft value will be lower than initial value. Setting Higher value change its scroll width value automatically in rtl
                        value = Math.min( value, _scrollwidth - _scrolldivBcr.width );
                    } else if( _FF || _isSafari ){
                        value = Math.min( value, 0 );
                    }
                } else {
                    value = Math.max( value, 0 );
                }
            } else if( isRight ){
                value = scrollLeft + this.getCrctScrollValue();
                if( _dir ){
                    if( _chrome ){
                        value = Math.max( value, 0 );
                        isRight = value != 0;
                    } else if( _FF || _isSafari ){
                        value = Math.max( value, _scrolldivBcr.width - _scrollwidth );
                        isRight = value != _scrolldivBcr.width - _scrollwidth;
                    } else {
                        value = Math.min( value, _scrollwidth - _scrolldivBcr.width ); 
                        isRight = value != _scrollwidth - _scrolldivBcr.width;
                    }
                } else {
                    value = Math.min( value, _scrollwidth - _scrolldivBcr.width );
                }
            } else {
                this.clearFastdom();
            } 
            if( isLeft || isRight ){
                _originalDiv.scrollLeft = value;
                var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),
                scrollIncrement = value - scrollLeft

                if( scrollIncrement ){

                    // why (value - sL) === > Updating my reference value without dom measure
                    _originalDiv._sL += scrollIncrement;

                    headerCells.forEach( cell => {
                        cell._bcr.left -= scrollIncrement;
                        cell._bcr.right -= scrollIncrement;
                    });

                    var fastdom = (_node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default().fastdom);

                    this._measure = fastdom.measure( () => {
                        delete this._measure;
                        this._reqId = fastdom.mutate( () => {
                            delete this._reqId;
                            this.sortmousemove( { clientX : this._prevx }, true, isRight );
                        });
                    });
                }
             }
        }

        getCrctScrollValue() {
            return this.data.ltPropScrollStep * ( this._dir ? -1 : 1 );
        }

        swapColumnsInData(header, startIndex, endIndex) {
            var La = this.$addon.arrayUtils,
            current = La( header, 'removeAt', startIndex );
            La( header, 'insertAt', endIndex, current );
        }

        swapColumnsInDom(startIndex, endIndex) {
            this._preventCustomdelete = true;

            var rows = Array.from( this.getRows() );

            rows.forEach( row => {
                this.$component[ startIndex < endIndex ? 'insertAfter' : 'insertBefore' ]( this.get_nth_cell( row, endIndex ), this.get_nth_cell( row, startIndex ) );
            });
            delete this._preventCustomdelete;
        }

        removeEvents(evt) {
            var isTch = /touch/i.test( evt.type ),
            rel = 'removeEventListener',
            __doc = document;

            __doc[ rel ]( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );
            __doc[ rel ]( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );

            delete this._sortmouseup; 
            delete this._sortmousemove; 
        }

        clearVariables() {
            delete this._elem; 
            delete this._xoffset; 
            delete this._originalIndex; 
            delete this._moved;
            delete this._affectedIndex; 
            delete this._tbody;
            delete this._cells; 
            delete this._prevx; 
            delete this._scrolldivBcr; 
            delete this._ww; 
            delete this._scrollwidth;
            delete this._originalDiv;
        }

        sortmouseup(evt) {
            var startIndex = this._originalIndex,
            selectedCell = this._elem,
            endIndex = selectedCell._transformedindex;

            this.resetcells();
            if( this.isSortEnabled() ){
                var failed,
                header = this.getData( 'ltPropHeader' ),
                next = this.get_nth_cell( selectedCell.parentNode, endIndex ),
                cb = "onBeforeDrop",
                failed = this.getMethods( cb ) && this.executeMethod( cb, selectedCell, next, startIndex, endIndex, header, evt ) == false;

                if( !failed && startIndex != endIndex ){
                    if( header.length ){
                        this.swapColumnsInData( header, startIndex, endIndex );
                    } else {
                        this.swapColumnsInDom( startIndex, endIndex );
                    }
                }
                this._setLeftForInterSection();
                !failed && this.callDrop( selectedCell, next, startIndex, endIndex, header, evt )
            } else {
                // Is onRelease a callback which gets fired when the element has not been moved? This sounds like a very special case callback. I want to know more about the use case of this

                // Generally all are adding some class to selected element in mousedown and want to remove the same in mouseup. If its not moved those classes will not be removed( or they have to write that in first mousemove ). In my case too i need to call reset cells. Thats why i here provided one extra callback
                this.callRelease( evt, selectedCell )
            }

            this.removeEvents( evt );
            this.clearFastdom();
            this.clearVariables();

            this.$node.classList.remove( 'lyteTableSortSelected' );
        }

        removeFakeCell(selectedCell) {
            var $node = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( selectedCell ),
            ns = 'sortElement',
            div = $node.data( ns );
            if( div ){
              div.remove();
              _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( div ).data( 'relatedElement', void 0 );
            }
            $node.data( ns, void 0 );
        }

        resetcells(cells) {
            var affected = this._affectedIndex,
            cells = this._cells,
            selectedCell = this._elem;

            if( this.data.ltPropPreventTableModify ){
                this.removeFakeCell( selectedCell );
                this.resetSingleCell( selectedCell );
            } else {
                cells.forEach( function( cell ){
                    var rowChildren = this.get_children( cell.parentNode );
                    this.resetSingleCell( cell );
                     affected.forEach( function( affIndex ){
                        this.resetSingleCell( rowChildren[ affIndex ] );
                    }.bind( this ) );
                }.bind( this ) );
            }
        }

        resetSingleCell(cell) {                
            cell.style.transform = "";
            cell.classList.remove( 'lyteStickyTableColumnSortSelect', 'lyteStickyTableColumnMoving', 'lyteStickyTableColumnSortAnimate' );
            delete cell._transformedindex;
            delete cell._translateX;
        }

        checkIntersection(arg, ignore_removal) {
            var table = this.__table,
            __this = table.component;

            if( table.ltProp( 'stickyTable' ) && __this.data.ltPropScroll.horizontal ){
                var __elem = this._horizontalIntersectionDiv;
                if( arg && !__elem ){
                    __this.createIntersection.call( this, table );
                } else if( !arg && __elem ){
                    var intersection = __elem;
                    __this.removeIntersection.call( this, intersection, table );
                    __this.removeSticky( this );
                    __this.removeFixedClass( this );

                    if( ignore_removal ){
                        __this.createIntersection.call( this, table );
                    }
                }
            }
        }

        createIntersection(table) {
            var div = _node_modules_zoho_lyte_dom_modules_lyte_dom_utils_js__WEBPACK_IMPORTED_MODULE_2___default()( document.createElement( 'div' ) ).addClass( 'lyteIntersectionDiv' ).get( 0 );
            table.getElementsByTagName( table.ltProp( 'tags' ).table )[ 0 ].appendChild( div );
            this._horizontalIntersectionDiv = div;
            div._cell = this;
            table.component._setLeftForInterSection();
        }

        disconnectedCallback() {
            var intersection = this._horizontalIntersectionDiv;
            if( intersection ){
                var table = this.__table,
                __this = table.component;

                if( table && __this._preventCustomdelete ){
                    return;
                }
                delete this.__table;
                __this.removeIntersection.call( this, intersection, table );
            }
        }

        removeIntersection(intersection, table) {
            if( table ){
                var ins = table.component._intersectionObs;
                if( ins ){
                    ins.unobserve( intersection );
                }
            }
            intersection.remove();

            delete intersection._cell;
            delete this._horizontalIntersectionDiv;
        }

        static observers(arg1) {
            return Object.assign(super.observers({
                stickyTable : function(){
                    var __this = this,
                    __data = __this.data;

                    if( __data.ltPropStickyTable ){
                        var $node = __this.$node,
                        scroll = __data.ltPropScroll,
                        scrollDiv = __this.getScrollDiv();

                        __this.__mixinAdded = true;
                        $node.classList.add( 'lyteStickyTable' );

                        if( scroll.horizontal ){
                            __this.registerInterSection( scrollDiv );
                            scrollDiv.addEventListener( 'scroll', __this.stickyScroll.bind( __this ), true );
                        }

                       $node.reset = function(){
                            __this._setLeftForInterSection( true );
                            if( !__this.__from_collapse ){
                                __this.update_collapse( true );
                            }
                       }.bind( __this );

                        __this.detectBrowsers();
                    }
                }.on( 'didConnect' ),

                setLeftForInterSection : function(){
                    if( this.data.ltPropStickyTable ){ 
                        this.$node.reset();
                    }
                }.observes( 'ltPropContent.[]', 'ltPropHeader.[]', 'ltPropContent', 'ltPropHeader' ).on( 'didConnect' ),

                bindingEvts : function(){
                   var data = this.data;

                   if( !data.ltPropStickyTable ){
                       return;
                   }

                   var header = this.getThead();
                   if( header ){
                       var fn,
                       ns = "addEventListener";
                       if( data.ltPropColumnSortable ){
                           fn = ( this._sortmousedown = this.sortablemousedown.bind( this ) );
                       } else {
                            if( fn = this._sortmousedown ){
                               ns = "removeEventListener";
                               delete this._sortmousedown;
                           }
                       }
                       if( fn ){
                           header[ ns ]( 'mousedown', fn, true );
                           header[ ns ]( 'touchstart', fn, true );
                       }
                   }

               }.observes( 'ltPropColumnSortable' ).on( 'didConnect' )
            }), arg1);
        }

        _() {
            _;
        }
    }

    return overrides(_LyteTableUtilsMixin);
});



LyteTableUtilsMixin.register({
    hash: "LyteTableUtilsMixin_4",
    refHash: "@zoho/lyte-ui-component_3"
});

/***/ }),

/***/ 19998358:
/*!************************************************************************!*\
  !*** ./node_modules/@zoho/lyte-ui-component/plugins/lyte-scrollbar.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( cb ){
	if( true ){
		  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! @zoho/lyte-dom */ 92838254) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (cb),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {}
} )( function( $L ){
   if( $L ) {
    var uA = window.navigator.userAgent, 
    isSaf =  { 
        uA : uA, 
        isUbuntu : /ubuntu/ig.test( uA ), 
        isIpad : /ipad/ig.test( uA ), 
        safari : /safari/ig.test( uA ), 
        isIE11Lyte : /rv:11/ig.test( uA ), 
        isEdgeLyte : /Edge/ig.test( uA ), 
        mode : {}, 
        chrome  : !!window.chrome , 
        firefox : /firefox/ig.test( uA ) 
    };

    function appendDiv( className, obj, dir, is_parent ) {
        var div = document.createElement( 'div' ), innerDiv;
        div.className = className;
        div._scrolldiv = this;
        div.style.visibility = 'hidden';
        innerDiv = document.createElement( 'div' );
        innerDiv.classList.add( 'lyteScrollDiv' );
        if( obj.handlerClass ) {
            innerDiv.classList.add( obj.handlerClass );
        }
        if( obj.containerClass ) {
            div.classList.add( obj.containerClass )
        }
        div.appendChild(innerDiv);
        if( dir ) {
            innerDiv._direction = dir;
            if( obj.horizontalContainerClass ){
                div.classList.add( obj.horizontalContainerClass );
            }
            if( obj.horizontalHandlerClass ) {
                innerDiv.classList.add( obj.horizontalHandlerClass );
            }
            this._horiDiv = div;
        } else {
            if( obj.verticalContainerClass  ) {
                div.classList.add( obj.verticalContainerClass );
            }
            if( obj.verticalHandlerClass ){
                innerDiv.classList.add( obj.verticalHandlerClass );
            }
            this._vertDiv = div;
        }

        ( is_parent ? this.parentElement : this ).appendChild( div )
        
        div.addEventListener( 'click', outerDivClick, true );
        innerDiv.addEventListener( 'mousedown', innerDivClick );
        if( !this._infiniteScroll ){        
            innerDiv.addEventListener( 'touchstart', innerDivClick );       
        }
        return div;
    }   

    function set( elem, prop, val ) {
        if( elem.style[ prop ] != val ){
            elem.style[ prop ] = val
        }
    }

    function checkscrollable( evt ){
        evt = evt || { target : this };
        var target = evt.target.correspondingElement || evt.target, ret;

        if( target.closest( '.lyteConnectWrapper.preventWheel' ) ){
            return true;
        }
        
        while( target && target != this ) {
            if( target.classList.contains( 'preventWheel' ) ) {
                ret = true;
                break;
            }
            target = target.parentElement
        }
        return ret
    }

    function check( flag, elem, obj, mode, evt ){
        var fg;
        evt = evt || {};

        window.fn = function( elem ){
            set( elem, 'visibility', 'hidden' );
            elem.classList.remove( 'visible' );
        };

        if( !flag.scroll ) {
            var is_showon_scroll = this._scrollData.showOn == 'scroll';
            if( !( [ 'mouseenter', 'touchstart' ].indexOf( evt.type ) != -1 && is_showon_scroll ) ){
                var from_reset = ( this._enableScroll = !flag.frm_reset ),
                is_event_added = $L( this ).hasClass( "eventBinded" );

                if( elem && ( !is_showon_scroll || !flag.frm_reset ) ) {
                    clearTimeout( elem._entertimeout );
                    clearTimeout( elem._leavetimeout );
                    delete elem._entertimeout; delete elem._leavetimeout;
                    if( !flag.scrollbar ){

                        if( !from_reset && !is_event_added ){
                            return;
                        }

                        if( evt.type == "touchstart" ){
                            elem._entertimeout = setTimeout( set.bind( this, elem, 'visibility', 'visible' ), 150 );
                        } else {
                            set( elem, 'visibility', 'visible' );
                        }
                        elem.classList.add( 'visible' );
                        updatePos.call( this, mode, undefined, {}, obj );
                    } else{
                        window.fn( elem );
                    }
                }
            }
            fg = true
        } else {
            if( elem ) {
               window.fn( elem );
            }
        }
        return fg
    }

    function initialWheel( evt ){
        this.removeEventListener( 'wheel', initialWheel, true )
        if( !this.classList.contains( 'eventBinded' ) ){
            var close_connect = this.closest( "lyte-connect" );
            if( !close_connect ){
                mouseenter.call( this, { type : 'mouseenter' } );
            }
        }
        evt.preventDefault()
    }

    function format_bcr( bcr ){
        var obj = {};
        [ 'x', 'y', 'bottom', 'height', 'top', 'width', 'left', 'right' ].forEach( function( item ){
            obj[ item ] = Math.round( bcr[ item ] );
        });
        return obj;
    }

    function mouseenter( evt, frm_reset ) {
        // console.log( evt.target, evt.type, evt.currentTarget );
        if( this.classList.contains( 'eventBinded' ) && evt != true ){
            return
        }
        if( evt.type == 'mouseenter' && this._prtmseenr ){
            return;
        }
        var flag, 
        obj = { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) },
        scrolldata = this._scrollData;

        this._wheelObj = obj
        if( this.classList.contains( 'lyteTableScroll' ) ){
            forTable.call( this, obj )
        }
        this._direction = window.getComputedStyle(  this ).direction;
        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
        obj.horbcr = this._horiDiv ?  this._horiDiv.getBoundingClientRect() : {}
        flag = check.call( this, fitForScroll.call( this, true, obj, frm_reset ), this._vertDiv, obj, true, evt )
        flag = check.call( this, fitForScroll.call( this, false, obj, frm_reset ), this._horiDiv, obj, false, evt ) || flag
        if( flag && evt ) {
            this._mouseleave = this._mouseleave || mouseleave.bind( scrolldata.appendTo == "parent" ? this.parentElement : this );
            if( evt.type == "touchstart" ) {
               if( evt.touches.length == 1 ){
                    clearTimeout( this._tchtime );
                    document.addEventListener( 'touchcancel', this._mouseleave, true )
                } else {
                    return;
                }
            } else {
                this.addEventListener( 'wheel', wheelEvent, true );
                this.addEventListener('keydown', keydownFunc, true);
                if( this._scrollData.showOn == 'scroll' ){
                    this.addEventListener( 'mousemove', hideScrollbar, true );
                }
            }
            this._allowTouch = true;
            document.addEventListener( 'touchend', this._mouseleave, true )
            this.classList.add( 'eventBinded' )
            this._tabindex = this._tabindex == undefined ? this.tabIndex : this._tabindex;
            if(this.tabIndex == -1){
                this.tabIndex = scrolldata.tabIndex || 0;
            }
        }
    } 

    function keydownFunc( evt ) {
        if( evt.target != this ){
            return
        }

        var key = evt.key,
        elem = this,
        sL =  Math.round( elem.scrollLeft ),
        sT = Math.round( elem.scrollTop ),
        wd = elem.offsetWidth,
        hgt = elem.offsetHeight,
        s_wd = elem.scrollWidth,
        s_hgt = elem.scrollHeight,
        obj = { 
            scrollLeft : sL, 
            scrollTop : sT, 
            scrollWidth : s_wd, 
            scrollHeight : s_hgt, 
            bcr : elem.getBoundingClientRect() 
        },
        step = this._scrollData.keyStep,
        dir = this._direction == 'rtl',
        pos,
        mode,
        __new,
        is_negative = dir && ( !window._lyteUiUtils || window._lyteUiUtils.isNegativeScroll() ),
        meta = evt.metaKey || evt.ctrlKey;

        switch( key ){
            case "ArrowLeft" : {
                mode = false;

                if( meta ){
                    if( dir ){
                        if( is_negative ){
                            __new = wd - s_wd;
                        } else {
                            __new = s_wd - wd;
                        }
                    } else {
                        __new = 0;
                    }
                } else {
                    if( dir && is_negative ){
                        dir = false;
                    }
                    __new = sL - step * ( dir ? -1 : 1 );
                }
            }
            break;
            case "ArrowRight" : {
                mode = false;
                
                if( meta ){
                    if( dir ){
                        if( is_negative ){
                            __new = 0;
                        } else {
                            __new = wd - s_wd;
                        }
                    } else {
                        __new = s_wd - wd;
                    }
                } else {
                    if( dir && is_negative ){
                        dir = false;
                    }
                    __new = sL + step * ( dir ? -1 : 1 );
                }
            }
            break;
            case "ArrowDown" : {
                __new = Math.min( sT + step, s_hgt - hgt );
                mode = true;
            }
            break;
            case "ArrowUp" : {
                __new = Math.max( 0, sT - step );
                mode = true;
            }
            break;
            case "PageDown" : {
                __new = Math.min( sT + hgt, s_hgt - hgt );
                mode = true;
            }
            break;
            case "PageUp" : {
                __new = Math.max( sT - hgt, 0 );
                mode = true;
            }
            break;
            case "Home" : {
                __new = 0;
                mode = true;
            }
            break;
            case "End" : {
                __new = s_hgt - hgt;
                mode = true;
            }
            break;
        }

        if( mode != void 0 && shouldPrevent.call( elem, obj, mode, __new - ( mode ? sT : sL ) ) ){
            elem[ mode ? 'scrollTop' : 'scrollLeft' ] = __new;
            scroll.call( elem, evt )
            evt.preventDefault();
        }
    }

    function mouseleave( evt ){
        evt = evt || {};
        if( ( evt.relatedTarget && this.contains( evt.relatedTarget ) ) || document._scrollmouseup ){
            return
        }
        if( evt.type == 'touchend' ) {     
            var tar = evt.target.correspondingElement || evt.target;        
            if( tar && tar.classList.contains( 'lyteScrollContainer' ) ) {      
                return;     
            }       
        }
        var bars = $L( this ).children( '.lyteScrollContainer' ), scrlDiv = this._scrolldiv || this;
        if( bars.length ) {
            for(  var i = 0; i < bars.length; i++ ) {
                var __cur_bar = bars[ i ];

                clearTimeout( __cur_bar._entertimeout );
                clearTimeout( __cur_bar._leavetimeout );
                delete __cur_bar._entertimeout;
                delete __cur_bar._leavetimeout;

                __cur_bar.classList.remove( 'visible' )
                if( evt.type == 'touchend' ){
                    __cur_bar._leavetimeout = setTimeout( set.bind( this, __cur_bar, 'visibility', 'hidden'), 150 )
                } else {
                    __cur_bar.style.visibility = 'hidden';
                }
            }
            if( evt.type == 'mouseleave' ) {
                scrlDiv.removeEventListener('wheel', wheelEvent, true);
                scrlDiv.removeEventListener('keydown', keydownFunc, true);
                scrlDiv.removeEventListener( 'mousemove', hideScrollbar, true );
                scrlDiv.addEventListener( 'wheel', initialWheel, true );
            } else if( evt.type == 'touchend' || evt.type == "touchcancel" ) {
                scrlDiv._prtmseenr = true;
                scrlDiv._tchtime = setTimeout( function(){
                    delete scrlDiv._prtmseenr;
                }, 500 )
                document.removeEventListener( 'touchcancel', scrlDiv._mouseleave, true )
            }
            if( evt.type ){
                document.removeEventListener( 'touchend', scrlDiv._mouseleave, true )
                delete scrlDiv._allowTouch;
                scrlDiv.classList.remove( 'eventBinded' );
                // scrlDiv.tabIndex = this._scrolldiv._tabindex;
                // delete scrlDiv._tabindex;
                 delete scrlDiv._wheelObj;
                delete scrlDiv._prevPosY; delete scrlDiv._mouseleave;
                delete scrlDiv._prevPosX; delete scrlDiv._wheelEvt;
            }
            delete scrlDiv._enableScroll;
        }
    }

    function outerDivClick( evt ) {
        if( !this.classList.contains( 'visible' ) ){
            return
        }
        var isTch = evt.type == "touchmove";       
        if( isTch ) {       
            if( evt.touches.length > 1 ){       
                return;     
            } else {        
                evt.preventDefault();       
                evt = evt.touches[ 0 ]      
            }       
        }       
        var elem = this._scrolldiv, mode, inn = this.children[ 0 ], outBcr = this.getBoundingClientRect(), inBcr = inn.getBoundingClientRect(),
        obj = { scrollLeft : Math.round( elem.scrollLeft ), scrollTop : Math.round( elem.scrollTop ), scrollWidth : elem.scrollWidth, scrollHeight : elem.scrollHeight, bcr : elem.getBoundingClientRect() },
        hgt = 'width', top1 = 'left', sT = 'scrollLeft', sH = 'scrollWidth', bt = 'right', cY = 'clientX';
        if( this.classList.contains( 'lyteTableScroll' ) && !obj.$nodeClient ){
            forTable.call( this, obj )
        }
        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}
        obj.horbcr = this._vertDiv ?  this._horiDiv.getBoundingClientRect() : {}
        if(!inn._direction){
            mode = true;
            hgt = 'height', top1 = 'top', sT = 'scrollTop', sH = 'scrollHeight', bt = 'bottom', cY = 'clientY';
        }
        var scramt = evt.type != 'click' ? ( evt[ cY ] - ( this.prev || evt[ cY ] ) ) : ( evt[ cY ] - ( inBcr[ top1 ] + inBcr[ hgt ] / 2 ) ), newsL;
        newsL = ( scramt / ( obj.bcr[ hgt ] + obj.bcr[ top1 ] - outBcr[ top1 ] ) * obj[ sH ] )
        elem[ sT ] += ( newsL ) ;
        scroll.call( elem, evt );
        this.prev = evt[ cY ];
    }

    function innerDivClick( evt ) {
       var isTch = evt.type == "touchstart",
       __parentNode = this.parentNode,
       __document = document,
       ael = 'addEventListener';

        __document[ ael ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove = outerDivClick.bind( __parentNode ), true );
        __document[ ael ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup = mouseup.bind( __parentNode ), true );

        evt.preventDefault();
        evt.stopPropagation();
    }

    function mouseup( evt ) {
        var isTch = evt.type == "touchend",
        __document = document,
        rel = "removeEventListener",
        scroll_elem = this._scrolldiv || this,
        target = evt.target,
        scrolldata = scroll_elem._scrollData;

        __document[ rel ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove, true );
        __document[ rel ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup, true );

        delete __document._scrollmousemove;
        delete __document._scrollmouseup; 
        delete this.prev;

        if( !scroll_elem.contains( target.correspondingElement || target ) && scrolldata.showOn != 'always' ){
            mouseleave.call( scrolldata.appendTo == "parent" ? scroll_elem.parentNode : scroll_elem , { type : 'mouseleave' } );
        }
    }

    function mousedown( evt ) {

        var scrolldata = this._scrollData,
        __document = document;

        if( __document._scrollmouseup ) {
            return
        }
        __document.addEventListener( 'mouseup', __document._scrollmouseup = mouseup.bind( scrolldata.appendTo == "parent" ? this.parentElement : this ), true )
    }

    function fitForScroll( mode, obj, frm_reset ) {
        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv,
        scrolldata = this._scrollData,
        margin = scrolldata.scrollYMarginOffset;

        if( !mode ) {
            sL = 'scrollLeft', sW = 'scrollWidth', wd = 'width';
            margin = scrolldata.scrollXMarginOffset;
        }
        if( obj[ sL ] + obj.bcr[ wd ] >= obj[ sW ] && obj[ sL ] == 0 ){
            if( elem && elem.classList.contains( 'visible' ) ) {
                check.call( this, { scroll : true, scrollbar : true }, elem )
            }
            return {
                scroll : true,
                scrollbar : true,
                frm_reset : frm_reset
            }
        }

        return{
            scroll : false,
            scrollbar : ( obj[ sW ] - obj.bcr[ wd ] ) <= margin,
            frm_reset : frm_reset
        }
    }

    function wheelEvent( evt ){
         if( checkscrollable.call( this, evt ) ) {
                return
            }
        if( evt.type == 'touchmove' ) { 
            if( this._allowTouch && evt.touches.length == 1 ) {
                var curr = evt.touches[ 0 ];
                wheelEvent1.call( this, evt, [ (this._prevPosX || curr.clientX ) - curr.clientX,  ( this._prevPosY || curr.clientY ) - curr.clientY ] )
                this._prevPosY = curr.clientY;
                this._prevPosX = curr.clientX;
            }
        } else {   
            wheelEvent1.call( this, evt )
        }
    }

    function shouldPrevent( obj, mode, val ){
        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv;
        if( !mode ) {
            sL = 'scrollLeft';
            sW = 'scrollWidth';
            wd = 'width';
        }

        if( mode ){
            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && obj[ sL ] == 0 ) ){
                return false
            }
        } else {
            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && Math.round( -obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) ){
                return false
            } else if( !mode && isSaf.firefox && this._direction == 'rtl' && ( val < 0 && obj[ sL ] == 0 ) ){
                return true
            } else if( ( val < 0 && obj[ sL ] == 0 ) && !( val < 0 && isSaf.safari && this._direction == 'rtl' && obj[ sL ] == 0 ) ){
                return false;
            }
        }
        return true
    }

    function getWheel( evt ) {
        var data = this._scrollData, min = data.min, max = data.max,
        fact1 = data.wheelSpeed, fact = fact1, uA = isSaf.uA.toLowerCase(), inf = this._infiniteScroll, ie = isSaf.isIE11Lyte;
        if( ( uA.indexOf('edge') != -1 || (( uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1)) ) && this._direction == 'rtl' ){
            fact1 *= -1
        }
        // if( evt.shiftKey ) {
        //     fact1 *= -1; fact *= -1; 
        // }
        var x, 
        y, 
        delta = evt.deltaMode && evt.deltaMode == 1,
        __deltaX = evt.deltaX,
        __deltaY = evt.deltaY;

        if( evt.shiftKey ){
            var __temp = __deltaX;
            __deltaX = __deltaY;
            __deltaY = __temp;
        }

        if( __deltaX > 0 ) {
            x = Math.max( delta ? ( __deltaX * 6 ) :  __deltaX, (inf ? 0 : 4 ) )
        } else if( __deltaX < 0 ) {
            x = Math.min( inf ? 0 : -4, delta ? ( __deltaX * 6 ) : __deltaX )
        }
        if( __deltaY > 0 ) {
            y = Math.min( max, Math.max( delta ? ( __deltaY * 6 ) : __deltaY, inf ? 0 : 4 ), ie ? 20 : Infinity );
        } else if( __deltaY < 0 ) {
            y = Math.max( min, Math.min( inf ? 0 : -4, delta ? ( __deltaY * 6 ) : __deltaY ), ie ? -20 : -Infinity );
        }
        return [ x * fact1, y * fact ]
    }

    function nestedScroll( evt, ret ){  
        var target = evt.target;
        while( target != this ) {
            var sT = Math.round( target.scrollTop ),
            sH = target.scrollHeight,
            oH = target.offsetHeight,
            compsty = window.getComputedStyle( target ),
            isMatch = ( /scroll|auto/i.test( compsty.overflowY ) || ( target.classList.contains( 'lyteScrollBar' ) && /hidden/i.test( compsty.overflowY  ) ) );


            if( oH < sH  ){
                if( ret ){
                    if( oH + sT < sH && isMatch ){
                        return true;
                    }
                } else {
                    if( sT && isMatch ){
                        return true;
                    }
                }
            }
            target = target.parentNode;
        }
    }

    function wheelEvent1( evt, tch ) {            
        var ret = tch || getWheel.call( this, evt );
        var a = ret[ 0 ] || 0, 
        b = ret[ 1 ] || 0, 
        mode = false, 
        obj = this._wheelObj || {} , 
        fit, 
        stpre, 
        isTable = this.classList.contains( 'lyteTableScroll' ),
        __deltaX = evt.deltaX,
        __deltaY = evt.deltaY,
        scrolldata = this._scrollData;

        if( evt.shiftKey ){
            var __temp = __deltaX;
            __deltaX = __deltaY;
            __deltaY = __temp;
        }

        if( Math.abs( tch ? a : ( __deltaX || 0 ) ) <= Math.abs( tch ? b : ( __deltaY || 0 ) ) ) {
            mode = true
        }
        if( scrolldata.nested && mode && nestedScroll.call( this, evt, b > 0 ) ){
            return;
        }

        if( scrolldata.showOn == 'scroll' ){
            if( !this._enableScroll ){
                mouseenter.call( this, true )
                evt.preventDefault();
                return
            }
            clearTimeout( this._scrollplugin )  
            this._scrollplugin = setTimeout(mouseleave.bind( scrolldata.appendTo == "parent" ? this.parentElement : this, {} ), scrolldata.tOut )
        }

        if( this._scrollEnd ) {
            obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };
            this._wheelObj = obj
            if( this.classList.contains( 'lyteTableScroll' ) ){
                forTable.call( this, obj )
            }
        }
        if( this._wheelObj ){
            fit = fitForScroll.call( this, mode, obj );
            if(( fit.scroll && mode /*&& b > 0*/ && (  !this._vertDiv || ( this._vertDiv && !this._vertDiv.classList.contains( 'visible' ) ) ) ) || ( fit.scroll && !mode /*&& a < 0*/ && ( !this._horiDiv || ( this._horiDiv && !this._horiDiv.classList.contains( 'visible' ) ) ) ) ){
                return
            }
            stpre = shouldPrevent.call( this, obj, mode, mode ? b : a ); 


            var is_inf = this._infiniteScroll,
            is_stopped = is_inf ? this.comp._stopScroll : false;

            if( ( is_inf && b > 0 ) || stpre ){
                 evt.preventDefault();
                if( !stpre && isTable && mode ) {
                    this.comp.scrollTable.call( this.comp, { yScroll : b }, this._wheelObj )
                }
            } else{
                if( scrolldata.preventOnEnd ){
                    evt.preventDefault();
                }
                return
            }
        }
        if( mode ) {
            if( isSaf.isIE11Lyte ) {
                if( this._wheelObj ){
                    this._wheelObj.scrollTop = Math.max( Math.min( this._wheelObj.scrollTop + b, this._wheelObj.scrollHeight - this._wheelObj.bcr.height ), 0 )
                    if(  isTable ) {
                        evt.yScroll = b;
                        this.comp.scroll.call( this, evt )
                    }
                    this.scrollTop += b;
                } 
            } else if( !isSaf.isIE11Lyte ) {
                this.scrollTop += b;
            }
        } else {
             if( isSaf.isIE11Lyte ) {
                if( this._wheelObj ) {
                    this._wheelObj.scrollLeft = Math.max( Math.min( this._wheelObj.scrollLeft + a, this._wheelObj.scrollWidth - this._wheelObj.bcr.width ), 0 )
                    if(  isTable ) {
                        evt.xScroll = a;
                        this.comp.scroll.call( this, evt )
                    }
                    this.scrollLeft += a;
                }
            } else {
               this.scrollLeft += a; 
            }
         }   
        if( isSaf.safari || isSaf.isIE11Lyte || isSaf.isIpad ) {
                this._alive = true;
                clearTimeout( this._alivetime )
                this._alivetime = setTimeout( function(){
                   delete this._alive; delete this._alivetime; 
                }.bind( this ), 16 )
            this._scrollFun.call( this, evt )
        }


        // if( this.comp ){
        //     clearTimeout( this._overlay.time );
        //     !this._overlay.classList.contains( 'lytescrolling' ) && this._overlay.classList.add( 'lytescrolling' );
        //     this._overlay.time = setTimeout( function(){
        //         this._overlay.classList.remove( 'lytescrolling' );
        //         delete this._overlay.time;
        //     }.bind( this ), 250 ) 
        // }
    }

    function scroll( evt ) {
        var a, b, issafIE = isSaf.isIE11Lyte || isSaf.safari || isSaf.isIpad, isIe = isSaf.isIE11Lyte ;
        if( issafIE && evt && evt.type == 'scroll' && ( this._alive && !evt._byFunc ) ) {
            trigEvt.call( this, isSaf.mode.a, isSaf.mode.b, this._wheelObj || { bcr : {} }, evt )
        } else{
            var obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };
            this._wheelObj = obj
            if( this.classList.contains( 'lyteTableScroll' ) ){
                forTable.call( this, obj )
            }
            if( this.prevScrlLeft != obj.scrollLeft ) {
                a = obj.scrollLeft - ( this.prevScrlLeft || 0 );
                b = 0;
                updatePos.call( this, false, a , evt, obj )
            } 
            if( this.prevScrlTop!= obj.scrollTop ) {
                b = obj.scrollTop - ( this.prevScrlTop || 0 );
                a = 0;
                updatePos.call( this, true, b , evt, obj )
            }
            isSaf.mode.b = b; isSaf.mode.a = a;
            if( !isIe || ( issafIE && ( !this._alive || evt._byFunc ) ) ) {
               if(  this.classList.contains( 'lyteTableScroll' ) ) {
                    this.comp.scroll.call( this, evt )
                }
            }
        }
    }

     function hideScrollbar( evt ) {
        clearTimeout( this._scrollplugin );  
        this._scrollplugin = setTimeout( mouseleave.bind( this._scrollData.appendTo == "parent" ? this.parentElement : this ), 500 );
    }

    function forTable( obj ) {
        var component =  this.comp, headerList = component.$node.getElementsByTagName( 'lyte-th' )
        if( this._infiniteScroll ){
            obj.$nodeClient = this.parentElement.getBoundingClientRect();
            var dummy =  this.getElementsByClassName( 'lytePreventInfiniteScroll' );
            obj.neglected = [];
            for( var m = 0; m < dummy.length; m++ ) {
                if( /*isVisible( dummy[ m ] )*/ !dummy[ m ].classList.contains( 'lyteHidden' ) ) {
                    obj.neglected.push( dummy[ m ] );
                }
            }

            obj.compNeg = dummy;
            if( this.comp._top != undefined ) {
                obj.topElem = [];
                var body = this.getElementsByTagName( 'lyte-tbody' )[ 0 ],
                another = body.getElementsByTagName( 'lyte-tr' );
                for( var n = 0; n < another.length; n++ ) {
                    if( !another[ n ].classList.contains( 'dummy' ) ) {
                        obj.topElem.push( another[ n ] );
                    }
                }
                obj.topElem = obj.topElem[ this.comp._top + obj.compNeg.length ]
                obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};
                obj.bottmElem = body.querySelector( 'lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length ) ) + ')' );
                obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}
                obj.tbody = body
                obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};
            }
        }
        obj.scrollDivClient = obj.bcr;
        for(var k = 0; k < headerList.length; k++)
            {
                headerList[k].property = headerList[k].getBoundingClientRect();
                headerList[k].order = k
            }
        obj.calculated = true;  
    }

    function trigEvt( a, b, obj, evt ) {
        delete this._scrollEnd; 

        var offset = this._scrollData.offset,
        __direction = this._direction == "rtl";

        if( ( ( Math.ceil( obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) && !( __direction && isSaf.chrome ) ) || ( ( isSaf.firefox || isSaf.safari ) && __direction && ( Math.ceil( -obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) ) || ( __direction && isSaf.chrome &&  obj.scrollLeft == offset.x ) ) {
            evt.horiScrollEnd = true;
        }
        if( Math.ceil( obj.scrollTop + obj.bcr.height + offset.y ) >= obj.scrollHeight ) {
            this._scrollEnd = evt.vertScrollEnd = true;
        }
        evt.yScroll = b; evt.xScroll = a;
        evt._byPlugin = true;
        this._wheelObj = obj;
    }

    function updatePos( mode, a, evt, obj ){
        var __this = this,
        __vert = __this._vertDiv,
        __hori = __this._horiDiv;

        if( parseInt( Math.abs( a ) ) == 0 || ( mode && !__vert ) ||( !mode && !__hori ) ){
            return;
        }

        var __out = mode ? __vert : __hori,
        rail_bcr = obj[ ( mode ? 'vert' : 'hori' ) + 'bcr' ] || __out.getBoundingClientRect(),
        __inn = __out.children[ 0 ],
        sL = "scrollTop",
        sW = "scrollHeight",
        wd = "height",
        lt = "top",
        direction = __this._direction == "rtl",
        btm = "bottom",
        __scrolldata = __this._scrollData,
        __bcr = obj.bcr,
        is_container = __scrolldata.appendTo != "parent",
        top_offset = mode ? ( __scrolldata.topOffset || 0 ) : 0;

        if( is_container ){
            rail_bcr = __bcr;
        }

        if( !mode ){
            sL = "scrollLeft";
            sW = "scrollWidth";
            wd = "width";
            lt = "left";
        }

        var __width = __bcr[ wd ],
        rail_bcr_lt = rail_bcr[ lt ],
        __rt = ( __width - ( rail_bcr_lt + top_offset - __bcr[ lt ] ) ) / obj[ sW ],
        trt = obj[ sL ] / obj[ sW ],
        mL = __scrolldata.minLength,
        minLength = mL ? ( mL != "auto" ? mL : 0 ) : 0.1 * __width,
        __final;

        set( __inn, wd, Math.max( __rt * __width, minLength ).toFixed( 3 ) + 'px' );

        if( direction && __inn._direction ){
            if( ( isSaf.safari && (  window._lyteUiUtils.isNegativeScroll() || !window.chrome ) ) || isSaf.firefox ) {
                __final =  ( ( obj[ sL ] / obj[ sW ] * 100 )  * obj.bcr[ wd ] / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );;
            } else {
                __final =  ( ( -( obj[ sW ] - __width - obj[ sL ] ) / obj[ sW ] * 100 ) * __width / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );
            }
            __final = 'translateX(' + __final + '%)';
        } else {
            __final = ( mode ? 'translateY' : 'translateX' ) + '(' + trt * ( __width - ( rail_bcr_lt - __bcr[ lt ] ) - ( Math.max( 0, minLength - __rt * __width ) ) ) + 'px)';
        }

        set( __inn, 'transform', __final );

        if( is_container ){
            set( __out, wd, __width + 'px' );

            var __other_elem = mode ? __hori : __vert,
            __to_set = 'translate' + '(' + obj.scrollLeft + 'px,' + obj.scrollTop + 'px)';

            set( __other_elem, 'transform', __to_set );
            set( __out, 'transform', __to_set );
        }

        __this.prevScrlLeft = obj.scrollLeft; 
        __this.prevScrlTop = obj.scrollTop;

        if( evt.type ){
            trigEvt.call( __this, mode ? 0 : a, mode ? a : 0, obj, evt );
        }
    }

    function removeScroll(){
        var elements = this;
        for( var i = 0; i < elements.length; i++ ) {
            var elem = elements[ i ], wrap = elem.parentElement;
            if( !wrap ){
                continue;
            }

            var scrolldata = elem._scrollData;

            if( scrolldata ) {

                if( scrolldata.appendTo != "parent" ){
                    wrap = elem;
                }

                delete elem._scrollData;
            }
            var scrollDivs = wrap.querySelectorAll( 'div.lyteScrollContainer' );
            for(var k = 0; k < scrollDivs.length; k++){
                if( scrollDivs[k].parentElement == wrap ) {
                    delete scrollDivs[ k ]._entertimeout;
                    delete scrollDivs[ k ]._leavetimeout;
                    wrap.removeChild(scrollDivs[k]);
                }
            }
            elem.classList.remove( 'lyteScrollBar', 'eventBinded' );
            elem.removeEventListener( 'mouseenter', mouseenter, true );
            elem.removeEventListener( 'wheel', initialWheel, true );
            elem.removeEventListener( 'touchstart', mouseenter, true )
            wrap.removeEventListener( 'mouseleave', mouseleave, true );
            elem.removeEventListener( 'mousedown', mousedown );
            elem.removeEventListener( 'touchmove', wheelEvent, { passive : false } )
            elem.removeEventListener( 'scroll', scroll, true );
            clearTimeout( elem._tchtime );
            if( elem._mouseleave ){
                document.removeEventListener( 'touchcancel', elem._mouseleave, true );
                document.removeEventListener( 'touchend', elem._mouseleave, true );
            }
            delete elem._wheelObj; delete elem._vertDiv; delete elem._horiDiv;
            delete elem._scrollFun; delete elem._alivetime; delete elem._alive; delete elem._wheelObj;
            delete elem.resetScrollbar; delete wrap._scrolldiv; delete elem._tchtime;
            delete elem._allowTouch;
            elem.classList.remove( 'eventBinded' );
            elem.tabIndex = elem._tabindex;
            delete elem._tabindex; delete elem._wheelObj;
            delete elem._prevPosY; delete elem._mouseleave;
            delete elem._prevPosX; delete elem._wheelEvt;
        }
        return this;
    }

    function destroy(){
        $L( '.lyteScrollBar' ).scroll( 'destroy' );
        window.removeEventListener('scroll', globalscroll, true ); 
        return this; 
    }

    function reset(){
        var elements = this;
        for( var i = 0; i < elements.length; i++ ){
            var __elems = elements[ i ],
            data = __elems._scrollData;

            if( data ){
                if( data.appendTo != "parent" ){
                    var obj = {
                        transform : "",
                        width : "",
                        height : ""
                    };
                    
                    $L( __elems._horiDiv ).css( obj );
                    $L( __elems._vertDiv ).css( obj );
                }
               __elems.resetScrollbar( true, true );
            }
        }
        return this;
    }

    $L.prototype.removeScroll = function(){
        // console.warn( 'removeScroll deprecated. Use scroll("destroy") instead' );
        return removeScroll.call( this );
    }

    $L.prototype.scroll = function( obj ) {
        if( obj && obj.constructor == String ){
            if( obj == "destroy" ){
                return removeScroll.call( this );
            } else if( obj == "destroyScroll" ){
                destroy.call( this );
            } else if( obj == "reset" ){
                reset.call( this );
            }
            return;
        }

        var fn = function( obj, name, _default ){
            var value = obj[ name ];
            if( value == void 0 ){
                value = _default;
            }
            obj[ name ] = value;
        };

        obj = obj || {};
        obj.showOn = obj.showOn || 'hover';
        obj.keyStep = obj.keyStep || 30;
        obj.wheelSpeed = obj.wheelSpeed || 1;
        // its a major change. to ensure same behaviour of normal scroll and to overcome issue in browser zoomed state changed this to false
        fn( obj, 'preventOnEnd', false );
        obj.offset = obj.offset || { x : 0, y : 0 };
        obj.tOut = obj.scrollTimeout || 500;
        obj.nested = obj.nested || false;
        obj.min = obj.min || -Infinity;
        obj.max = obj.max || Infinity;

        obj.appendTo = obj.appendTo || "parent";

        fn( obj, 'scrollYMarginOffset', 5 );
        fn( obj, 'scrollXMarginOffset', 5 );
        if( obj.preventXScroll ){
            obj.preventHorizontal = true; 
        }
        if( obj.preventYScroll ){
            obj.preventVertical = true;
        }
        var elements = this,
        is_parent = obj.appendTo == "parent";

        for( var i = 0; i < elements.length; i++ ) {
            var elem =  elements[ i ], vertDiv, horiDiv, wrp = elem.parentElement;
            is_parent && set( wrp, 'position', 'relative' );
            if( elem._scrollData ) {
                $L( elem ).removeScroll()
            }
            elem.resetScrollbar = mouseenter.bind( elements[ i ] );
            is_parent && ( wrp._scrolldiv = elem );
            elem._scrollData = obj;
            if( !obj.preventVertical ) {
                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerY', obj, void 0, is_parent );
                if(obj.verticalPosition == 'left'){
                    vertDiv.classList.add('left');
                }
            }
            if( !obj.preventHorizontal ) {
                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerX', obj, true, is_parent );
                if(obj.horizontalPosition == 'top'){
                    vertDiv.classList.add('top');
                }
            }
            if(isSaf.firefox ){
                elem.scrollLeft = 0;
                elem.scrollTop = 0;
            } 
            elem.addEventListener( 'mouseenter', mouseenter, true )
            elem.addEventListener( 'touchstart', mouseenter, true )
            elem.addEventListener( 'touchmove', wheelEvent, { passive : false } )
            elem.addEventListener( 'mousedown', mousedown );
            elem.addEventListener( 'wheel', initialWheel, true );
            
            if( obj.showOn != 'always' ){
                ( is_parent ? wrp : elem ).addEventListener( 'mouseleave', mouseleave, true )
            } else {
                setTimeout( mouseenter.bind( elem ), 100, {} )
            }

            elem.classList.add( 'lyteScrollBar' )
            elem._scrollFun = scroll;
        }
      return this;
    }

    $L.prototype.destroyLyteScroll = function(){
        // console.warn( 'destroyLyteScroll deprecated. Use scroll("destroyScroll") instead' );
        return destroy.call( this );  
    }

    $L.prototype.resetScrollbar = function(){
        // console.warn( 'resetScrollbar deprecated. Use scroll("reset") instead' );
        return reset.call( this );
    }

    function globalscroll( evt ){
        var el = evt.target.correspondingElement || evt.target;
        if( el != document && el != document.body && el._scrollFun ) {
            el._scrollFun.call( el, evt );
        }
        if( evt._byFunc ) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
        }
    }
    window.addEventListener('scroll', globalscroll, true ); 
   }
} );

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_zoho_lyte-ui-component_components_javascript_lyte-table_js.js.map