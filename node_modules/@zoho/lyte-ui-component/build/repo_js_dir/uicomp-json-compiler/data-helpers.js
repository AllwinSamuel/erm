var path = require("path");
var fs = require("fs");
var espree = require("espree");
var html2json = require('html2json').html2json;
var jsPath = path.resolve(__dirname,'../dist/components/');
var metaFiles = ['meta.json','syntax.txt'];

var errorMsgs = {
	missingFileIn:(component,filename) => filename+' for '+component+' is missing',
	parsingError:(component,error) => console.error(component+'\n'+error)
};

String.prototype.hash = function(){
	const basePrime = 26031997;
	const shiftingPrime = 19970207;
	const emptyString = '';//No I18n
	let hash = basePrime,scr = emptyString;//No I18n
	if (this.length === 0){
		return hash;
	}
	this.split(emptyString).forEach(function(ch,index){
		scr += (hash << hash - shiftingPrime) + this.charCodeAt(index)
		hash |= 0 
	}.bind(this))
	return scr.split(emptyString).reverse().join(emptyString).substring(this.length, this.length * 2);
}
const $ = {
	metaInfoPath : path.resolve(__dirname,'../components/metaInfo'),
	allUiComponents : fs.existsSync(jsPath)?
					  fs.readdirSync(jsPath)
						.filter((child) => !fs.statSync(path.join(jsPath,child)).isDirectory() && child.startsWith('lyte-'))
						.map((name) => name.replace(".js","")):[], // This line will generate an array of all ui components present 
	getName:(fileName) => fileName.split('.').shift(),
	getExt:(fileName) => fileName.split('.').pop(),
	getLast:(filePath) => filePath.split('/').pop(),
	getChildFoldersOf:(directory) => fs.existsSync(directory)?fs.readdirSync(directory).filter((child) => fs.statSync(path.join(directory,child)).isDirectory()):[],
	constructJsPath:(component) => path.join(jsPath,component+'.js'),
	constructBasePath:(component) => path.join($.metaInfoPath,component),
	getContent:(dir) => fs.existsSync(dir)?fs.readFileSync(dir,'utf-8'):null,
	setContent:(dir,content) => fs.writeFileSync(dir,content),
	checkForMetaFiles:(component,throwError=true) => {
		const basePath = $.constructBasePath(component);
		const pathsToCheck = metaFiles.map((filePath) => path.join(basePath,filePath));
		for(let i in pathsToCheck){
			if(!fs.existsSync(pathsToCheck[i])){
				if(throwError){
					throw new Error(errorMsgs.missingFileIn(component,metaFiles[i]));
				}else{
					return false;
				}
			}
		}
		return true;
	},
	parseJs:(data) => {
		try{
		    var object = espree.parse(data,{ ecmaVersion: 6,sourceType: "script" });
			var componentProperty = [],subComponents = new Set();
		    object.body.forEach(function(node){
		        if(node.expression){
		            let callee = node.expression.callee;
		            if(callee && callee.object && callee.object.object && callee.object.property && callee.property ){
		                let name = callee.object.object.name+"."+callee.object.property.name+"."+callee.property.name
		                if(name.toLowerCase() === "lyte.component.register"){
							let argumentArray = node.expression.arguments;
		                    argumentArray.forEach((argument)=>{
		                        if(argument.type === "ObjectExpression"){
		                            argument.properties.forEach((property)=>{
		                                if(property.key.name === "data" && property.value.type === "FunctionExpression"){
		                                    let body = property.value.body.body[0];
		                                    if(body.type === "ReturnStatement"){
		                                        body.argument.properties.forEach((lyteproperty)=>{
		                                            let name = lyteproperty.key.value!==undefined ? lyteproperty.key.value:lyteproperty.key.name;
		                                            if(name.indexOf("ltProp") > -1 ){
		                                                let propertyObj = {};
		                                                propertyObj._name=name;
		                                                propertyObj._type=lyteproperty.value.arguments[0].value;
		                                                if(lyteproperty.value.arguments[1]){
		                                                    propertyObj._default= lyteproperty.value.arguments[1].properties[0].value.value;
		                                                }
		                                            	componentProperty.push(propertyObj);
		                                            }    
		                                        });
		                                    }
										}else if(property.key.name === "_template"){
											let htmlString = property.value.value;
											let json = html2json(htmlString);
											let regex = new RegExp("^lyte-.+");
											let getNodesFrom = (array)=>{
												array.forEach(function(elem){
													getNodesFrom(elem.child||[]);
													if(elem.node === 'element' && regex.test(elem.tag)){
														subComponents.add(elem.tag);
													}
												})
											}
											getNodesFrom(json.child);
											subComponents.delete("lyte-yield");
											// this is done to remove the ui components in the object
											subComponents.forEach((component) => $.allUiComponents.includes(component) && subComponents.delete(component))
										}
		                            });
								}
							});
		                }
					}
					if(callee && callee.object && callee.property){
						let name = callee.object.name+"."+callee.property.name;
						if(name === 'Lyte.createCustomElement'){
							subComponents.add(node.expression.arguments[0].value);
						}
					}
		        }
		    });
		    return [ componentProperty,Array.from(subComponents) ];
		}catch(error){
		    return [];
		}
	},
	generateHashFor:(string)=>{
		return string.hash();
	},
	addPropsToWatchFrom:(value,array)=>{
		if(Array.isArray(value)){
			if(!array.some(elem => elem.every(prop => value.includes(prop)) && value.every(prop => elem.includes(prop)))){
				array.push(value);
			}
		}else{
			try{
				const parsed = espree.parse(value,{ ecmaVersion: 6,sourceType: "script" });
				const content = parsed.body[0];
				if(content.type === 'ExpressionStatement'){//No I18n
					let expressions = [];
					if(content.expression.type === 'SequenceExpression'){//No I18n
						expressions = expressions.concat(content.expression.expressions)
					}else if(content.expression.type === 'AssignmentExpression'){//No I18n
						expressions = expressions.concat(content.expression);
					}
					let properties = expressions.map(expression => expression.left.name);
					if(!array.some(elem => elem.every(prop => properties.includes(prop)) && properties.every(prop => elem.includes(prop)))){
						array.push(properties);
					}
				}
			}catch(e){
				console.error(e);
			}
		}
	},
	updateExtractedData:(component) => {
		const [ properties,subComponents ] = $.parseJs($.getContent($.constructJsPath(component)));
		const basePath = $.constructBasePath(component);
		const metaJsonPath = path.join(basePath,'meta.json');
		const meta = JSON.parse($.getContent(metaJsonPath));
		properties.forEach((prop) => {
			if(prop._type === 'object'){
				meta._objectData[prop._name] = {}
			}else{
				if(prop._type === 'array'){
					meta._heterogenousArray[prop._name] = false;
				}
				meta._allowedValues[prop._name] = [];
			}
		});
		meta._subComponents = subComponents;
		$.setContent(metaJsonPath,JSON.stringify(meta,null,'\t'));
	},
	createFolder:(folderPath) => {
		if(!fs.existsSync(folderPath)){
			fs.mkdirSync(folderPath);
		}
	},
	createMetaFilesFor:(component) => {
		const basePath = $.constructBasePath(component);
		const pathsToCreate = metaFiles.map((filePath) => path.join(basePath,filePath));
		$.createFolder($.metaInfoPath);
		$.createFolder(basePath);
		const defaultContent = {
			'meta':JSON.stringify({_allowedValues:{},_methods:[],_dependencies:[],_objectData:{},_heterogenousArray:{},_experimentalAttributes:[],_utilityFunctions:[],_excludeMethods:[],_cloneMethodsFrom:[],_subComponents:[]},null,4),
			'syntax':"## Component Name: "+component.toUpperCase()+"\n\n## non-yielded ##\n\n<"+component+"></"+component+">"
		}
		pathsToCreate.forEach((filePath,index) => {
			$.setContent(filePath,defaultContent[$.getName(metaFiles[index])]);
		})
	},
	getPropsOf:(component,excludeProps) => {
		let json = {};
		const compiledJson = path.join($.constructBasePath('lyte-'+component),'lyte-'+component+'.json');
		if(fs.existsSync(compiledJson)){
			try{
				json = JSON.parse($.getContent(compiledJson)).properties||{};
				excludeProps.forEach(function(prop){
					delete json[prop];
				})
				return json;
			}catch(e){
				errorMsgs.parsingError(component,e);
				return {};
			}
		}else{
			return {};
		}
	},
	setCustomValues:(customCommand,object) => {
		var data = espree.parse(customCommand,{ecmaVersion: 6,sourceType: "script"});
		if(data.body && Array.isArray(data.body)){
			var value;
			if(data.body.length===0 && !object.hasOwnProperty("type")){
				object.type="string";
			}else{
				data.body.forEach((objData) => {
					try{
					switch(objData.expression.callee.name){
						case "range":
							if(!object.type){
								object.type = "number";
							}
							object.minValue = objData.expression.arguments[0].value;
							object.maxValue = objData.expression.arguments[1].value;
							if(objData.expression.arguments[2]){
								object.step = objData.expression.arguments[2].value;
							}
						break;
						case "minValue":
							value = objData.expression.arguments[0].value;
							object.minValue = value;
							if(!object.type){
								if(/^\d+\D+$/.test(value)){
									object.type = "string";
								}else{
									object.type = "number";
								}
							}
						break;
						case "maxValue":
							value = objData.expression.arguments[0].value;
							object.maxValue = value;
							if(!object.type){
								if(/^\d+\D+$/.test(value)){
									object.type = "string";
								}else{
									object.type = "number";
								}
							}
						break;
						case "step":
							value = objData.expression.arguments[0].value;
							object.step = value;
							if(!object.type){
								object.type = "number";
							}
						break;
						case "clonePropertiesOf":{
							object.type = "object";
							let excludeProps = [];
							if(objData.expression.arguments[1] && objData.expression.arguments[1].callee.name === "exclude"){
								excludeProps =  objData.expression.arguments[1].arguments.map((property) => property.name);
							}
							object.objectData = $.getPropsOf(objData.expression.arguments[0].name.toLowerCase(),excludeProps);
						}
						break;
						case "allowedSuffix":
							object.allowedSuffix = objData.expression.arguments.map((data) => data.value);
						break;
						case "defaultValue":
							object.defaultValue = objData.expression.arguments[0].value;
						break;
						case "allowedValues":
							object.allowedValues = objData.expression.arguments[0].elements.map((data) => data.value);
						break;
						case "type":
							object.type = objData.expression.arguments[0].value;
						break;
					}
				}catch(e){
					console.log(e);
				}
				});
			}
		}
	},
	convertToJson:(html) => {
		try{
			return html2json(html);
		}catch(e){
			console.error(e);
		}
	},
	extend:(propertiesToAdd,jsonPath) => {
		let json;
		let jsonContent = $.getContent(jsonPath);
		if(jsonContent){
			try{
				json = JSON.parse(jsonContent);
			}catch(e){
				console.log(e);
				return;
			}
			propertiesToAdd.forEach(property => json[property] = []);
			$.setContent(jsonPath,JSON.stringify(json,null,'\t'));
		}
	},
	remove:(propertiesToRemove,jsonPath) => {
		let json;
		let jsonContent = $.getContent(jsonPath);
		if(jsonContent){
			try{
				json = JSON.parse(jsonContent);
			}catch(e){
				console.log(e);
				return;
			}
			propertiesToRemove.forEach(property => delete json[property]);
			$.setContent(jsonPath,JSON.stringify(json,null,'\t'));
		}
	},
	constructMethods:(obj) => {
		const array = obj.toInclude;
		obj.toImport.forEach(component => {
			const jsonContent = $.getContent(path.join($.constructBasePath(component),'meta.json'))||'{}';
			const json = JSON.parse(jsonContent);
			array.concat((json._methods||[]).filter(method => !(json._excludeMethods||[]).includes(method))||[]);
		});
		return array.filter(method => obj.toExclude.includes(method));
	}
}
module.exports = $;