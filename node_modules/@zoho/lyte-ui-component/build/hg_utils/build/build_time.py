import logging
import traceback
import xml.etree.ElementTree as ET
import os
from datetime import datetime
import datetime as dt

time_consuming_task = {}


def verify_time_format(time):
    try:
        _ = datetime.strptime(time, time_format[time.count(":")])
    except:
        logging.info("Invalid time format found. ( " + time + " ).Trying to fix it..")
        while float(time.split(":")[0]) > 59.0 or float(time.split(":")[1]) > 59.0:
            num = time.count(":")
            if num == 1 and int(time.split(":")[0]) > 59:
                time = "1:" + str(int(time.split(":")[0]) - 60) + ":" + time.split(":")[1]
            elif num == 2 and int(time.split(":")[1]) > 59:
                time = str(int(time.split(":")[0]) + 1) + ":" + str(int(time.split(":")[1]) - 60) + ":" + time.split(":")[2]
        logging.info("After time correction : " + time)
    return time


def get_log_filename(filename):
    task_log_file = ""
    logfiles = os.listdir(os.getcwd())
    for logfile in logfiles:
        if logfile.endswith('.log') and logfile.startswith(filename) and not logfile.endswith("err.log"):
            task_log_file = logfile
    return task_log_file


def max_time_fnc(task_dicts):
    try:
        time_list = []
        task_list = []
        for task, time in task_dicts.items():
            task_list.append(task)
            time_list.append(time.replace("sec", ""))
        max_t = time_list[0]
        for max_index in range(1, len(time_list)):
            if not time_list[max_index].__contains__("."):
                time_list[max_index] += ".0"
            if not max_t.__contains__("."):
                max_t += ".0"
            if (datetime.strptime(max_t, time_format[max_t.count(":")]) - datetime(1900, 1, 1)) < (datetime.strptime(time_list[max_index], time_format[time_list[max_index].count(":")]) - datetime(1900, 1, 1)):
                max_t = time_list[max_index]
        return max_t, task_list[time_list.index(max_t)]

    except Exception as e:
        logging.error("Exception occurred while calculating time taken by order and value assigned as 'nil'.\n" + "ERROR : " + str(e) + "\nTRACEBACK : " + str(traceback.format_exc()))
        return "Nil", "Nil"


def task_time_file_creation(sec):
    try:
        temp_dict = time_consuming_task.copy()
        for _ in range(len(time_consuming_task)):
            max_time, task_key = max_time_fnc(temp_dict)
            temp_dict.pop(task_key)
            if not max_time.__contains__("."):
                max_time += ".0"
            if datetime.strptime(max_time, time_format[max_time.count(":")]) - datetime(1900, 1, 1) < dt.timedelta(seconds=sec):
                break
            with open("task_time.txt", "a") as f:
                f.write(task_key + ";" + str(max_time) + "sec\n")
            f.close()
        return 0
    except Exception as e:
        logging.error("Error while creating Task_time.txt\n" + "ERROR : " + str(e) + "\nTRACEBACK : " + str(traceback.format_exc()))
        return 1


def prettify(element, indent='  '):
    queue = [(0, element)]
    while queue:
        level, element = queue.pop(0)
        children = [(level + 1, child) for child in list(element)]
        if children:
            element.text = '\n' + indent * (level + 1)
        if queue:
            element.tail = '\n' + indent * queue[0][0]
        else:
            element.tail = '\n' + indent * (level - 1)
        queue[0:0] = children


def ordertodict(dict_values):
    name = "".join(dict_values).strip()
    for order1 in (name.split(";")):
        if order1 != "":
            order1_list = order1.split(":", 1)[1].split(",")
            for order2 in order1_list:
                order_dict[order2.replace(":", "")] = order1.split(":")[0]


def contextpk_order(sub_contents, root):
    global ordername, order_dict
    condition = True
    sub_pkg_name = ""
    order_list = []
    length = len(sub_contents)
    root = ET.SubElement(root, "subtask",
                         {"name": sub_contents[length - 1].strip().split(" ")[1] + ":" +
                                  sub_contents[0].strip().split(" ")[-1], "ordername": ordername,
                          "timetaken": verify_time_format(sub_contents[length - 1].strip().split(" ")[6]) + "sec"})
    for sub_index in range(1, len(sub_contents) - 1):
        values = sub_contents[sub_index].strip().split(" ")
        try:
            if values[0] == "contextpkgpara" and sub_pkg_name == "":
                sub_pkg_name = values[4]
                sub_inital = sub_index
                condition = False

            elif values[0] == "contextpkgpara_order":
                for val in values[2].split(","):
                    order_list.append(val)

            elif values[0] in order_list and condition:
                ordertodict(values)

            elif values[1] == "contextpkgpara" and values[3] == sub_pkg_name:
                condition = True
                temp_root = root
                temp_order_dict = order_dict
                order_dict = {}
                contextpk_order(sub_contents[sub_inital:sub_index + 1], root)
                root = temp_root
                order_dict = temp_order_dict
                sub_pkg_name = ""

            elif condition and values[0] == "task" and values[1] != "contextpkgpara":
                logfile_name = get_log_filename(values[1] + "_" + values[3] + "_")
                sub_task = ET.SubElement(root, values[0],
                                         {"name": values[1], "variable": values[3],
                                          "ordername": order_dict[values[1] + values[3]],
                                          "timetaken": verify_time_format(values[6]) + "sec", "filename": logfile_name})
                time_consuming_task[ordername + "/" + sub_contents[length - 1].strip().split(" ")[1] + ":" + sub_contents[0].strip().split(" ")[-1] + "/" + order_dict[values[1] + values[3]] + ";" + values[1] + "/" + values[3]] = values[6]

        except:
            pass


order_dict = {}
contextpk = []
contextpk_name = ""
subtask_condition = True
time_format = ['%S.%f', '%M:%S.%f', '%H:%M:%S.%f']
try:
    os.chdir(os.getcwd() + "/buildlogs")
    logging.basicConfig(filename="build-time-report.log", filemode='a', format='%(asctime)s - %(message)s', level=logging.INFO)
    logging.info(" => Build_time.xml creation Started.\n")
    with open("build_time_new.txt") as f:
        content = f.readlines()
        for value in content:
            value = value.strip().split(" ")
            if value[0] == "build":
                root = ET.Element('build', {"TotalBuildTime": verify_time_format(value[4]) + value[5]})
                temp = root
except Exception as e:
    logging.error("ERROR occurred while build-time table creation.\n" + "ERROR : " + str(e) + "\nTRACEBACK : " + str(traceback.format_exc()))
    exit(1)
for index in range(len(content)):
    value = content[index].strip().split(" ")

    try:
        if value[0] == "build":
            break

        elif value[0] == "contextpkgpara" and contextpk_name == "":
            contextpk_name = value[4]
            inital = index
            subtask_condition = False

        elif value[1] == "contextpkgpara" and value[3] == contextpk_name:
            contextpk_order(content[inital:index + 1], root)
            contextpk_name = ""
            subtask_condition = True

        elif value[0] == "target" and subtask_condition:
            if value[2] == "started":
                root = ET.SubElement(root, value[0])
                target = root
                ordername = value[1]
            else:
                root.attrib = {"name": value[1], "timetaken": verify_time_format(value[4]) + "sec"}
                root = temp

        elif value[0] == "task" and subtask_condition:
            logfile_name = get_log_filename(value[1] + "_" + value[3] + "_")
            elem = ET.SubElement(root, value[0], {"name": value[1], "variable": value[3],
                                                  "ordername": ordername,
                                                  "timetaken": verify_time_format(value[6]) + "sec",
                                                  "filename": logfile_name})
            time_consuming_task[ordername + ";" + value[1] + "/" + value[3]] = value[6]

    except:
        pass

try:
    prettify(root)
    tree = ET.ElementTree(root)
    logging.info(" =>  Build_time.xml created Successfully.\n")
    tree.write("build_time_new.xml", encoding="UTF-8", xml_declaration=True)
except Exception as e:
    logging.error("Error while creating build_time_new.xml\n" + "ERROR : " + str(e) + "\nTRACEBACK : " + str(traceback.format_exc()))
    exit(1)

return_code = task_time_file_creation(60)
if return_code != 1 and not os.path.exists("task_time.txt"):
    return_code = task_time_file_creation(5)
if return_code != 1:
    logging.info(" =>  Task_time.txt is created successfully.\n")
