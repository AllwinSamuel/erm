#! /usr/local/bin/python

import os, re, datetime, logging

import urllib, httplib, json, time, inspect

def getToday():
    today = datetime.datetime.today().strftime('%b_%d_%Y')
    return today

def getTime(micro_sec=True):
    now = datetime.datetime.now()
    if micro_sec:
        date = now.strftime("%Y-%m-%d %H:%M:%S:%f")
    else:
        date = now.strftime("%H:%M:%S")
    return date

def getSec(s):
    l = s.split(':')
    return int(l[0]) * 3600 + int(l[1]) * 60 + int(l[2])

def calculateDelta(st_time, end_time):
    return datetime.datetime.strptime(end_time, '%H:%M:%S') - datetime.datetime.strptime(st_time, '%H:%M:%S')

class updateTime():
    def __init__(self, type):
        self.machine = 'cmtools-api.csez.zohocorpin.com'
        self.port = '443'
        self.type = type
        self.LOGS_DIR = 'logs'
        self.log_file = 'timeupdation.log'

    def getPrivateToken(self):
        file_path = "/zoho/build/WH_DIR/Nov_25_2024/LYTE_UI_COMPONENTS/LYTE_UI_COMPONENTS_9504002/LYTE_UI_COMPONENTS.txt"
        with open(file_path) as f:
            content = f.readlines()
            for i in content:
                line = i.strip()
                if len(line) != 0:
                    b = line.startswith("#")
                    if b != True:
                        if "=" in line:
                            key = line.split("=")[0]
                            value = line.split("=")[1]
                            if key == "TOOLS_REFERENCE_VALUE":
                                tokval = value.replace('"','')
                            if key == "GEN_REP_VALUE":
                                genval = value.replace('"','')
            tokval = tokval.replace(genval, '')
            return tokval

    def urlGet(self, url, params_dict, type):
        data = urllib.urlencode(params_dict)
        http_req = httplib.HTTPSConnection(self.machine)
        headers = {"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain", 'private_token': self.getPrivateToken()}
        output_data = {}
        try:
            http_req.request(type, '/api/v1/' + url, data, headers)
            response = http_req.getresponse()
            status = response.status
            if status not in [200, 304, 201]:
                body =  response.read()
                msg = response.msg
                reason = response.reason
                self.addLogs("Url : " + url + " " + str(status) + " " + str(msg) + " " + str(reason))
                self.addLogs("Error MSG : " + str(body))
                logging.error("Url : " + url + " " + str(status) + " " + str(msg) + " " + str(reason))
            else:
                output_data = response.read()
                output_data = json.loads(output_data)

            if url in output_data:
                output_data = output_data[url]

            return output_data
        except Exception as ex:
            self.addLogs(ex)
            return []

    def addLogs(self, messageString, logfile=None):
        if logfile is None:
            logfile = self.log_file

        filename = self.LOGS_DIR + os.sep + logfile
        messageString = "\n" + str(messageString) + "\n"

        if os.path.exists(filename):
            fileHandle = open(filename, 'a')
        else:
            if not os.path.exists(os.path.dirname(filename)):
                os.makedirs(os.path.dirname(filename))
            fileHandle = open(filename, 'w')
        try:
            fileHandle.write(messageString)
        except UnicodeEncodeError:
            fileHandle.write(messageString.encode('utf8'))

        fileHandle.close()
        return True

    def getTimeStamp(self, timestring):
        try:
            return time.mktime(time.strptime(timestring, '%b_%d_%Y %H:%M:%S'))
        except Exception as ex:
            self.addLogs("Unable to make time stamp for " + str(timestring))

    def getProduct(self, module):
        product = None
        url = 'products'
        params = {'module_name': module}
        products = self.urlGet(url, params, 'GET')

        for product in products:
            if 'module_name' in product and str(product['module_name']) == module:
                product = product['id']
        return product

    def addProduct(self, url, params):
        pdtObj = self.urlGet(url, params, 'POST')
        if pdtObj and 'id' in pdtObj:
            product = pdtObj['id']
        else:
            self.addLogs("Product " + str(prams) + " is not available in the Database.")
            product = None
        return product

    def getUser(self, username):
        user = None
        url = 'users'
        params = {'username': str(username).strip()}
        users = self.urlGet(url, params, 'GET')
        for user in users:
            if 'username' in user and str(user['username']) == username:
                user = user['id']
                break
        if user is None:
            user = self.addUser(url, params)
        return user

    def addclonetime(self, module, username, st_time, end_time, branch='', status=None):
        product = self.getProduct(module)
        if product:
            user = self.getUser(username)

            if self.type == 'clone':
                if end_time:
                    status = 'SUCCESS'
                else:
                    status = 'FAILED/KILLED'
            elif self.type == 'push':
                if status:
                    status = 'SUCCESS'
                else:
                    status = 'FAILED'

            params = {'process_type': self.type, 'product_id': product, 'user_id': user, 'branch': branch,
                      'started_at': st_time, 'finished_at': end_time, 'status': status}
            self.urlGet('operation_details/', params, 'POST')
        else:
            self.addLogs("Product is not found for the module " + str(module))

    def getProductDetails(self, prdName):
        url = 'products'
        params = {'name': prdName}
        productdetails = self.urlGet(url, params, 'GET')
        return productdetails

    def getPreviousBuildDetails(self, product_id, colabel, started_from):
        url = 'buildlogs'
        params = {'product_id': product_id, 'status': 'Success', 'checkout_label': colabel, 'availability': "A", 'per_page': 1}
        if started_from.lower() == 'cron':
            params.update({'started_from' : 'Cron'});
        buildlogDetails = self.urlGet(url, params, 'GET')
        if len(buildlogDetails) > 0:
            return buildlogDetails[0]

        return None

    def getBuildChangeset(self, buildid, product_id=None):
        url = 'changesetdetails'
        params = {'buildlog_id': buildid}
        if product_id:
            params['product_id'] = product_id

        changeset_details = self.urlGet(url, params, 'GET')

        return changeset_details

    def subGetTipChangeset(self, repoUrl, branchName):
        url = 'get_tip_changeset'
        params = {'repository_url': repoUrl, 'checkout_label': branchName}
        gettipchangeset_prod = self.urlGet(url, params, 'GET')

        return gettipchangeset_prod


    def getProductUsers(self, product_id, user_type=None):
        url = 'users'
        params = {'product_id': product_id, }
        if user_type:
            params['product_admin'] = user_type

        url = 'users'
        users = self.urlGet(url, params, 'GET')
        if len(users) > 0:
            return users

        return None

    def getProductUsersList(self, product_id, user_type=None):
        users_list = []

        users = getProductUsers(product_id, user_type)
        if not users:
            return users_list

        for user in users['users']:
            users_list.append(user['username'])

        return users_list

    def getProductUsersStr(self, product_id, user_type=None):
        users_str = ""

        users = getProductUsers(product_id, user_type)
        if not users:
            return users_str

        for user in users['users']:
            users_str = users_str + str(user['username'])

        return users_str

    def getUsers(self, userIds):
        params = ""
        for userId in userIds:
            params = params + "ids[]=" + str(userId)

        url = 'users'
        users = self.urlGet(url, params, 'GET')

        usersList = []
        for user in users['users']:
            usersList.append(user['username'])

        return usersList

    def getBuildDetails(self, prdId):
        url = 'builddetails'
        params = {'product_id': prdId, 'per_page': 1}
        details = self.urlGet(url, params, 'GET')
        if len(details) > 0:
            return details[0]

        return None

    def __getDetailsById(self, resource_name, resource_id):
        url = "%s/%s" % (resource_name, resource_id)
        result = self.urlGet(url, {}, 'GET')
        if len(result) > 0:
            return result[resource_name]

        return None

    def getRepoType(self, repo_id):
        repo_details = self.__getDetailsById("repository_types", repo_id)
        if repo_details:
            return repo_details['name']

        return None

    def getServerDetails(self, server_id):
        return self.__getDetailsById("servers", server_id)

    def getGroupDetails(self, group_id):
        return self.__getDetailsById("groups", group_id)

    def getLatestMilestone(self, branch_name, product_name):
        self.productId = self.getProductId(product_name);
        url = 'buildlogs'
        branch_params = {'checkout_label': branch_name, 'product_id': self.productId, 'availability': "M"}
        resultSet = self.urlGet(url, branch_params, 'GET')
        if resultSet and resultSet[0]:
            return str(resultSet[0]['url'])+str("#")+str(resultSet[0]['checkout_label'])
        else:
            default_params = {'product_id': self.productId, 'availability': "M"}
            latestMilestone = self.urlGet(url, default_params, 'GET')
            if latestMilestone and latestMilestone[0]:
                return str(latestMilestone[0]['url'])+str("#")+str(latestMilestone[0]['checkout_label'])
            else:
                return None
        return None

    def getProductId(self, prdName):
        url = 'products'
        params = {'name': prdName}
        self.products = self.urlGet(url, params, 'GET')
        return self.products[0]['id']

    def getDBID(self, prdName, IDCurl):		
        url = 'buildlogs?perpage=1'		
        self.productId = self.getProductId(prdName);		
        params = {"product_id":  self.productId, "url": IDCurl}		
        self.getDBID = self.urlGet(url, params, 'GET')
    
        if self.getDBID:
             return self.getDBID['buildlogs'][0]['id']
        else:
            return None

    def getChangeset(self, DBID):
        url='changesetdetails?perpage=1'
        params = {'buildlog_id': DBID}
        self.getChangeset = self.urlGet(url, params, 'GET')
        
        if self.getChangeset and self.getChangeset['changesetdetails']:
            return self.getChangeset['changesetdetails'][0]['changeset']
        else:
            return None

    def getmilestonemoveddetails(self, bldid):
        url = 'moved_details'
        params = {'buildlog_id': bldid}
        getmilestonemoveddetails = self.urlGet(url, params, 'GET')

        if getmilestonemoveddetails:
            return getmilestonemoveddetails[0]['location']
        else:
            return None

    def getmilestonemovedstatus(self, bldid):
        url = 'build_movement_states'
        params = {'buildlog_id': bldid}
        getmilestonemovedstatus = self.urlGet(url, params, 'GET')
        if getmilestonemovedstatus:
            return getmilestonemovedstatus
        else:
            return None

    def getIDCbuildChangeset(self, IDCbuildurl):
        url = 'buildlogs?perpage=1'
        params = {'url': IDCbuildurl}
        self.getIDCbuildChangeset = self.urlGet(url, params, 'GET')
        if self.getIDCbuildChangeset:
            return self.getIDCbuildChangeset['buildlogs'][0]
        else:
            return None

    def getProductIdByDownloadUrl(self, downloadUrl):
        url = 'products'
        params = {'download_url': downloadUrl}
        self.getProductIdByDownloadUrl = self.urlGet(url, params, 'GET')
        if self.getProductIdByDownloadUrl:
            return self.getProductIdByDownloadUrl[0]['id']
        else:
            return None

    def checkIsDependencyMilestone(self, prdId, bldLoc):
        url = 'buildlogs?perpage=1'
        params = {'product_id': prdId, 'location': bldLoc}
        self.checkIsDependencyMilestone = self.urlGet(url, params, 'GET')
        if 'buildlogs' in self.checkIsDependencyMilestone and self.checkIsDependencyMilestone['buildlogs']:
            return self.checkIsDependencyMilestone['buildlogs'][0]
        else:
            return None

 
    def getPreviousMilestoneChangeset(self, mlabel):
        pre_mlabel_cset = []
        url = 'buildlogs?per_page=1'
        cset_url = 'changesetdetails?per_page=1'
        params = {'release_version': mlabel}
        pre_mlbl_details = self.urlGet(url, params, 'GET')
        if pre_mlbl_details['buildlogs'] == []:
            return ""
        else:
            mle_buildid = pre_mlbl_details['buildlogs'][0]['id']

        if mle_buildid != 0:
            cset_url = 'changesetdetails?per_page=1'
            cset_params = {'buildlog_id': mle_buildid}
            mle_changeset = self.urlGet(cset_url, cset_params, 'GET')
            if mle_changeset['changesetdetails'] == []:
                return ""
            else:
                pre_mlabel_cset.append(mle_changeset['changesetdetails'][0]['changeset'])
                pre_mlabel_cset.append(mle_changeset['changesetdetails'][0]['tp_changeset'])
                pre_mlabel_cset.append(mle_buildid)
            return pre_mlabel_cset
        else:
            return ""

    def moveBuild(self, product, buildlog_id, comment):

        if comment.find(product) == -1:
            comment = product + "_" + comment

        location = comment.split(' ')[0]
        params = {'buildlog_id': buildlog_id, 'comment': comment, 'release_type': 'MAJOR_OR_MINOR', 'notify': '','location': location}
        url='moved_details'
        response = self.urlGet(url, params, 'POST')
        print("Response Values in MoveBuild in python Script =======>")
        print(response)
        return response
