{"version":3,"file":"vendors-node_modules_zoho_lyte-ui-component_components_javascript_lyte-table_js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAgBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAnnEA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsnEA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AA/HA;;AAkIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAx1EA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;;AAEA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AAGA;;AAjVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;;AAEA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AAGA;;AA1gCA;;;;;;;;;;;;;ACHA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://erm/./node_modules/@zoho/lyte-ui-component/components/javascript/lyte-table.js","webpack://erm/./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-sortable.js","webpack://erm/./node_modules/@zoho/lyte-ui-component/mixins/lyte-table-utils.js","webpack://erm/./node_modules/@zoho/lyte-ui-component/plugins/lyte-scrollbar.js"],"sourcesContent":["import { LyteTableUtilsMixin } from \"/mixins/lyte-table-utils.js\"\nimport { LyteTableSortableMixin } from \"/mixins/lyte-table-sortable.js\"\nimport { prop } from \"@slyte/core\";\nimport { Component, LyteUiComponentComponentRegistry } from \"../component.js\";\nimport $L from \"@zoho/lyte-dom\";\n\n/* @Slicer.otherframeworkStart */\nimport \"../../plugins/lyte-scrollbar.js\";\n/*  @Slicer.otherframeworkEnd */\n\n// Issues to fix\n\n// Combined width of fixed column should not exceed width of lyte-table\n\n/**\n * Lyte-table is a component used to display data in rows and columns\n * @component lyte-table\n * @dependency lyte-scrollbar\n *  /plugins/lyte-scrollbar.js\n *  /theme/compiledCSS/default/ltr/lyte-ui-scrollbar.css\n * @version 1.0.0\n */\n\nclass LyteTableComponent extends Component {\n    constructor() {\n        super();\n    }\n\n    init() {\n        var uA = window.navigator.userAgent,\n        cb = \"beforeRender\",\n        __this = this,\n        $node = __this.$node,\n        __window = window,\n        add = \"addEventListener\",\n        ns = '_tableResize';\n        \n        __this._dir = window._lyteUiUtils.getRTL();\n        __this.isIE11Lyte = /rv:11/ig.test( uA );\n        __this.isEdgeLyte = /Edge/ig.test( uA );\n        __this._browser = __this.isIE11Lyte || __this.isEdgeLyte || uA.match( 'Safari' );\n\n        /**\n         * @method beforeRender\n         * @version 1.0.1\n         */\n\n        __this.getMethods( cb ) && __this.executeMethod( cb, $node );\n\n        /**\n         * @utility scrollTable\n         * @version 1.0.4\n         */\n\n        $node.scrollTable = function( x, y ){\n            var scrollElem = ( __this.scrollDiv = __this.scrollDiv || $node.querySelector( 'div.lyteTableScroll' ) ),\n            undef = void 0,\n            evt = new Event( 'scroll', { bubbles: true } );\n\n            if( x != undef ){\n                scrollElem.scrollLeft = x;\n            }\n\n            if( y != undef ){\n                scrollElem.scrollTop = y;\n            }\n\n            evt._byFunc = true;\n            scrollElem.dispatchEvent( evt );\n\n            if( !__this.__from_collapse ){\n                __this.update_collapse( true );\n            }\n        }\n        /**\n         * @utility updateCollapse\n         * @version 3.92.0\n         */\n        $node.updateCollapse = __this.update_collapse.bind( __this );\n\n        if( !__window[ ns ] ){\n            __window[ ns ] = true;\n\n            var fn = window.resizeTable;\n\n            __window[ add ]( 'resize', fn, true );\n            __window[ add ]( 'orientationchange', fn, true );\n        }\n\n        /**\n         * @utility toggleRows\n         * @version 1.0.3\n         */\n\n         $node.toggleRows = function( val ){\n            var name = val ? 'remove' : \"add\",\n            __tags = this.ltProp('tags');\n\n            Array.from( this.querySelectorAll( __tags.tbody + ' ' + __tags.tr + '.lytePreventInfiniteScroll' ) ).forEach( function( item ){\n                item.classList[ name ]( 'lyteHidden' );\n            });\n         }\n\n    }\n\n    rtlfunc(lft, bcr, ww) {\n        if( this._dir && lft != 'top' && lft != 'clientY' ){\n            if( bcr ){\n                if( lft == 'right' ){\n                    return ww - bcr.left;\n                } else if( lft == 'clientX' ){\n                    return ww - bcr[ lft ];\n                }\n                return ww - bcr.right;\n            } else if( lft == 'left' ){\n                return 'right';\n            } else if( lft == \"right\" ){\n                return \"left\";\n            }\n        }\n        return bcr ? bcr[ lft ] : lft;\n    }\n\n    didDestroy() {\n        var __this = this,\n        __data = __this.data,\n        scrolldiv = __this.scrollDiv,\n        $node = __this.$node,\n        _window = window,\n        iso = __this._intersectionObs;\n\n        if( _window._tableResize && document.body.getElementsByTagName( 'lyte-table' ).length == 0 ){\n            var rel = \"removeEventListener\";\n\n            _window[ rel ]( 'resize', window.resizeTable, true );\n            _window[ rel ]( 'orientationchange', window.resizeTable, true );\n\n            delete _window._tableResize;\n        }\n\n        if( __data.ltPropNavigation ){\n           window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __data.ltPropTags.table )[ 0 ], 'unbind' );\n        }\n\n        $L.fastdom.clear( this.__collpse_fdom );\n        delete this.__collpse_fdom;\n\n        if( iso ){\n            __this._setmeasure && $L.fastdom.clear( __this._setmeasure );\n            iso.disconnect();\n\n            delete __this.reset;\n            delete __this._intersectionObs;\n            delete __this._intersections;\n        }\n\n        !__data.ltPropPreventScrollbar && scrolldiv && $L( scrolldiv ).removeScroll();\n\n        delete __this.scrollDiv; delete __this._dummy; delete __this._dummy1; delete __this.resizeComponent; delete __this.targetElem; delete __this._dummyTr;\n        delete $node.setValue; delete $node.scrollTable;\n    }\n\n    didConnect() {\n        var __data = this.data,\n        ltPropInfiniteScroll = __data.ltPropInfiniteScroll, \n        secData = __data.secondaryData,\n        // ltPropResize = __data.ltPropResize,\n        $node = this.$node,\n        __tags = __data.ltPropTags;\n\n        // if( __data.ltPropYield && (ltPropResize.vertical || ltPropResize.horizontal)) {\n        //     this.resizeComponentAppend();\n        // }\n        try {\n            var scrollDiv = $node.querySelector('div.lyteTableScroll');\n            // scrollDiv._overlay = scrollDiv.getElementsByTagName( 'lyte-overlaydiv' )[ 0 ];\n            this.scrollDiv = scrollDiv;\n            scrollDiv.comp = this;\n            scrollDiv._infiniteScroll = ltPropInfiniteScroll;\n            if ( !__data.ltPropPreventScrollbar && $L.prototype.scroll ) {\n                $L(scrollDiv).scroll( __data.ltPropScrollbarOption);\n                var scrollbar = $node.querySelector('.lyteScrollContainer.lyteScrollContainerY');\n                var header = $node.getElementsByTagName( __tags.th )[ 0 ], hgt;\n                $L.fastdom.measure(function () {\n                    var fg = this._dir;\n                    // while applying scroll plugin vertical scrollbar needs some offset for enabling the virtual of only body part is scrolling. If it is zero we have to set height of the header as offset\n                    if (header && scrollbar && scrollbar.offsetTop == 0) {\n                        hgt = header.getBoundingClientRect().height;\n                        $L.fastdom.mutate(function () {\n                            scrollbar.style.top = hgt + 'px';\n                            if (fg) {\n                                $node.classList.add('lyteRTL')\n                            }\n                        }.bind(this))\n                    }\n                    $L.fastdom.mutate(function () {\n                        __data.ltPropDualResize && $node.classList.add('lyteDualResize')\n                        if (this.getMethods('afterRender')) {\n                            this.executeMethod('afterRender', this.$node);\n                        }\n                    }.bind(this))\n                }.bind(this))\n            } else {\n                if (this.getMethods('afterRender')) {\n                    /**\n                     * @method afterRender\n                     * @version 1.0.1\n                     */\n                    this.executeMethod('afterRender', this.$node);\n                }\n            }\n        } catch (err) {\n        }\n        if (ltPropInfiniteScroll) {\n            $node.classList.add('infinitescroll')\n            /**\n             * @utility setValue\n             * @version 1.0.2\n             */\n            $node.setValue = function (ret) {\n                if (this._stopScroll) {\n                    this.appendAddData1.call(this, ret)\n                }\n            }.bind(this)\n\n            /**\n             * @utility removeRow\n             * @version 2.2.17\n             */\n\n            $node.removeRow = function (row) {\n                this.removeRow(row);\n            }.bind(this);\n\n            /**\n             * @utility scrollToRecord\n             * @version 2.2.19\n             */\n\n            $node.scrollToRecord = this.scrollToRecord.bind(this);\n\n            /**\n             * @utility insertRow\n             * @version 2.2.19\n             */\n\n            $node.insertRow = this.insertRow.bind(this);\n        }\n\n        if( __data.ltPropNavigation ){\n            window._lyteUiUtils.tableNavigation( $node.getElementsByTagName( __tags.table )[ 0 ] );\n        }\n    }\n\n    // width calculation for positioning\n    columnWidth(fixedColumn, i, j) {\n\n        var width = 0;\n        j = j || 0;\n\n        for( ; j < i; j++ ){\n            width += fixedColumn[ j ].property.width;\n        }\n\n        return width;\n    }\n\n    heightCalc(rows, upper, hgtLimit) {\n        var hgt = 0, j = upper;\n        for( ; j > 0; j-- ){\n            hgt += rows[ j ];\n            if( hgtLimit < hgt ){\n                break;\n            }\n        }\n        return [ hgt, j ];\n    }\n\n    topElem(elem) {\n        var __final;\n\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            __final = elem.getElementsByTagName( this.data.ltPropTags.td )[ 0 ];\n        } else {\n            __final = elem;\n        }\n        return __final ? __final.getBoundingClientRect() : {};\n    }\n\n    cellSet(elem, value) {\n        var __elem;\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            __elem = Array.from( elem.getElementsByTagName( this.data.ltPropTags.td ) );\n        } else {\n           __elem = [ elem ];\n        }\n\n        if( value ){\n            __elem.forEach( function( item ){\n                item.style.transform = value;\n            });\n        }\n        return __elem[ 0 ].style.transform;\n    }\n\n    scrollTable(event, obj) {\n        // fastdom has been removed here due to delay causes error in calculation of data in ie edge safari\n        var b = event.yScroll, \n        __tags = this.data.ltPropTags,\n        ltPropData = this.getData('ltPropData'), \n        ltPropContent = this.getData('ltPropContent'), \n        scrollDiv = this.scrollDiv, \n        divClientRect = obj.tbodyClient, \n        tableClient = obj.$nodeClient, \n        table = this.$node.querySelector( __tags.table ),\n        head = this.$node.getElementsByTagName( __tags.th )[ 0 ], \n        neglected = obj.neglected, \n        compNeg = obj.compNeg;\n        head = head ? (head.property ? head.property.height : head.getBoundingClientRect().height) : 0;\n        var topElem = obj.topElem, \n        top1 = obj.topElemClient;\n\n        if (table.style.height.indexOf('px') == -1) {\n            table.style.height = divClientRect.height + 'px';\n            this._rowHgt = parseInt(top1.height * 10) / 10;\n            this._step = parseInt((divClientRect.height - this._rowHgt * neglected.length) * 10) / 10;\n        }\n        if( !this._dummy ){\n            this.createDummy( obj.tbody );\n        }\n        if (b == undefined && !scrollDiv.classList.contains('eventBinded')) {\n            var prevScroll = parseFloat(this._dummy.style.transform.match(/[\\d|.]+/ig)[0]),\n                currScroll = scrollDiv.scrollTop\n            if (currScroll > prevScroll) {\n                b = 1\n            } else {\n                b = -1\n            }\n        }\n\n        var __boundary = this._boundary,\n        __dummy = this._dummy.style,\n        __dummy1 = ( this._dummy1 || {} ).style,\n        __rowHgt = this._rowHgt;\n\n        if (b > 0) {\n            if (parseFloat(tableClient.top + head) >= parseFloat(top1.bottom)) {\n                if( __boundary.bottom <= ltPropContent.length - 2 ) {\n                    var diff = Math.max(parseInt((tableClient.top + head - top1.bottom) / __rowHgt ), 1);\n                    if( __boundary.bottom + diff > ltPropContent.length - 1) {\n                        diff = ltPropContent.length - 1 - __boundary.bottom\n                    }\n                    for (var i = 0; i < diff; i++) {\n                        __boundary.bottom += 1;\n                        if (i >= diff - ltPropData.length) {\n                            this.$component.set(ltPropData[this._top], { body: ltPropContent[__boundary.bottom], index: __boundary.bottom })\n                            topElem.dataOrder = __boundary.bottom;\n                        }\n                        __boundary.top = __boundary.bottom - ltPropData.length + 1;\n                        if (this.cellSet(topElem)) {\n                            this.regex(topElem)\n                        } else {\n                            this.cellSet(topElem, \"translateY(\" + (this._step) + 'px)')\n                        }\n                        __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\\d|.]+/ig)[0]) + __rowHgt ) + 'px)'\n                        __dummy.height = Math.max(parseFloat( __dummy.height) - __rowHgt, 0) + 'px';\n                        if (this._browser) {\n                            __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\\d|.]+/ig)[0]) + __rowHgt ) + 'px)'\n                        }\n                        this._bottom = this._top;\n                        this._top = (this._top + 1) % ltPropData.length;\n                        if ( __boundary.bottom >= ltPropContent.length) {\n                            __boundary.bottom = ltPropContent.length - 1;\n                            this._top = (this._top + 1) % ltPropData.length;\n                            break\n                        }\n                        topElem = this.nthoftype.call(this, obj.tbody, this._top + compNeg.length, true)\n                    }\n                } else {\n                    this.scrollEndMethod1();\n                }\n            }\n\n        } else if (b < 0) {\n            var bottmElem = obj.bottmElem, bottom = obj.bottmElemClient;\n            if (tableClient.bottom <= bottom.top) {\n                var mat = this.cellSet(bottmElem).match(/[\\d|.]+/ig);\n                if (!mat || (mat && mat[0] == '0')) {\n                    return\n                }\n                var diff = parseInt(Math.max(parseFloat((bottom.top - tableClient.bottom) / __rowHgt ), 0)),\n                    minDiff = Math.max(diff - 1 - this._boundary.top, 0)\n                for (var i = diff - 1; i >= 0 && diff != 0; i--) {\n                    if ( __boundary.top == 0) {\n                        break;\n                    }\n                    __boundary.top -= 1;\n                    if (i <= ltPropData.length - 1 + minDiff) {\n                        this.$component.set(ltPropData[this._bottom], { body: ltPropContent[ __boundary.top], index: __boundary.top })\n                        bottmElem.dataOrder = __boundary.top;\n                    }\n                    __boundary.bottom = __boundary.top + ltPropData.length - 1;\n                    if (this.cellSet(bottmElem)) {\n                        this.regex(bottmElem, true)\n                    }\n                    __dummy.height = (parseFloat( __dummy.height) + __rowHgt ) + 'px';\n                    __dummy.transform = 'translateY(' + (parseFloat( __dummy.transform.match(/[\\d|.]+/ig)[0]) - __rowHgt ) + 'px)'\n                    if (this._browser) {\n                        __dummy1.transform = 'translateY(' + (parseFloat( __dummy1.transform.match(/[\\d|.]+/ig)[0]) - __rowHgt ) + 'px)'\n                    }\n                    this._top = this._bottom;\n                    this._bottom = (ltPropData.length + this._bottom - 1) % ltPropData.length;\n                    if (__boundary.top == -1) {\n                        __boundary.top = 0;\n                        __boundary.bottom = __boundary.top + ltPropData.length - 1;\n                        break\n                    }\n                    bottmElem = this.nthoftype.call(this, obj.tbody, this._bottom + compNeg.length, true)\n                }\n            }\n        }\n    }\n\n    createDummy(tbody) {\n        var dummy = document.createElement( this.data.ltPropTags.tr );\n        dummy.classList.add('dummy');\n        tbody.appendChild(dummy)\n        dummy.setAttribute('style', 'transform:translateY(0px);height:0px')\n        this._dummy = dummy;\n        if (this._browser) {\n            var dummy1 = document.createElement('div');\n            dummy1.classList.add('dummy');\n            this.scrollDiv.appendChild(dummy1)\n            dummy1.setAttribute('style', 'transform:translateY(0px);height:5px')\n            this._dummy1 = dummy1;\n        }\n    }\n\n    regex(elem, flag) {\n        if( this.isIE11Lyte || this.isEdgeLyte ){\n            var cells = elem.getElementsByTagName( this.data.ltPropTags.td ),\n            __length = cells.length;\n\n            for( var i = 0; i < __length; i++ ){\n                this.regex1( cells[ i ], flag );\n            }\n        } else {\n            this.regex1( elem, flag );\n        }\n    }\n\n    regex1(elem, flag) {\n        var __style = elem.style,\n        __transform = __style.transform,\n        rgx = /[\\d|.]+/ig,\n        __step = this._step;\n\n        if( flag ) {\n            __style.transform = __transform.replace( rgx, function( arg ) { return Math.max( parseFloat( arg ) - __step, 0 ).toFixed( 3 ) });\n        } else {\n            __style.transform = __transform.replace( rgx, function( arg ) { return ( parseFloat( arg ) + __step ).toFixed( 3 ) });\n        }\n    }\n\n    scrollEndMethod1() {\n        if( this._stopScroll ) {\n            return\n        }\n        this._stopScroll = true;\n        if (this.getMethods('scrollEnd')) {\n            /**\n             * @method scrollEnd\n             * @version 1.0.0\n             */\n            this.appendAddData1(this.executeMethod('scrollEnd'))\n        }\n    }\n\n    appendAddData1(ret) {\n        if (ret) {\n            if (ret.then) {\n                Promise.resolve(ret).then(function (arg) {\n                    if (arg) {\n                        this.apd1.call(this, arg);\n                    }\n                }.bind(this), function () {\n                    console.log( 'error at scroll end promise' );\n                }.bind(this));\n            } else {\n                this.apd1.call(this, ret)\n            }\n        }\n    }\n\n    apd1(ret) {\n        var __data = this.data,\n        ltPropContent = __data.ltPropContent, \n        ltPropData = __data.ltPropData,\n        La = this.$addon.arrayUtils;\n\n        this._prevent = true\n        if( ret.constructor == Array ){\n            La( ltPropContent, 'concat', ret );\n        } else if( ret.constructor == Object ) {\n            La( ltPropContent, 'push', ret );\n        }\n        delete this._prevent;\n        delete this._stopScroll;\n    }\n\n    nthoftype(tbody, index, fg) {\n        var arr = [],\n        rows = tbody.getElementsByTagName( this.data.ltPropTags.tr );\n\n        if( fg ){\n            return rows[ index ];\n        }\n\n        var __length = rows.length;\n\n        for( var i = 0; i < __length; i++ ) {\n            var __cur = rows[ i ];\n            if( !__cur.classList.contains('dummy')) {\n                arr.push( this.get_children( __cur )[ index ] );\n            }\n        }\n        return arr;\n    }\n\n    scroll(event) {\n\n        // cant use fastdom because of jerk in ie edge safari browser\n        var component = this.comp,\n            // headerList =component.$node.querySelectorAll( 'lyte-th' ),\n            // scrollleft and top are required for process like fixing columns and infinite scroll. If scroll is dispatched by plugin event object contains these properties or it is calculated\n        obj = this._wheelObj || { bcr: {} };\n\n        if( component.__ignore_scroll && component.__allow_scroll !== true ){\n            return;\n        }\n\n        this._scrollLeft = obj.scrollLeft != undefined ? obj.scrollLeft : this.scrollLeft;\n        this._scrollTop = obj.scrollTop != undefined ? obj.scrollTop : this.scrollTop;\n        \n        var direction = this._direction,\n        __is_not_sticky = !component.data.ltPropStickyTable;\n\n        __is_not_sticky && component.scrollCheck.call(this, event, obj);\n\n        if (this._scrollLeft == 0 && direction != 'rtl' && component.getData('ltPropInfiniteScroll')) {\n            var ary = component.getData('columns');\n            component.$addon.arrayUtils(ary, 'remove', 0, ary.length);\n            \n            if( __is_not_sticky ){\n                var fixedd = this.getElementsByClassName( 'lyteTableFixed' ),\n                __length = fixedd.length;\n\n                for( var i = 0; i < __length; i++ ) {\n                    var __cur = fixedd[ i ];\n\n                    __cur.style.left = '0px';\n                    __cur.classList.remove('lyteTableFixed');\n                }\n            }\n        }\n        if (component.data.ltPropInfiniteScroll) {\n            component.scrollTable.call(component, event, obj)\n        }\n        delete this._scrollLeft; delete this._scrollTop;\n    }\n\n    // fixed column checks and removals\n    scrollCheck(event, obj) {\n        var component = this.parentElement.component,\n        __tags = component.data.ltPropTags,\n        table = this.getElementsByTagName( __tags.table )[0], scrollDiv = this,\n            scrollTop = this._scrollTop, scrollLeft = this._scrollLeft,\n            scrollDir = component.getData('ltPropScroll'),\n            direction = this._direction,\n            tbody = table.getElementsByTagName( __tags.tbody )[0],\n            thead = this.getElementsByTagName( __tags.thead )[0],\n            ths = [],\n            headerList = [],\n            fixedColumn = [];\n\n        if (thead) {\n            ths = thead.getElementsByTagName( __tags.th );\n        }\n\n        if ((scrollTop != this.prevScollTop || event._byFunc) && scrollDir.vertical) {\n            var colsNos = ths;\n            if (colsNos.length) {\n                for (var i = 0; i < colsNos.length; i++) {\n                    colsNos[i].classList.add('tableRowFixed')\n                    // colsNos[i].style.top = (scrollTop) + 'px';\n                    component.transform(true, colsNos[i], scrollTop)\n                }\n                if (!scrollTop) {\n                    for (var i = 0; i < colsNos.length; i++) {\n                        colsNos[i].classList.remove('tableRowFixed');\n                    }\n                }\n            }\n        }\n        // for horizontal scroll    \n        if ((scrollLeft != this.prevScollLeft || event._byFunc) && scrollDir.horizontal) {\n            var columns = component.data.columns, head = [];\n            if (thead) {\n                var headRows = Array.apply(Array, thead.getElementsByTagName( __tags.tr )),\n                    headRowCopy = Array.apply(Array, thead.getElementsByClassName('lyteRowCopy'));\n                head = headRows.concat(headRowCopy);\n            }\n\n            var ltPropFixedColumnClass = component.data.ltPropFixedColumnClass || '';\n            if (head.length) {\n                headerList = head[0].getElementsByTagName( __tags.th );\n                for (var n = 0; n < headerList.length; n++) {\n                    headerList[n].classList.contains('lyteFixedColumn') && fixedColumn.push(headerList[n]);\n                }\n            }\n            // fastdom removed due to jerk in ie edge chrome browser\n            for (var i = columns.length; i < fixedColumn.length; i++) {\n                if (((fixedColumn[i].property.right + component.columnWidth.call(component, fixedColumn, i) > (obj.scrollDivClient.right)) && direction == 'rtl') || ((fixedColumn[i].property.left < (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, i))) && direction != 'rtl')) {\n                    var width = fixedColumn[i].property.width\n                    var order = fixedColumn[i].order\n                    if (order + 1 < headerList.length) {\n                        !fixedColumn[i].classList.contains('lyteTableFixed') && fixedColumn[i].classList.add('lyteTableFixed')\n                        columns.push(fixedColumn[i])\n                        for (var zz = 1; zz < head.length; zz++) {\n                            var colex = head[zz].getElementsByTagName( __tags.th )[order];\n                            colex && !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed')\n                        }\n                        var colls = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')' )*/\n                        for (var k = 0; k < colls.length; k++) {\n                            !colls[k].classList.contains('lyteTableFixed') && colls[k].classList.add('lyteTableFixed')\n                            if (ltPropFixedColumnClass) {\n                                colls[k].classList.add(ltPropFixedColumnClass)\n                            }\n                        }\n                    }\n                }\n            }\n            for (var n = columns.length - 1; n >= 0; n--) {\n                var j = columns.length - 1;\n                if ((scrollLeft == 0 && !(window.chrome && direction == 'rtl')) || ((((parseFloat((headerList[columns[j].order + 1].property.right + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1)).toFixed(2)) <= parseFloat(obj.scrollDivClient.right.toFixed(2))) || (headerList[columns[j].order + 1].property.right + 2 < columns[j].property.left)) && direction == 'rtl') || ((headerList[columns[j].order + 1].property.left >= (obj.scrollDivClient.left + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1))) && (columns[j].property.left >= (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, columns.length - 1))) && direction != 'rtl'))) {\n                    // var innerElem = headerList[columns[j].order].querySelector( 'lyte-th-data' );\n                    headerList[columns[j].order].classList.contains('lyteTableFixed') && headerList[columns[j].order].classList.remove('lyteTableFixed');\n                    if (ltPropFixedColumnClass) {\n                        headerList[columns[j].order].classList.remove(ltPropFixedColumnClass)\n                    }\n                    // columns[j].style.removeProperty('left');\n                    component.transform(false, columns[j], 0)\n                    for (var zz = 0; zz < head.length; zz++) {\n                        var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];\n                        if (colex) {\n                            colex.classList.contains('lyteTableFixed') && colex.classList.remove('lyteTableFixed');\n                            // colex.style.removeProperty('left');\n                            component.transform(false, colex, 0)\n\n                        }\n                    }\n                    var currCols = /*component.isIE11Lyte ?*/ component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/;\n                    for (var z = 0; z < currCols.length; z++) {\n                        // currCols[z].style.removeProperty('left');\n                        component.transform(false, currCols[z], 0)\n                        currCols[z].classList.contains('lyteTableFixed') && currCols[z].classList.remove('lyteTableFixed')\n                        if (ltPropFixedColumnClass) {\n                            currCols[z].classList.remove(ltPropFixedColumnClass)\n                        }\n                    }\n                    component.$addon.arrayUtils(columns, 'removeAt', j)\n                }\n                else {\n                    break;\n                }\n            }\n            for (var j = 0; j < columns.length; j++) {\n                //positioning on scroll\n                var left, cells = /*component.isIE11Lyte ? */component.nthoftype.call(component, tbody, columns[j].order) /*: this.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')' )*/,\n                    uA = window.navigator.userAgent.toLowerCase();\n                if (j == 0) {\n                    if (direction == 'rtl') {\n                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {\n                            left = scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                        else if (uA.indexOf('edge') != -1 || uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1) {\n                            left = -scrollLeft + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                        else {\n                            left = scrollLeft - 1 - (obj.scrollWidth) + obj.scrollDivClient.width + (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                        }\n                    }\n                    else {\n                        left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))\n                    }\n                }\n                else {\n                    if (direction == 'rtl') {\n                        if (uA.indexOf('firefox') != -1 || (uA.indexOf('safari') != -1 && (window._lyteUiUtils.isNegativeScroll() || (!(uA.indexOf('chrome') != -1) && !(uA.indexOf('chromium') != -1))))) {\n                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)\n                        }\n                        else {\n                            left = /*parseInt(columns[j - 1].style.left)*/ component.transform(!1, columns[j - 1]) + component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1);\n                        }\n                    }\n                    else {\n                        left = component.transform(!1, columns[j - 1]) /*parseInt(columns[j - 1].style.left)*/ - component.columnWidth.call(component, headerList, columns[j].order, columns[j - 1].order + 1)\n                    }\n                }\n                for (var x = 0; x < cells.length; x++) {\n                    !cells[x].classList.contains('lyteTableFixed') && cells[x].classList.add('lyteTableFixed');\n                    //cells[x].style.left = left + 'px';\n                    component.transform(false, cells[x], left)\n                }\n                // columns[j].style.left = left + 'px';\n                component.transform(false, columns[j], left)\n                for (var zz = 0; zz < head.length; zz++) {\n                    var colex = head[zz].getElementsByTagName( __tags.th )[columns[j].order];\n                    if (colex) {\n                        !colex.classList.contains('lyteTableFixed') && colex.classList.add('lyteTableFixed');\n                        // colex.style.left = left + 'px';\n                        component.transform(false, colex, left)\n                    }\n                }\n            }\n        }\n        this.prevScollLeft = scrollLeft;\n        this.prevScollTop = scrollTop;\n    }\n\n    transform(flag, elem, value) {\n        var transform = (elem.style.transform || 'translateX(0px) translateY(0px)'),\n            transX = parseFloat(/translateX\\((.+)/.exec(transform)[1]),\n            transY = parseFloat(/translateY\\((.+)/.exec(transform)[1]);\n\n        if (value != undefined) {\n            if (!flag) {\n                elem.style.transform = \"translateY(\" + transY + 'px) ' + 'translateX(' + value + 'px)';\n            } else {\n                elem.style.transform = \"translateY(\" + value + 'px) ' + 'translateX(' + transX + 'px)';\n            }\n        } else {\n            return parseFloat(flag ? transY : transX);\n        }\n    }\n\n    borderChange() {\n        if (this.data.ltPropBorder) {\n            this.$node.classList.add('border');\n        }\n        else {\n            this.$node.classList.remove('border');\n        }\n    }\n\n    widthObs() {\n        this.$node.querySelector( this.data.ltPropTags.table ).style.width = this.data.ltPropWidth;\n    }\n\n    heightObs() {\n        this.$node.querySelector( this.data.ltPropTags.table ).style.height = this.data.ltPropHeight;\n    }\n\n    sortable() {\n        var row = this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];\n        if( row ){\n            var ns = \"remove\";\n\n            if( this.data.ltPropColumnSortable ){\n                this.colSort = this.sortableColumns.bind( this );\n                ns = \"add\";\n            }\n\n            if( ns ){\n                var rel = ns + \"EventListener\",\n                fn = this.colSort;\n\n                row[ rel ]( \"mousedown\", fn );\n                row[ rel ]( \"touchstart\", fn );\n                row.parentNode.classList[ ns ]( 'sortableTable' );\n            }\n        }\n    }\n\n    composePath(event) {\n        var arr = [], \n        __target = event.target,\n        node = __target.correspondingElement || __target;\n        while( node && node.tagName != 'HTML' ){\n            arr.push( node );\n            node = node.parentNode;\n        }\n        return arr;\n    }\n\n    sortableColumns(event) {\n        var __tags = this.data.ltPropTags,\n        target = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), __tags.th + ':not(.lyteTableFixed)');\n        if (target && this.$node.contains(target)) {\n            var ret, isTch = event.type == \"touchstart\";\n            if (this.getMethods('onBeforeSelect')) {\n                /**\n                 * @method onBeforeSelect\n                 * @version 1.0.3\n                 */\n                ret = this.executeMethod('onBeforeSelect', target, event, this.$node)\n            }\n            if (ret != false) {\n                var evt = isTch ? event.touches[0] : event\n                this._ww = window.innerWidth;\n                this.mousemove = this.sortableMouseMove.bind(this);\n                this.offLeft = this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.rtlfunc.call(this, 'left', target.getBoundingClientRect(), this._ww);\n                this.colHead = target;\n                this._thisBccr = this.$node.getBoundingClientRect()\n                target.classList.add('lyteStickyTableColumnSortSelect')\n                document.documentElement.addEventListener(isTch ? \"touchmove\" : 'mousemove', this.mousemove);\n                this.mouseup = this.sortableMouseup.bind(this);\n                document.documentElement.addEventListener(isTch ? \"touchend\" : 'mouseup', this.mouseup);\n                this.flag = true;\n                event.preventDefault();\n                if (this.getMethods('onSelect')) {\n                    /**\n                     * @method onSelect\n                     * @version 1.0.3\n                     */\n                    this.executeMethod('onSelect', target, event, this.$node)\n                }\n            }\n        }\n    }\n\n    horiScroll(dummyDiv, ww) {\n        var lt = this.rtlfunc.call(this, 'left'), IE = this.isIE11Lyte || this.isEdgeLyte,\n            isEvt, check1, check2;\n        if (/mousemove|touchmove/i.test(dummyDiv.type)) {\n            isEvt = true;\n        }\n        if (isEvt) {\n            if (this._reqId) {\n                return;\n            }\n\n            var __bcr = this.__bcr;\n\n            check1 = this.rtlfunc( 'clientX', dummyDiv, ww ) > Math.min( this.rtlfunc( 'right', __bcr, ww), ww - 2 );\n            check2 = this.rtlfunc( 'clientX', dummyDiv, ww ) <= Math.max( 0, this.rtlfunc('left', __bcr, window.innerWidth ) );\n        } else {\n            check1 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;\n            check2 = (parseFloat(dummyDiv.style[lt]) - this._xxoff + parseFloat(dummyDiv.style.width)) >= this.rtlfunc('right', this._thisBccr, ww) - 1;\n        }\n\n        if (check1) {\n            this.scrollDiv.scrollLeft += 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)\n            if (isEvt) {\n                var __value = 2 * ( this._dir ? -1 : 1 );\n                this.__clientX -= __value;\n\n                if( this.data.ltPropFixResizeCursor ){\n                    this.__trans_value += __value\n                }\n            }\n            this._reqId = window.requestAnimationFrame(function () {\n                delete this._reqId;\n                this.horiScroll(dummyDiv, ww)\n            }.bind(this))\n        } else if (check2) {\n            if (isEvt) {\n                var __value =  2 * ( this._dir ? -1 : 1 );\n                this.__clientX += __value;\n                \n                if( this.data.ltPropFixResizeCursor ){\n                    this.__trans_value -= __value\n                }\n            }\n            this.scrollDiv.scrollLeft -= 2 * (this._dir ? (-1 * (IE ? -1 : 1)) : 1)\n            this._reqId = window.requestAnimationFrame(function () {\n                delete this._reqId;\n                this.horiScroll(dummyDiv, ww);\n            }.bind(this))\n        } else {\n            window.cancelAnimationFrame(this._reqId);\n            delete this._prevent;\n        }\n    }\n\n    sortableMouseMove(event) {\n        var isTch = event.type == \"touchmove\", evt = event;\n        if (isTch && evt.touches.length != 1) {\n            return\n        } else if (isTch) {\n            evt = evt.touches[0]\n        }\n        if (this.flag && this._timeout == undefined) {\n            var target = this.colHead, xscroll;\n            var clientRect = target.getBoundingClientRect();\n            var div = document.createElement('div');\n            div.classList.add('lyteTableSortHelper');\n            div.innerText = this.colHead.innerText;\n            this._xxoff = xscroll = (window.pageXOffset || document.documentElement.scrollLeft) * (this._dir ? -1 : 1);\n            var yscroll = window.pageYOffset || document.documentElement.scrollTop\n            div.style.height = clientRect.height + 'px';\n            div.style.width = clientRect.width + 'px';\n            div.style[this.rtlfunc.call(this, 'left')] = (xscroll + this.rtlfunc.call(this, 'left', clientRect, this._ww)) + 'px';\n            div.style.top = (yscroll + clientRect.top) + 'px';\n            this._timeout = setTimeout(function () {\n                window._lyteUiUtils.appendChild( document.body, div );\n                this.flag = false;\n            }.bind(this), 100)\n        }\n        var dummyDiv = document.querySelector('div.lyteTableSortHelper')\n        if (dummyDiv) {\n            var lft = this._dir ? \"right\" : \"left\", ww = window.innerWidth;\n            var newLeft = Math.max(Math.min((this.rtlfunc.call(this, 'clientX', evt, this._ww) - this.offLeft), this.rtlfunc.call(this, 'right', this._thisBccr, this._ww) - parseFloat(dummyDiv.style.width)), this.rtlfunc.call(this, 'left', this._thisBccr, this._ww));\n            // if( ( newLeft > parseFloat( dummyDiv.style[ lft ] - this._xxoff ) ) || ( newLeft < parseFloat( dummyDiv.style[ lft ] ) - this._xxoff ) ){\n            if ((parseFloat(newLeft) > this.rtlfunc('left', this._thisBccr, ww)) && ((parseFloat(newLeft) + parseFloat(dummyDiv.style.width)) < this.rtlfunc('right', this._thisBccr, ww))) {\n                window.cancelAnimationFrame(this._reqId);\n                delete this._prevent; delete this._scrollDir\n            }\n            if (this._prevent) {\n                return\n            }\n            dummyDiv.style[lft] = (newLeft + this._xxoff) + 'px';\n            this._prevent = true\n            this.horiScroll(dummyDiv, ww)\n            if (this.getMethods('onDrag')) {\n                /**\n                 * @method onDrag\n                 * @version 1.0.3\n                 */\n                this.executeMethod('onDrag', this.colHead, dummyDiv, event, this.$node)\n            }\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    sortableMouseup(event) {\n        if (!this.flag) {\n            var __tags = this.data.ltPropTags,\n            isTch = event.type == \"touchend\", dummyDiv = document.getElementsByClassName('lyteTableSortHelper')[0], clientRect = dummyDiv.getBoundingClientRect(), x = clientRect.left + clientRect.width / 2 + 2, y = clientRect.top + clientRect.height / 2,\n                adjCol = this.closestFind.call(this, document.elementsFromPoint ? document.elementsFromPoint(x, y) : this.elementsFromPointCal.call(this, x, y), __tags.th + ':not(.lyteTableFixed)'),\n                tbody = this.$node.getElementsByTagName( __tags.tbody )[0];\n            if (adjCol != this.colHead && adjCol) {\n                var Heads = this.colHead.parentElement.getElementsByTagName( __tags.th ),\n                    colOrder = Array.prototype.indexOf.call(Heads, this.colHead),\n                    adjOrder = Array.prototype.indexOf.call(Heads, adjCol),\n                    ltPropHeader = this.data.ltPropHeader, ret;\n                if (this.getMethods('onBeforeDrop')) {\n                    /**\n                     * @method onBeforeDrop\n                     * @version 1.0.3\n                     */\n                    ret = this.executeMethod('onBeforeDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)\n                }\n                if (ret != false) {\n                    if (!ltPropHeader.length) {\n                        window._lyteUiUtils.insertBefore(adjOrder > colOrder ? adjCol.nextElementSibling : adjCol, this.colHead);\n                        var colGrp = /*this.isIE11Lyte ? */this.nthoftype.call(this, tbody, colOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( colOrder + 1) +')' )*/;\n                        var AdjColGrp = /*this.isIE11Lyte ?*/ this.nthoftype.call(this, tbody, adjOrder) /*: this.$node.querySelectorAll( 'lyte-tbody lyte-td:nth-of-type(' + ( adjOrder + 1) +')' )*/;\n                        for (var i = 0; i < colGrp.length; i++) {\n                            window._lyteUiUtils.insertBefore(adjOrder > colOrder ? AdjColGrp[i].nextElementSibling : AdjColGrp[i], colGrp[i]);\n                        }\n                    }\n                    else {\n                        var flag = adjOrder > colOrder ? true : false;\n                        var temp = this.$addon.arrayUtils(ltPropHeader, 'removeAt', colOrder), newOrder = Array.prototype.indexOf.call(adjCol.parentElement.getElementsByTagName( __tags.th ), adjCol);\n                        this.$addon.arrayUtils(ltPropHeader, 'insertAt', colOrder < adjOrder ? (newOrder + 1) : newOrder, temp);\n                        var newCol = adjCol.parentElement.getElementsByTagName( __tags.th, adjCol.parentElement)[colOrder < adjOrder ? (newOrder + 1) : newOrder];\n                        if (adjCol.classList.contains('tableRowFixed')) {\n                            newCol.classList.add('tableRowFixed');\n                            newCol.style.top = adjCol.style.top;\n                        }\n                    }\n                    if (this.getMethods('onDrop')) {\n                        /**\n                         * @method onDrop\n                         * @version 1.0.3\n                         */\n                        this.executeMethod('onDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node)\n                    }\n                }\n            } else {\n                this.getMethods( 'onRelease' ) && this.executeMethod( 'onRelease', this.colHead, event, this.$node );\n            }\n            document.body.removeChild(dummyDiv);\n        } else {\n            clearTimeout(this._timeout)\n        }\n        document.documentElement.removeEventListener(isTch ? \"touchend\" : 'mouseup', this.mouseup);\n        document.documentElement.removeEventListener(isTch ? \"touchmove\" : 'mousemove', this.mousemove);\n        this.colHead.classList.remove('lyteStickyTableColumnSortSelect')\n        window.cancelAnimationFrame(this._reqId)\n        delete this.mouseup; delete this._xxoff;\n        delete this.mousemove;\n        delete this.offLeft;\n        delete this.colHead;\n        delete this.flag;\n        delete this._timeout;\n        delete this._thisBccr; delete this._ww;\n        delete this._reqId; delete this._prevent; delete this._scrollDir\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n    }\n\n    elementsFromPointCal(x, y) {\n        var arr = [], element = document.elementFromPoint(x, y);\n        while (element != document && element != document.documentElement && element != document.body && element != this.$node) {\n            element.style.pointerEvents = 'none';\n            arr.push(element);\n            element = document.elementFromPoint(x, y);\n        }\n        for (var i = 0; i < arr.length; i++) {\n            arr[i].style.pointerEvents = 'initial';\n        }\n        return arr;\n    }\n\n    // resizeComponentAppendObs: function () {\n    //     if (this.data.ltPropYield) {\n    //         this.resizeComponentAppend.call(this);\n    //     }\n    // }.observes('ltPropResize', 'ltPropResize.{}'),\n\n    // resizeComponentAppend: function () {\n    //     var ltPropResize = this.data.ltPropResize, scrdiv = this.$node.getElementsByTagName('lyte-table-structure')[0],\n    //         tRz = scrdiv.getElementsByTagName('lyte-table-resize')[0], vrz = scrdiv.getElementsByTagName('lyte-table-vertical-resize')[0],\n    //         hrz = scrdiv.getElementsByTagName('lyte-table-horizontal-resize')[0];\n    //     if (ltPropResize.vertical || ltPropResize.horizontal) {\n    //         if (!tRz) {\n    //             var comp = document.createElement('lyte-table-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this));\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     } else if (tRz) {\n    //         scrdiv.removeChild(tRz)\n    //     }\n    //     if (ltPropResize.vertical) {\n    //         if (!vrz) {\n    //             var comp = document.createElement('lyte-table-vertical-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     }\n    //     else if (vrz) {\n    //         scrdiv.removeChild(vrz)\n    //     }\n    //     if (ltPropResize.horizontal) {\n    //         if (!hrz) {\n    //             var comp = document.createElement('lyte-table-horizontal-resize')\n    //             scrdiv.appendChild(comp)\n    //             comp.addEventListener('mousedown', this.actions.tableResize.bind(this))\n    //             comp.addEventListener('touchstart', this.actions.tableResize.bind(this));\n    //         }\n    //     }\n    //     else if (hrz) {\n    //         scrdiv.removeChild(hrz)\n    //     }\n    // },\n\n    data() {\n        \n        var default_values = window._lyteUiUtils.getDefault( 'lyte-table' );\n\n        return {\n            //user data\n            /**\n             * @componentProperty {object[]} ltPropContent\n             * @version 1.0.0\n             * @default []\n             */\n            ltPropContent: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {object[]} ltPropHeader\n             * @version 1.0.0\n             * @default []\n             */\n            ltPropHeader: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {string} ltPropId=''\n             * @version 1.0.0\n             */\n            ltPropId: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropClass=''\n             * @version 1.0.0\n             */\n            ltPropClass: prop(\"string\", { \"default\": default_values.class || '' }),\n            /**\n             * @componentProperty {boolean} ltPropBorder=false\n             * @version 1.0.0\n             */\n            ltPropBorder: prop(\"boolean\", { \"default\": default_values.border || false }),\n            /**\n             * @componentProperty {string} ltPropHeaderLabelKey=''\n             * @version 1.0.0\n             */\n            ltPropHeaderLabelKey: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropBodyLabelKey=''\n             * @version 1.0.0\n             */\n            ltPropBodyLabelKey: prop(\"string\", { \"default\": '' }),\n            /**\n             * @componentProperty {string} ltPropWidth=100%\n             * @version 1.0.0\n             */\n            ltPropWidth: prop('string', { 'default': default_values.width || '100%' }),\n            /**\n             * @componentProperty {string} ltPropHeight=100%\n             * @version 1.0.0\n             */\n            ltPropHeight: prop('string', { 'default': default_values.height || '100%' }),\n            /**\n             * @typedef {object} tableResize\n             * @property {boolean} horizontal\n             * @property {boolean} vertical\n             */\n\n            /**\n             * @componentProperty {tableResize} ltPropResize\n             * @version 1.0.0\n             * @default {}\n             */\n            ltPropResize: prop('object', { 'default': default_values.resize || {} }),\n            /**\n             * @componentProperty {string} ltPropFixedColumnClass=''\n             * @version 1.0.0\n             */\n            ltPropFixedColumnClass: prop('string', { 'default': default_values.fixedColumnClass || '' }),\n            /**\n             * @componentProperty {boolean} ltPropYield=false\n             * @version 1.0.0\n             */\n            ltPropYield: prop('boolean', { 'default': default_values.yield || false }),\n            /**\n             * @typedef {object} tableScroll\n             * @property {boolean} horizontal=true\n             * @property {boolean} vertical=true\n             */\n            /**\n             * @componentProperty {tableScroll} ltPropScroll\n             * @default {\"horizontal\":true,\"vertical\":true}\n             */\n            ltPropScroll: prop('object', { 'default': default_values.scroll || { horizontal: true, vertical: true } }),\n            /**\n             * @componentProperty {boolean} ltPropColumnSortable=false\n             * @version 1.0.0\n             */\n            ltPropColumnSortable: prop('boolean', { 'default': default_values.columnSortable || false }),\n            /**\n             * @typedef {object} tableScrollbar\n             * @property {left | right} verticalPosition=left\n             * @property {top | bottom} horizontalPosition=bottom\n             * @property {string} containerClass\n             * @property {string} handlerClass\n             * @property {string} horizontalContainerClass\n             * @property {string} horizontalHandlerClass\n             * @property {string} verticalContainerClass\n             * @property {string} verticalHandlerClass\n             * @property {boolean} preventVertical\n             * @property {boolean} preventHorizontal\n             * @property {number} keyStep=30\n             * @property {hover | always | scroll} showOn=scroll\n             * @property {number} wheelSpeed=1\n             * @property {boolean} preventOnEnd=true\n             * @property {object} offset={\"x\":0,\"y\":0}\n             * @property {boolean} nested\n             * @property {number} max=Infinity\n             * @property {number} min=-Infinity\n             */\n            /**\n             * @componentProperty {tableScrollbar} ltPropScrollbarOption\n             * @version 1.0.0\n             * @default {}\n             */\n            ltPropScrollbarOption: prop('object', { 'default': default_values.scrollbarOption || {} }),\n            /**\n             * @componentProperty {boolean} ltPropDualResize=false\n             * @version 1.0.5\n             */\n            ltPropDualResize: prop('boolean', { default: default_values.dualResize || false }),\n\n            // scroll table test data\n            /**\n             * @experimental ltPropData\n             */\n            ltPropData: prop(\"array\", { \"default\": [] }),\n            /**\n             * @componentProperty {boolean} ltPropInfiniteScroll=false\n             * @version 1.0.0\n             */\n            ltPropInfiniteScroll: prop('boolean', { 'default': default_values.infiniteScroll || false }),\n            /**\n             * @componentProperty {string} ltPropCellHeight=20px\n             * @version 1.0.2\n             */\n            ltPropCellHeight: prop('string', { default: default_values.cellHeight || '20px' }),\n            /**\n             * @componentProperty {number} ltPropContentLength\n             * @version 1.0.2\n             */\n            ltPropContentLength: prop('number', { default_values : default_values.contentLength || void 0 }),\n            /**\n             * @componentProperty {boolean} ltPropPreventScrollbar=false\n             * @version 1.0.0\n             */\n            ltPropPreventScrollbar: prop('boolean', { default: default_values.preventScrollbar || false }),\n\n            /**\n             * @componentProperty {string} ltPropRole=\"\"\n             * @version 3.45.0\n             */\n\n            ltPropRole : prop( 'string', { default : default_values.role || \"\" } ),\n\n            // sticky table props\n            /**\n             * @componentProperty {boolean} ltPropStickyTable=false\n             * @version 3.53.0\n             */\n            ltPropStickyTable : prop( 'boolean', { default : default_values.stickyTable || false } ),\n            /**\n             * @componentProperty {number} ltPropScrollStep=2\n             * @version 3.53.0\n             */\n            ltPropScrollStep : prop( 'number', { default : default_values.scrollStep || 2 } ),\n            /**\n             * @componentProperty {boolean} ltPropPreventTableModify=true\n             * @version 3.53.0\n             */\n            ltPropPreventTableModify : prop( 'boolean', { default : default_values.preventTableModify == false ? false : true } ),\n            /**\n             * @componentProperty {string} ltPropSortDummyColumClass=\"\"\n             * @version 3.53.0\n             */\n            ltPropSortDummyColumClass : prop( 'string', { default : default_values.sortDummyColumnClass || \"\" } ),\n\n            /**\n             * @componentProperty {boolean} ltPropNavigation=false\n             * @version 3.51.2\n             */\n            ltPropNavigation : prop( 'boolean', { default : default_values.navigation || false } ),\n\n            /**\n             * @componentProperty {boolean} ltPropReset=false\n             * @version 3.53.0\n             */\n\n            ltPropReset : prop( 'boolean', { default : false } ),\n            /**\n             * @typedef {object} tableTags\n             * @property {string} table=\"lyte-table-structure\"\n             * @property {string} thead=\"lyte-thead\"\n             * @property {string} tbody=\"lyte-tbody\"\n             * @property {string} tr=\"lyte-tr\"\n             * @property {string} td=\"lyte-td\"\n             * @property {string} th=\"lyte-th\"\n             */\n\n            /**\n             * @componentProperty {tableTags} ltPropTags\n             * @version 3.91.0 \n             */\n\n            ltPropTags : prop( 'object', { default : default_values.tags || { table : \"lyte-table-structure\", thead : \"lyte-thead\", tbody : \"lyte-tbody\", td : \"lyte-td\", th : \"lyte-th\", tr : \"lyte-tr\" } } ),\n\n            ltPropSortable : prop( 'boolean' , { default : default_values.sortable || false }),\n\n            ltPropContainment : prop('string' , { default : default_values.containment || '' }),\n\n            lyteUnbound: prop('boolean', { default: false }),\n\n            ltPropFromListview : prop('boolean' , {default : false} ),\n\n            /**\n             * @componentProperty {boolean} ltPropFixResizeCursor=false\n             * @version 3.95.0\n             */\n\n            ltPropFixResizeCursor : prop( 'boolean', { default : default_values.fixResizeCursor || false } ),\n\n            // system data\n            columns: prop('array', { 'default': [] }),\n            nonFixedColumn: prop('array', { 'default': [] }),\n            minWidth1: prop('string', { 'default': '' }),\n            minWidth2: prop('string', { 'default': '' }),\n            secondaryData: prop('array', { 'default': [] }),\n            boundary: prop('object', { 'default': {} }),\n            rowHeights: prop('array', { 'default': [] }),\n            fromListView : prop( 'boolean', { default : false } )\n        };\n    }\n\n    resize_fun(evt) {\n        var isTch = evt.type == \"touchstart\",\n        __evt = evt,\n        touches = evt.touches;\n\n        if( isTch ){\n            if( touches.length > 1 ){\n                return;\n            }\n            __evt = touches[ 0 ];\n        }\n\n        evt.preventDefault();\n\n        var __this = this,\n        __bcr = __this.__bcr,\n        __elem = __this.__elem,\n        x_inc = ( __this.__clientX - ( __this.__clientX = __evt.clientX ) ) * ( __this._dir ? -1 : 1 ),\n        y_inc = __this.__clientY - ( __this.__clientY = __evt.clientY ),\n        original_x_inc = x_inc,\n        __min1 = __this.__min1,\n        __min2 = __this.__min2,\n        __max1 = __this.__max1,\n        __max2 = __this.__max2,\n        __width = parseFloat( __elem.style.width ),\n        new_width = __width - x_inc,\n        new_height,\n        __next = __elem.nextElementSibling,\n        new_width2,\n        cb = \"onResizeMove\",\n        table = __this.__table,\n        __resize = __this.data.ltPropResize,\n        __dir = __this.__dir,\n        is_hgt_modify = /vert|both/i.test( __dir || '' ),\n        $node = $L( __this.$node );\n\n        if( __dir ){\n            if( !__resize.horizontal ){\n                x_inc = 0;\n            }\n\n            if( !__resize.vertical ){\n                y_inc = 0;\n            }\n        }\n\n        if( __max1 && new_width > __max1 ){\n            x_inc = __max1 - __width;\n        } else if( __min1 && new_width < __min1 ){\n            x_inc = __width - __min1;\n        }\n\n        if( !is_hgt_modify && __min2 != void 0 ){\n            var __width2 = parseFloat( __next.style.width ),\n\n            new_width2 = __width2 + x_inc;\n\n            if( __max2 && new_width2 > __max2 ){\n                x_inc = __width2 - __max2;\n            } else if( __min2 && new_width2 < __min2 ){\n                x_inc = __min2 - __width2;\n            }\n\n            new_width2 = __width2 + x_inc;\n        } else {\n            __next = void 0;\n        }\n\n        if( is_hgt_modify ){\n            var __height = parseFloat( __elem.style.height );\n            new_height = __height - y_inc;\n\n            if( __max2 && new_height > __max2 ){\n                y_inc = __max1 - __height;\n            } else if( __min2 && new_height < __min2 ){\n                y_inc = __height - __min2;\n            }\n\n            new_height = __height - y_inc;\n        }\n\n        if( original_x_inc && __this.data.ltPropFixResizeCursor && /lyte-th/i.test( __elem.tagName ) ){\n            var __diff = original_x_inc - x_inc,\n            trans_value = __this.__trans_value;\n\n            if( __diff ){\n                __this.__trans_value += __diff;\n            } else if( trans_value ) {\n                if( ( trans_value > 0 && x_inc < 0 ) || ( trans_value < 0 &&  x_inc > 0 ) ){\n                    if( __next ){\n                        new_width2 -= x_inc;\n                    }\n\n                    if( Math.abs( trans_value ) < Math.abs( x_inc ) ){\n                        x_inc += trans_value;\n                        __this.__trans_value = 0;\n                    } else {\n                        __this.__trans_value += x_inc;\n                        x_inc = 0;\n                    }\n                }\n            }\n        }\n\n        new_width = __width - x_inc;\n\n        if( table ){\n           $L( table ).css( 'width', ( parseFloat( table.style.width ) - x_inc ) + 'px' );\n\n        } \n\n        $L( __elem ).css( 'width', new_width + 'px' );\n        __next && $L( __next ).css( 'width', new_width2 + 'px' );\n\n        if( __dir ){\n            var ret = $node.css( 'maxWidth', new_width + 'px' );\n            if( new_height ){\n                ret.css( 'maxHeight', new_height + 'px' );\n                $L( __elem ).css( 'height', new_height + 'px' );\n            }\n        }\n\n        window.cancelAnimationFrame( __this._reqId );\n        delete __this._reqId;\n\n        __this.horiScroll( evt, __this.__ww );\n\n        __this.data.ltPropStickyTable && __this._setLeftForInterSection();\n\n        __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node );\n    }\n\n    resize_up(evt) {\n        var isTch = evt.touches,\n        __doc = document,\n        __fn = 'removeEventListener',\n        cb = 'onResizeEnd',\n        __elem = this.__elem;\n\n        __doc[ __fn ]( isTch ? 'touchmove' : 'mousemove', this.__mmove, true );\n        __doc[ __fn ]( isTch ? 'touchend' : 'mouseup', this.__mup, true );\n\n        [ '__dir', '__ww', '__min2', '__min1', '__max1', '__max2', '__clientX', '__clientY', '__elem', '__bcr', '__table' ].forEach( function( item ){\n            delete this[ item ];\n        }.bind( this ) );\n\n        $L( this.$node ).removeClass( 'resizing lyteTableResizing' );\n        $L( __elem ).removeClass( 'resizeSelect lyteTableResizeSelect' );\n\n        this.clearfdm();\n\n        /**\n         * @method onResizeEnd\n         * @version 1.0.3\n         */\n\n        this.getMethods( cb ) && this.executeMethod( cb, __elem, this.$node, evt );\n    }\n\n    static actions() {\n        return {\n\n            tableResize : function( evt, from ){\n                var isTch = evt.type == \"touchstart\",\n                __evt = evt,\n                touches = evt.touches;\n\n                if( isTch ){\n                    if( touches.length > 1 ){\n                        return\n                    }\n                    __evt = touches[ 0 ];\n                }\n\n                var  __this = this,\n                __data = __this.data,\n                __tags = __data.ltPropTags,\n                table = __this.$node.getElementsByTagName( __tags.table )[ 0 ],\n                __elem = from ? table : evt.target.parentNode,\n                cb = \"onBeforeResizeSelect\";\n\n                if( __this.getMethods( cb ) && __this.executeMethod( cb, __elem, evt, __this.$node ) == false ){\n                    return;\n                }\n\n                var tag = __elem.tagName,\n                is_dual = __data.ltPropDualResize,\n                fastdom = $L.fastdom,\n                __maxwidth = table.style.maxWidth,\n                __minWidth = table.style.minWidth,\n                __maxheight = table.style.maxHeight,\n                __layout = table.style.tableLayout,\n                $table = $L( table ),\n                __width = __elem.offsetWidth,\n                is_cell = tag.toLowerCase() == __tags.th,\n                nextelem = is_cell ? __elem.nextElementSibling : void 0,\n                __next_width = nextelem ? nextelem.offsetWidth : 0,\n                table_width = table.offsetWidth,\n                scroll_elem = __this.scrollDiv,\n                sL = scroll_elem.scrollLeft,\n                is_vert = /vert|both/i.test( from || '' ),\n                table_height = is_vert ? ( table.offsetHeight + 'px' ): table.style.height,\n                $$node = $L( __this.$node ),\n                table_style = window.getComputedStyle( table ),\n                is_fixed = table_style.tableLayout == \"fixed\",\n                read_value = table_style.getPropertyValue( 'max-width' ),\n                max_width_read = is_cell || (  /px/i.test( read_value ) ? parseFloat( read_value ) : Infinity );\n\n                __this.__ignore_scroll = true;\n\n                __this.__bcr = __this.$node.getBoundingClientRect();\n                __this.__ww = window.innerWidth;\n                __this.__dir = from;\n\n                __this.__trans_value = 0;\n\n                if( is_cell && /%|px/i.test( table_style.minWidth ) ){\n                    var __arr = [];\n\n                    Array.from( __this.get_children( __elem.parentNode ) ).forEach( function( item ){\n                        __arr.push({\n                            node : item,\n                            width : item.style.width || ( item.offsetWidth + 'px' )\n                        });\n                    });\n\n                    __arr.forEach( function( item ){\n                        item.node.style.width = item.width;\n                    });\n                }\n\n                $table.css( {\n                    maxWidth :  '0px',\n                    tableLayout : \"auto\",\n                    minWidth : \"auto\"\n                });\n\n                if( is_vert ){\n                    $table.css( 'maxHeight', '0px' );\n                }\n\n                $$node.addClass( 'lyteTableInitialResize' );\n\n                __this.__fd1 = fastdom.measure( function(){\n                    var __style = window.getComputedStyle( __elem ),\n                    actual_min = parseFloat( __style.getPropertyValue( 'min-width' ) ),\n                    minWidth1 = Math.min( __width, Math.max( __elem.offsetWidth, actual_min ) ),\n                    maxWidth1 = is_cell ? parseFloat( __style.getPropertyValue( 'max-width' ) ) : max_width_read,\n                    minWidth2,\n                    maxWidth2;\n\n                    if( minWidth1 == 0 ){\n                        minWidth1 = 50;\n                    }\n\n                    if( is_cell && is_fixed ){\n                        minWidth1 = Math.min( minWidth1, actual_min );\n                    }\n\n                    if( maxWidth1 < minWidth1 ){\n                        maxWidth1 = minWidth1;\n                    }\n\n                    if( is_cell ){\n                        if( !is_dual ){\n                            if( nextelem ){\n                                var next_style = window.getComputedStyle( nextelem ),\n                                actual_min_next = parseFloat( next_style.getPropertyValue( 'min-width' ) );\n\n                                minWidth2 = Math.min( __next_width, Math.max( nextelem.offsetWidth, actual_min_next ) );\n                                maxWidth2 = parseFloat( next_style.getPropertyValue( 'max-width' ) );\n\n                                if( minWidth2 == 0 ){\n                                    minWidth2 = 50;\n                                }\n\n                                if( is_fixed ){\n                                    minWidth2 = Math.min( minWidth2, actual_min_next );\n                                }\n\n                                if( maxWidth2 < minWidth2 ){\n                                    maxWidth2 = minWidth2;\n                                }\n                            }\n                        } else {\n                            __this.__table = table;\n                        }\n                    } else if( is_vert ){\n                        maxWidth2 = parseFloat( __style.getPropertyValue( 'max-height' ) );\n                        minWidth2 = parseFloat( __style.getPropertyValue( 'min-height' ) );\n                    }\n\n                    __this.__fd2 = fastdom.mutate( function(){\n                        __this.__min1 = minWidth1;\n                        __this.__min2 = minWidth2;\n                        __this.__max1 = maxWidth1;\n                        __this.__max2 = maxWidth2;\n\n                        __this.__clientX = __evt.clientX;\n                        __this.__clientY = __evt.clientY;\n\n                        __this.__elem = __elem;\n\n                        $table.css( {\n                            maxWidth : __maxwidth,\n                            width : table_width + 'px',\n                            maxHeight : __maxheight,\n                            height : table_height,\n                            tableLayout : __layout,\n                            minWidth : __minWidth\n                        });\n\n                        $L( __elem ).addClass( 'resizeSelect lyteTableResizeSelect' ).css( 'width', __width + 'px' );\n                        nextelem && $L( nextelem ).css( 'width', __next_width + 'px' );\n\n                        delete __this.__ignore_scroll;\n                        scroll_elem.scrollLeft = sL;\n\n                        var __doc = document,\n                        __fn = \"addEventListener\";\n\n                        __doc[ __fn ]( isTch ? 'touchmove' : \"mousemove\", __this.__mmove = __this.resize_fun.bind( __this ), true );\n                        __doc[ __fn ]( isTch ? 'touchend' : \"mouseup\", __this.__mup = __this.resize_up.bind( __this ), true );\n\n                        $$node.addClass( 'resizing lyteTableResizing' ).removeClass( 'lyteTableInitialResize' );\n\n                        __this.getMethods( cb = \"onResizeSelect\" ) && __this.executeMethod( cb, __elem, evt, __this.$node );\n                    });\n                });\n\n\n                evt.preventDefault();\n                evt.stopPropagation();\n                evt.stopImmediatePropagation();\n            },\n\n            rowMouseDown : function( evt ){\n                if( this.data.ltPropSortable && (evt.button == 0 || (evt.touches && evt.touches.length==1) ) ){      \n                        this.rowMouseDown( evt );\n                }\n            }\n            \n        };\n    }\n\n    clearfdm() {\n        var __fastdom = $L.fastdom;\n\n        [ '__fd1', '__fd2' ].forEach( function( item ){\n            var __cur = this[ item ];\n\n            if( __cur ){\n                __fastdom.clear( __cur );\n                delete this[ item ];\n            }\n        }.bind( this ) );\n    }\n\n    arrayFrom(nodeList) {\n        if (Array.from) {\n            return Array.from(nodeList)\n        }\n        return Array.apply(Array, nodeList);\n    }\n\n    closestFind(path, query) {\n        var elements = this.arrayFrom.call(this, document.querySelectorAll(query));\n        for (var i = 0; i < path.length; i++) {\n            if (Array.prototype.indexOf.call(elements, path[i]) != -1) {\n                return path[i];\n            }\n        }\n        return null;\n    }\n\n    findDomIndex(order) {\n        var data = this.data.ltPropData;\n        for (var i = 0; i < data.length; i++) {\n            if (data[i].index == order) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    insertRow(index, insertData) {\n        var boundary = this._boundary,\n            top = boundary.top,\n            bottom = boundary.bottom,\n            content = this.data.ltPropContent,\n            data = this.data.ltPropData,\n            _contentLength = this.data.ltPropContentLength;\n\n        this._prevent = true;\n\n        this.$addon.arrayUtils(content, 'insertAt', index, insertData);\n\n        if (index <= bottom) {\n            var start = Math.max(top, index);\n\n            for (var i = start; i <= bottom; i++) {\n                var domIndex = this.findDomIndex(i);\n                this.$component.set(data[domIndex], { index: data[domIndex].index, body: content[i] });\n            }\n        }\n\n        if( this.data.ltPropContentLength > content.length || this.data.ltPropContentLength > data.length ) {\n            var _length = data.length;\n\n            this.$addon.arrayUtils( data, 'push', {\n                index : _length,\n                body : content[ _length ],\n                checked : false\n            });\n\n            boundary.bottom++;\n            this._bottom++;\n\n            if( this._rowHgt ){\n                this._step = this._rowHgt * data.length;\n            }\n        }\n\n        delete this._prevent;\n    }\n\n    removeRow(dataIndex) {\n        var tags = this.data.ltPropTags,\n        rows = this.arrayFrom($L( tags.tbody + ' ' + tags.tr + ':not(.dummy)', this.$node));\n\n        if (dataIndex.constructor != Number) {\n            dataIndex = dataIndex.dataOrder || rows.indexOf(dataIndex);\n        }\n\n        var domIndex = this.findDomIndex(dataIndex),\n            boundary = this._boundary,\n            top = boundary.top,\n            bottom = boundary.bottom,\n            content = this.data.ltPropContent,\n            data = this.data.ltPropData,\n            removed = false;\n\n        this._prevent = true;\n\n        if (domIndex != -1) {\n            if (bottom == content.length - 1) {\n                for (var i = dataIndex; i <= bottom; i++) {\n                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;\n                    if (i + 1 == content.length) {\n                        this.regex(rows[cIndex], true);\n\n                        if ( this._dummy ) {\n                            var _style = this._dummy.style;\n                            _style.transform = 'translateY(' + ( parseFloat( _style.transform.match( /[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';\n                            \n                            if ( this._dummy1 ) {\n                                var _style1 = this._dummy1.style;\n                                _style1.transform = 'translateY(' + ( parseFloat( _style1.transform.match( /[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) + 'px)';\n                            }\n                        }\n                        if( content[ top - 1 ] ){\n                            this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[top - 1] });\n                            rows[ cIndex ].dataOrder = top - 1;\n                        }\n                    } else {\n                        this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });\n                        rows[cIndex].dataOrder--;\n                    }\n                }\n                if( content.length - 1 == data.length - 1 ){\n                    this.$addon.arrayUtils( data , 'pop' );\n                    removed = true;\n                }else if( boundary.top >= dataIndex){\n                    boundary.top--;\n                } \n                if(this._top != 0){\n                    this._top = (this._top -1 + data.length) % data.length;\n                }\n                this._bottom = (this._bottom - 1 + data.length) % data.length;\n                boundary.bottom--;\n                boundary.top!=0 && boundary.top--;\n \n            } else {\n                for (var i = dataIndex; i <= bottom; i++) {\n                    var cIndex = (domIndex + (i - dataIndex) + data.length) % data.length;\n                    this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i + 1] });\n                }\n                if (this._dummy) {\n                    var _style = this._dummy.style;\n                    _style.height = Math.max( 0, parseFloat( _style.height ) - this._rowHgt ) + 'px';\n                }\n            }\n            this.$addon.arrayUtils(content, 'removeAt', dataIndex);\n        } else {\n            this.$addon.arrayUtils(content, 'removeAt', dataIndex);\n            if (dataIndex < top) {\n\n                for (var i = top; i <= bottom; i++) {\n                    var cIndex = (this._top + i - top + rows.length) % rows.length;\n                    this.$component.set(data[cIndex], { index: data[cIndex].index, body: content[i == content.length ? (top - 1) : i] });\n                    if (i == bottom) {\n                        this.regex(rows[cIndex], true);\n                        this._bottom = (this._bottom - 1 + data.length) % data.length;\n                        this._top = (this._top - 1 + data.length) % data.length;\n                    }\n                }\n\n                boundary.bottom--;\n                boundary.top--;\n\n                var _style = this._dummy.style;\n                _style.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style.transform.match(/[\\d|.]+/ig)[ 0 ] ) - this._rowHgt ) ) + 'px)';\n                if (this._dummy1) {\n\n                    var _style1 = this._dummy1.style;\n                    _style1.transform = 'translateY(' + Math.max( 0, ( parseFloat( _style1.transform.match( /[\\d|.]+/ig )[ 0 ] ) - this._rowHgt ) ) + 'px)';\n                }\n\n            } else if (dataIndex > bottom) {\n                if (this._dummy) {\n                    this._dummy.style.height = Math.max(0, parseFloat(this._dummy.style.height) - this._rowHgt) + 'px';\n                }\n            }\n\n            if( content.length < this.data.ltPropContentLength && !removed ){\n                    Lyte.arrayUtils( data, 'pop' );\n            }\n        }\n\n        delete this._prevent;\n    }\n\n    scrollToRecord(rowIndex, isImmediate, scrollTop) {\n        var content = this.data.ltPropContent,\n            contentLength = content.length;\n\n        if (rowIndex == undefined || rowIndex < 0 || rowIndex >= contentLength) {\n            return;\n        }\n\n        if (!this._rowHgt) {\n            this.$node.scrollTable();\n        }\n\n        $L.fastdom.clear(this._scrollToRecord);\n\n        isImmediate ? this.processScrollToRecord( rowIndex , scrollTop ) : this._scrollToRecord = $L.fastdom.measure(this.processScrollToRecord.bind(this, rowIndex));\n\n        // this.processScrollToRecord( rowIndex );\n    }\n\n    processScrollToRecord(rowIndex, _scrollTop) {\n        var boundary = this._boundary,\n        top = boundary.top,\n        bottom = boundary.bottom,\n        content = this.data.ltPropContent,\n        data = this.data.ltPropData,\n        contentLength = data.length,\n        __length = content.length,\n        step = this._step,\n        rowHeight = this._rowHgt,\n        scrollDiv = this.scrollDiv,\n        offsetHeight = scrollDiv.offsetHeight,\n        scrollHeight = scrollDiv.scrollHeight,\n        scrollTop = scrollDiv.scrollTop,\n        possible_per_view = Math.floor( offsetHeight / rowHeight ),\n        scrollPosition = Math.max(0, Math.min(rowIndex, __length - Math.min( contentLength, possible_per_view ) ) ),\n        newScrollTop = scrollPosition * rowHeight,\n        scrollToSet,\n        __tags = this.data.ltPropTags;\n\n        if( content.length <= contentLength ){\n            scrollToSet = Math.max( 0, Math.min( scrollHeight - offsetHeight, rowIndex * rowHeight ) );\n        } else if( bottom - possible_per_view >= rowIndex ) {\n            scrollToSet = newScrollTop;\n        } else {\n            if (scrollPosition != rowIndex) {\n                newScrollTop += (step - offsetHeight);\n                var thead = $L( __tags.thead, this.$node).get(0);\n                if (thead) {\n                    newScrollTop += thead.offsetHeight;\n                }\n            }\n\n            var scrollHeight = scrollDiv.scrollHeight,\n            maxScrollTop = scrollHeight - offsetHeight,\n            diff = step - offsetHeight,\n            rows = this.arrayFrom($L( __tags.tbody + ' ' + __tags.tr + ':not(.dummy)', this.$node)),\n            fact = Math.floor(scrollPosition / contentLength),\n            newscrollPosition = scrollPosition % contentLength;\n\n            for (var i = 0; i < contentLength; i++) {\n                var cIndex = scrollPosition + i,\n                domIndex = cIndex % contentLength,\n                dom = rows[ domIndex ],\n                iteration = fact /*+ (i < newscrollPosition ? 1 : 0)*/;\n\n                if( cIndex >= __length ){\n                    if( scrollPosition % contentLength < domIndex ){\n                        iteration--;\n                    }\n                    cIndex -= contentLength;\n                } else {\n                    if( scrollPosition % contentLength > domIndex ){\n                        iteration++;\n                    }\n                }\n\n                this.$component.set(data[domIndex], { index: cIndex, body: content[cIndex] });\n\n                this.cellSet(dom, \"translateY(0px)\")\n                for (var j = 0; j < iteration; j++) {\n                    this.regex(dom);\n                }\n            }\n\n            if( !this._dummy ){\n                this.createDummy( this.$node.querySelector( __tags.tbody ) );\n            }\n\n            var boundary_top = Math.min( scrollPosition, __length - contentLength );\n\n            this._dummy.style.transform = 'translateY(' + ( boundary_top * rowHeight ) + 'px)';\n            if (this._dummy1) {\n                this._dummy1.style.transform = 'translateY(' + ( boundary_top * rowHeight) + 'px)';\n            }\n            scrollToSet = newScrollTop;\n            boundary.top = boundary_top;\n            boundary.bottom = boundary_top + contentLength - 1;\n            this._top = boundary_top % contentLength;\n            this._bottom = ( boundary_top + contentLength - 1) % contentLength;\n        }\n\n        var scrollFn = function (  ) {\n            scrollDiv.querySelector( 'lyte-table-structure' ).style.height = ( contentLength * rowHeight ) + 'px';\n            scrollDiv.scrollTop = scrollToSet;\n        }\n        if( _scrollTop != void 0 ){\n            scrollToSet = _scrollTop;\n            scrollFn();\n        }else{\n            window.requestAnimationFrame( scrollFn );\n        }\n        \n    }\n\n    calculateRowHeight() {\n        let tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody );\n        let tr = tbody[0].children[0];\n        let rowHeight = tr && tr.getBoundingClientRect().height;\n\n        return this._rowHgt = rowHeight;\n    }\n\n    update_aria(cell) {\n        var row = cell.parentNode,\n        index = this.get_children( row ).indexOf( cell ),\n        table = row.parentNode.parentNode,\n        sA = \"setAttribute\",\n        role = \"role\",\n        __tags = this.data.ltPropTags;\n\n        table[ sA ]( role, this.data.ltPropRole );\n        \n        Array.from( this.get_children( table ) ).forEach( function( item ){\n\n            if( /^div$/i.test( item.tagName || \"\" ) ){\n                return;\n            }\n\n            item[ sA ]( role, \"rowgroup\" );\n\n            var name = item.tagName.toLowerCase() == __tags.thead ? 'columnheader' : 'cell';\n\n            Array.from( this.get_children( item ) ).forEach( function( row ){\n                row[ sA ]( role, 'row' );\n\n                var __cell = this.get_children( row )[ index ];\n\n                if( __cell ){\n                    __cell[ sA ]( role, name );\n                }\n            }.bind( this ) );\n        }.bind( this ) );\n    }\n\n    get_children(__elem) {\n        var elems = __elem.length != void 0 ? Array.from( __elem ) : [ __elem ],\n        ret = [];\n\n        elems.forEach( function( item ){\n            Array.from( item.children ).forEach( function( __item ){\n                if( !/template/i.test( __item.tagName ) ){\n                    ret.push( __item );\n                }\n            });\n        });\n\n        return ret;\n    }\n\n    get_nth_cell(row, index) {\n        var children = this.get_children( row ),\n        __len = children.length,\n        __count = 0;\n\n        if( this.data.ltPropFromListview ){\n            return children[ index ];\n        }\n        for( var i = 0; i < __len; i++ ){\n            var __cell = children[ i ];\n            if( __count == index ){\n                return __cell;\n            } else if( __count > index ){\n                break;\n            }\n\n            __count += ( __cell.colSpan || 1 );\n        }\n    }\n\n    update_collapse(frm_update) {\n        if( this.__from_collapse ){\n            return;\n        }\n        var cells = Array.from( this.$node.getElementsByClassName( 'lyteHeaderCellCollapsed' ) );\n        cells.forEach( function( item ){\n            this.toggle_column( item, true, frm_update );\n        });\n    }\n\n    toggle_column(__cell, to_collapse, frm_update) {\n        var __index = Array.from( __cell.parentNode.children ).indexOf( __cell ),\n        header_cls = \"lyteHeaderCellCollapsed\",\n        body_cls = \"lyteCellCollapsed\",\n        tbody = this.$node.getElementsByTagName( this.data.ltPropTags.tbody ),\n        rows = this.get_children( tbody ),\n        __is_sticky = this.data.ltPropStickyTable;\n\n        __cell.classList[ to_collapse ? 'add' : \"remove\" ]( header_cls );\n\n        rows.forEach( function( item, index ){\n            var __elem = this.get_nth_cell( item, __index );\n\n            if( __elem ){\n                if( !index ){\n                    if( to_collapse ){\n                        __elem.rowSpan = rows.length;\n                    } else {\n                        __elem.rowSpan = 1;\n                    }\n                    __elem.classList[ to_collapse ? \"add\" : \"remove\" ]( \"lyteCollapseFirstCell\" );\n                }\n\n                __elem.classList[ to_collapse ? \"add\" : \"remove\" ]( body_cls );\n            }\n        }.bind( this ) );\n\n        if( !this.__from_collapse && !frm_update && ( __is_sticky || __cell.classList.contains( 'lyteTableFixed' ) ) ){\n            $L.fastdom.clear( this.__collpse_fdom );\n            this.__from_collapse = true;\n            this.__collpse_fdom = $L.fastdom.measure( function(){\n                delete this.__collpse_fdom;\n                this.$node[ __is_sticky ? \"reset\" : \"scrollTable\" ]();\n                delete this.__from_collapse;\n            }.bind( this ) );\n        }\n    }\n\n    collapse_column(__cell) {\n        this.toggle_column( __cell, true );\n    }\n\n    expand_column(__cell) {\n        this.toggle_column( __cell );\n    }\n\n    static observers() {\n        return {\n            initProcess1 : function( arg ){\n                var __this = this,\n                __data = __this.data,\n                is_reset = arg && arg.item == \"ltPropReset\";\n\n                if( __this._prevent ){\n                    return\n                }\n\n                if( is_reset && arg.newValue == false ){\n                    return;\n                }\n\n                if( __data.ltPropInfiniteScroll ){\n                    var table = __this.$node.getElementsByTagName( __data.ltPropTags.table )[ 0 ],\n                    content = __data.ltPropContent || [],\n                    __length = content.length,\n                    len = Math.min( __data.ltPropContentLength || __length, __length ),\n                    data = [];\n\n                    if( __length == 0 && !arg ){\n                        return;\n                    }\n\n                    if( table ){\n                        table.style.height = \"auto\";\n                    }\n\n                    for( var i = 0; i < len; i++ ){\n                        data[ i ] = {\n                            body : content[ i ],\n                            checked : false,\n                            index : i\n                        };\n                    }\n\n                    if( __data.fromListView ){\n                        var act_data = __data.ltPropData,\n                        arr_util = this.$addon.arrayUtils,\n                        obj_util = this.$addon.objectUtils;\n\n                        data.forEach( function( item, index ){\n                            var __cur = act_data[ index ];\n\n                            if( __cur ){\n                                obj_util( __cur, 'add', 'body', item.body );\n                                obj_util( __cur, 'add', 'index', item.index );\n                                obj_util( __cur, 'add', 'checked', item.checked );\n                            }else {\n                                arr_util( act_data, 'insertAt', item.index, item );\n                            }\n                        });\n\n                        arr_util( act_data, 'splice', data.length, act_data.length - data.length );\n\n                    } else {\n                        this.setData( 'ltPropData', data );\n                    }\n\n                    var __dummy = __this._dummy,\n                    __dummy1 = __this._dummy1,\n                    __scrolldiv = __this.scrollDiv,\n                    __translate = \"translateY(0px)\";\n\n                    delete __this._stopScroll;\n\n                    if( arg ){\n                        __dummy && $L( __dummy ).css({\n                            height : 0,\n                            transform : __translate\n                        });\n\n                        __dummy1 && $L( __dummy1 ).css( 'transform', __translate );\n\n                        __scrolldiv.scrollTop = 0;\n                        __scrolldiv.scrollLeft = 0;\n                    }\n\n                    __this._boundary = {\n                        top : __this._top = 0,\n                        bottom : __this._bottom = Math.max( len - 1, 0 )\n                    };\n                }\n\n                if( is_reset ){\n                    this.setData( arg.item, false );\n                }\n            }.observes( 'ltPropContent.[]', 'ltPropReset' ).on( 'init' ),\n\n            // border \n\n            borderChangeObs: function () {\n                this.borderChange.call(this);\n            }.observes('ltPropBorder').on('didConnect'),\n\n            widthObsObs: function () {\n                this.widthObs.call(this);\n            }.observes('ltPropWidth').on('didConnect'),\n\n            heightObsObs: function () {\n                this.heightObs.call(this);\n            }.observes('ltPropHeight').on('didConnect'),\n\n            sortableObs: function () {\n                !this.data.ltPropStickyTable && this.sortable();\n            }.observes('ltPropColumnSortable').on('didConnect')\n        };\n    }\n\n    includes() {\n        return [LyteTableUtilsMixin, LyteTableSortableMixin];\n    }\n}\n\nif (!window._lyteUiUtils.registeredCustomElements['lyte-th']) {\n    window._lyteUiUtils.registeredCustomElements['lyte-th'] = true;\n\n    /**\n     * @customElement lyte-th,lyte-td\n     */\n    class LyteThCustomElements extends LyteUiComponentComponentRegistry.CustomElements {\n        static options = {clone : {allCallbacks : false}};\n\n        lookups() {\n            return [{\n                component: LyteUiComponentComponentRegistry\n            }];\n        }\n\n        constructor() {\n            super();\n        }\n\n        static get observedAttributes() {\n            return [ 'fixed', 'resize', 'icon', 'sticky-position', \"collapse\" ];\n        }\n\n        getTable() {\n            var lyteNode = this.$node;\n            var query = \"lyte-table\";\n            return (lyteNode.__table || (lyteNode.__table = lyteNode.closest ? lyteNode.closest( query ) : $L( lyteNode ).closest( query ).get( 0 )));\n        }\n\n        getSticky() {\n            var lyteNode = this;\n            var __sticky = lyteNode.__is_sticky;\n            return __sticky == void 0 ? ( lyteNode.__is_sticky = lyteNode.getTable().ltProp( 'stickyTable' ) ) : __sticky;\n        }\n\n        connectedCallback() {\n            var lyteNode = this;\n            var table = lyteNode.getTable(),\n            $node = lyteNode.$node;\n\n            if( table && table.ltProp( 'role' ) && table.ltProp( 'yield' ) ){\n                table.component.update_aria( $node );\n            }\n\n            if( $node.parentNode.previousElementSibling ){\n                lyteNode.$node.classList.add( \"lyteTableSecondaryHeader\" );\n            }\n        }\n\n        attributeChangedCallback(attr, oldVal, newVal) {\n            var lyteNode = this.$node;\n\n            var $node = $L( lyteNode );\n\n            switch (attr) {\n                case 'fixed': {\n                    var is_enable = newVal == \"enable\";\n\n                    $node[ ( is_enable ? 'add' : \"remove\" ) + 'Class' ]( 'lyteFixedColumn' );\n                    if( this.getSticky() ){\n                        lyteNode.__table.component.checkIntersection.call( lyteNode, is_enable );\n                    }\n                }\n                    break;\n                case 'resize': {\n                    var ns = 'lyte-tablehead-resize';\n                    if( newVal == \"enable\" ){\n                        var thead = document.createElement( ns ),\n                        __add = \"addEventListener\",\n                        fn = this.resize;\n\n                        thead[__add]('mousedown', fn);\n                        thead[__add]('touchstart', fn);\n\n                        lyteNode.appendChild( thead );\n                    } else {\n                        var thead = lyteNode.getElementsByTagName( ns )[ 0 ];\n                        if( thead ){\n                            lyteNode.removeChild( thead );\n                        }\n                    }\n                }\n                break;\n                case 'icon' : {\n                    $node[ ( newVal == \"disable\" ? 'add' : \"remove\" ) + 'Class' ]( 'lytePreventIcon' );\n                }\n                break;\n                case 'sticky-position' : {\n                    if( $node.attr( 'fixed' ) == \"enable\" && this.getSticky() ){\n                        var is_enable = newVal == \"right\",\n                        __table = lyteNode.__table.component,\n                        fn = is_enable ? 'add' : \"remove\",\n                        __class = 'lyteTableRightFixed';\n\n                        if( !is_enable && !$node.hasClass( __class ) ){\n                            return;\n                        }   \n\n                        __table.stickyFunction( lyteNode, false, fn + 'Class', __class );\n                        __table.checkIntersection.call( lyteNode, is_enable, true );\n                    }\n                }\n                break;\n                case 'collapse' : {\n                    var __table = this.getTable();\n\n                    if( __table ){\n                        if( newVal == \"true\" ){\n                            __table.component.collapse_column( lyteNode );\n                        } else if( oldVal == \"true\" ){\n                            __table.component.expand_column( lyteNode );\n                        }\n                    }\n                }\n                break;\n            }\n        }\n\n        resize(event) {\n            var lyteNode = this;\n            if (lyteNode.parentNode.classList.contains('lyteTableFixed')) {\n                return;\n            }\n            var table = $L(event.target).closest('lyte-table')[0];\n            table.component.getActions(\"tableResize\").call(table.component, event);\n        }\n\n        disconnectedCallback() {\n            var lyteNode = this.$node;\n            if( lyteNode.__is_sticky ){\n                lyteNode.__table.component.disconnectedCallback.call( lyteNode );\n            }\n            delete lyteNode.__table;\n        }\n    }\n\n    LyteThCustomElements.register(\"lyte-th\");\n\n    window.resizeTable = function(evt) {\n        if (evt && evt.type == 'resize' && _lyteUiUtils.isMobile) {\n            return;\n        }\n\n        var fn = function( item ){\n            var __elem = item.component.scrollDiv,\n            $elem = $L( __elem );\n            __elem && $elem.resetScrollbar && $elem.resetScrollbar();\n        },\n        is_orient = evt && evt.type == \"orientationchange\";\n\n        Array.from(document.body.getElementsByTagName('lyte-table')).forEach(function (item) {\n            if (is_orient) {\n                setTimeout(fn.bind(this, item), 500);\n            } else {\n                fn(item);\n            }\n        });\n    };\n}\n\n\n/**\n * @syntax nonYielded\n *   <lyte-table  lt-prop-content='[{\"cityName\" : \"Agra\",\"serialNo\" : \"1\"},{\"cityName\" : \"Mysore\", \"serialNo\" : \"2\"}]' lt-prop-header='[{\"data\" : \"From\", \"bodyData\" : \"cityName\"},{\"data\" : \"No\", \"bodyData\" : \"serialNo\"}]' lt-prop-header-label-key='data' lt-prop-body-label-key='bodyData' >\n *   </lyte-table>\n */\n\n/**\n * @syntax yielded\n * <lyte-table lt-prop-yield=\"true\">\n *      <template is=\"registerYield\" yield-name=\"yield\">\n *          <lyte-table-structure>\n *             <lyte-thead>\n *                <lyte-tr>\n *                   <lyte-th>From</lyte-th>\n *                   <lyte-th>No</lyte-th>\n *                   <lyte-th>Name</lyte-th>\n *                </lyte-tr>\n *             </lyte-thead>\n *             <lyte-tbody>\n *                <lyte-tr>\n *                   <lyte-td>Agra</lyte-td>\n *                   <lyte-td>1</lyte-td>\n *                   <lyte-td>Tajmahal</lyte-td>\n *                </lyte-tr>\n *                <lyte-tr>\n *                   <lyte-td>Mysore</lyte-td>\n *                   <lyte-td>2</lyte-td>\n *                   <lyte-td>Mysorepalace</lyte-td>\n *                </lyte-tr>\n *             </lyte-tbody>\n *          </lyte-table-structure>\n *      </template>\n *  </lyte-table>\n */\n\n/**\n * @syntax Infinite scroll\n * @attribute ltPropYield=true\n * @attribute ltPropInfiniteScroll=true\n *  <lyte-table style = 'height: 350px;' lt-prop-infinite-scroll = true lt-prop-yield = true lt-prop-content = {{contentJSON}} scroll-end = {{method('someMethod')}}>\n *   <template is = 'registerYield' yield-name = 'yield'>\n *       <lyte-table-structure>\n *           <lyte-thead>\n *               <lyte-tr>\n*                  <lyte-th> From </lyte-th>\n*                  <lyte-th> No </lyte-th>\n*                  <lyte-th> Name </lyte-th>\n *              </lyte-tr>\n *           </lyte-thead>\n *           <lyte-tbody>\n *             <lyte-tr>\n *               <lyte-td> Agra </lyte-td>\n *               <lyte-td> 1 </lyte-td>\n *               <lyte-td> Taj Mahal </lyte-td>\n *             </lyte-tr>\n *              <lyte-tr>\n *               <lyte-td> Mysore </lyte-td>\n *               <lyte-td> 2 </lyte-td>\n *               <lyte-td> Mysore palace </lyte-td>\n *             </lyte-tr>\n *           </lyte-tbody>\n *       </lyte-table-structure>\n *   </template>\n *  </lyte-table>\n */\nexport { LyteTableComponent };\n \n","import { Mixin } from \"@slyte/core\";\nimport $L from \"@zoho/lyte-dom\";\n\nclass LyteTableSortableMixin extends Mixin {\n     rowMouseDown(evt) {\n                  \n            var _this = this ,\n                tags = _this.data.ltPropTags,\n                tr = evt.target.closest(tags.tr) , \n                tbody = tr.closest(tags.tbody);\n            if( tbody != void 0 ){\n                var table = tbody.closest('lyte-table'),\n                    index = Array.from( tr.parentElement.children ).indexOf( tr ),\n                    actual_index = index ,\n                    cur_index = actual_index  ,\n                    data = _this.data.ltPropData , \n                    isFirst = true , \n                    trTransform = tr.style.transform ,\n                    content = _this.data.ltPropContent ,\n                    boundary = _this._boundary , \n                    isTouch = Boolean(evt.touches),\n                    hasContainment = Boolean(_this.data.ltPropContainment) ,\n                    containElem = hasContainment ? $L(_this.$node).find(_this.data.ltPropContainment)[0] : undefined,\n                    containElemClient = containElem != void 0 ? containElem.getBoundingClientRect() : undefined , \n                    placeholder = $L(this.$node).find( '.lyteTableSortablePlaceholder' ).get(0),\n                    outOfBound = false, yRelatedToElement , reachedTop , reachedEnd , diff = void 0;\n\n                if(tr.parentElement.tagName.toLowerCase() == _this.data.ltPropTags.tbody){\n                    if( this.getMethods( 'onRowSelect' ) ){\n                        let ret = this.executeMethod( 'onRowSelect' , evt  , data[actual_index].index  , actual_index , _this.$node );\n                        if( ret === false ){\n                            return;\n                        }\n                    } \n\n                    evt.preventDefault();\n\n                    placeholder.classList.remove( 'lyteTableSortablePlaceholderHidden' );\n                \n                    var findElement = function ( isPrev , isMouseUp ){\n                        if( isMouseUp ){\n                            let arr = Array.from(tbody.children);\n                            for( let i = 0 ; i < arr.length ; i++ ){\n                                let cur = arr[i];\n                                if( cur.classList.contains('lyteTableRowSorting') ){\n                                    return i;\n                                }\n                            }\n                        }else{\n                            let curIndex =_this.data.ltPropData[cur_index].index ,\n                                findIndex = isPrev ? getIndex(  curIndex == 0 ? data.length-1 : curIndex - 1 ) :\n                                                     curIndex == data.length-1 ? curIndex == content.length-1 ? undefined : 0 : getIndex(curIndex + 1 ),\n                                arr = Array.from( tbody.children );\n                            if(findIndex == undefined){\n                                return;\n                            }\n                            for( let i = 0, j = 0 ; i < arr.length ; i ++ ){\n                                let cur = arr[i];\n                                if( !(cur.classList.contains('dummy')) ){\n                                    if( j == findIndex ){\n                                        return arr[i];\n                                    }\n                                    j++\n                                }\n                            }\n                        }\n                    },\n                    makeElementDraggable = function(){\n                        var width = []\n                        Array.from( tr.children ).forEach( function(td){\n                            width.push( window.getComputedStyle(td).width );\n                        }); \n                        tr.classList.add('lyteTableRowSorting'); \n                    },\n                    getIndex = function( index ){\n                        var find = function(obj){\n                            return obj.index === index;\n                        }\n                        return _this.data.ltPropData.findIndex(  find );\n                    },\n                    checkLimit = function (num){\n                        return 0 <= num && num < _this.data.ltPropData.length ;\n                    },\n                    changePlaceHolder = function( _tr ){\n                        placeholder.style.transform = \"\";\n                        if( _tr.style.transform ){\n                            placeholder.style.transform = _tr.style.transform;\n                        }\n                        placeholder.style.top = _tr.offsetTop + \"px\";\n                        placeholder.style.left = _tr.offsetLeft + \"px\";\n                        placeholder.style.width = _tr.offsetWidth + \"px\";\n                        placeholder.style.height = _tr.offsetHeight + \"px\";\n                    };\n                \n                    changePlaceHolder( tr );\n                    makeElementDraggable();\n                \n                    var initialY = isTouch ? evt.touches[0].clientY : evt.clientY;\n                         \n                    var mouseup = function(event){\n                        let currentIndex = findElement( false , true ) ,\n                        scrollTop = _this.scrollDiv.scrollTop;\n                        evt.preventDefault();\n\n                        placeholder.classList.add( 'lyteTableSortablePlaceholderHidden' );\n                    \n                            if(_this.getMethods( 'onBeforeRowDrop' )){\n                                var ret = _this.executeMethod( 'onBeforeRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node  );\n                            } \n\n                            if(ret === false){\n                                let removeIndex = cur_index , \n                                    cur_data = Object.assign( {} , data[removeIndex] );\n\n                                _this.removeRow(data[removeIndex].index);\n                                _this.insertRow(data[actual_index].index , cur_data.body);\n\n                                if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){\n                                    _this.scrollToRecord( data[removeIndex].index , true , scrollTop );\n                                }\n                            }\n                            tr.style.transform = trTransform;\n                            tr.classList.remove('lyteTableRowSorting')\n\n                            _this.getMethods( 'onRowDrop' ) && _this.executeMethod( 'onRowDrop' , event , currentIndex , data[currentIndex].index , _this.$node );\n                        \n                            let elem = tbody.children[getIndex(actual_index)];\n                            if(elem){\n                                elem.style.top = \"\"; elem.style.right = \"\";\n                            }\n                        \n                        \n                        document.removeEventListener( isTouch ? 'touchmove' : 'mousemove', mousemove)\n                        document.removeEventListener( isTouch ? 'touchend' : 'mouseup', mouseup);\n                    },\n\n                    parseNum = function (number){\n                        let match = number.match(/-?\\d+(\\.\\d+)?/);\n                        return match ? parseFloat(match[0]) : 0\n                    },\n                    isInRange = function( tr , y , isUp){\n                        let client = tr.getBoundingClientRect() ,\n                            topCheck = containElemClient.top < client.top ,\n                            bottomCheck = ( client.top + client.height ) < (containElemClient.top + containElemClient.height );\n\n                        if( isUp == void 0 ){ return topCheck && bottomCheck }\n\n                        reachedTop = false; reachedEnd = false;\n\n                        if( !topCheck ) { \n                             reachedTop = true; }\n                        else if( !bottomCheck ) { reachedEnd = true; }\n\n                        if( reachedTop ){ \n                            topCheck = !isUp && ( ( containElemClient.top < y ) && ( y < containElemClient.top + containElemClient.height-diff ) ) && diff >= 0;\n                        }else if( reachedEnd ){\n                            bottomCheck = isUp && ( containElemClient.top < y && y < (containElemClient.top + containElemClient.height ) ) && diff <= 0\n                        }\n                         return topCheck && bottomCheck \n\n                    },\n                    fixTop = function ( isUp , returnBoundElem , getDiff){\n                        var trClient = tr.getBoundingClientRect(),\n                            _diff , transformY ,\n                            top = _this._top , bottom = _this._bottom , \n                            contentLength = data.length;\n\n                    \n                        _diff = isUp ? containElemClient.top - trClient.top : \n                                     (containElemClient.top + containElemClient.height) - (trClient.top + trClient.height);\n                        if( getDiff === true ){ \n                            diff = -_diff;\n                            return;\n                        };\n                        transformY = parseNum( tr.style.transform );\n                        tr.style.transform = \"\"; _this.transform( true , tr , transformY + _diff );\n                        trClient = tr.getBoundingClientRect();\n\n\n                        if( !returnBoundElem ) { return; }\n\n                        let reachedEnd = false;\n\n                        for (let i = isUp ? top : bottom ; isUp ? i < (top+contentLength) : (reachedEnd ? i > bottom + 1 : i >= 0) ; isUp ? i++ : i--) {\n                            i = isUp ? i%contentLength : i;\n                            const element = tbody.children[i] ,\n                                  elemClient = element.getBoundingClientRect();\n\n                            if(isUp ? ( elemClient.top >= ( containElemClient.top ) ) : (elemClient.top < (containElemClient.top+containElemClient.height))){\n                                if( isUp ? trClient.top <= elemClient.top : trClient.top >= elemClient.top ){\n                                    if(cur_index != i){\n                                        return i;\n                                    }\n                                    return;\n                                 }\n                            }\n\n\n                            if( !isUp && i == 0 ){\n                                reachedEnd = true;\n                                i = contentLength;\n                            }\n                        }\n                    \n                    }\n                \n                    var mousemove = function( event ){\n                        isTouch ? null : event.preventDefault();\n                        var y = isTouch ? event.touches[0].clientY : event.clientY ;\n\n                        y = (y < 0) ? 0 : y;\n\n                        var isUp = ( initialY > y) , isDown = ( initialY < y ),\n                            isRange , targetIndex , \n                            neighbour = isDown ? findElement( false ) : isUp ? (cur_index == 0 && boundary.top == 0) ? undefined : findElement( true ) : undefined ,\n                            check = false;\n                        \n                        \n                        \n                        if(isUp || isDown) {\n\n                            let _transform = tr.style.transform;\n                            tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") + ( diff != void 0 ? diff : 0 )- (initialY - y)) + \"px)\";\n\n                            if(hasContainment){\n                                diff = diff != void 0 ? diff - (initialY - y) : void 0;\n                                isRange = isInRange( tr , y , isUp );\n                                if(!isRange && !outOfBound){\n                                    fixTop( isUp , false , true );\n                                    check = true ;\n                                }\n                            }\n\n                            tr.style.transform = _transform;\n\n\n                           if( isFirst && _this.getMethods('onRowDragStart') ){\n                               _this.executeMethod( 'onRowDragStart' , event , data[cur_index].index , cur_index , _this.$node );\n                           }\n\n\n                       \n                           if( hasContainment && isRange){\n                               if(  outOfBound ){\n                                   tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") + ( diff )) + \"px)\";\n                                   diff = void 0;\n                                   outOfBound = false;\n                               }else{\n                                   tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") - (initialY - y)) + \"px)\";\n                                   outOfBound = false;\n                               }\n                           }else if( hasContainment && !outOfBound) {\n                               outOfBound = true ;\n                               targetIndex = fixTop( isUp , true );\n                           }else if(!hasContainment){\n                               tr.style.transform = \"translateY(\" + (parseNum(tr.style.transform || \"\") - (initialY - y)) + \"px)\";\n                           }\n\n                           isFirst = false;  \n                           var trClient = tr.getBoundingClientRect();\n\n                           if( (neighbour != void 0 && !outOfBound) || (targetIndex != void 0) ){\n                                let isExceeds = targetIndex == void 0 ? isDown ? ( neighbour.getBoundingClientRect().top < trClient.top ) :\n                                                isUp ?   ( neighbour.getBoundingClientRect().top > trClient.top ) : false : false;\n\n                                if( (neighbour != void 0 && isExceeds) || (targetIndex != void 0)){\n                                    let curData = Object.assign( {} , _this.data.ltPropData[cur_index] ) , \n                                        heightDiff = parseNum(tr.style.transform) - parseNum(trTransform) + ( (isDown ? -1 : 1 ) * tr.offsetHeight ) ,\n                                        _curIndex = data[cur_index].index, \n                                        hasTarget = targetIndex != void 0;\n\n                                    tr.style.setProperty('transform' , trTransform ) ;\n                                    let scrollTop = _this.scrollDiv.scrollTop;\n\n                                    clearTimeout(_this._ignoreTimeout)\n                                    _this.__ignore_scroll = true;\n\n                                    let insertIndex = ( targetIndex != void 0 ? data[targetIndex].index : isDown ? _curIndex+1 : _curIndex-1  ),\n                                        removeIndex = _curIndex!=void 0 ? _curIndex : cur_index;\n\n                                    _this.removeRow( removeIndex );\n                                    _this.insertRow( insertIndex , curData.body );\n\n\n                                    if( _this.data.ltPropContent.length - 2 == _this._boundary.bottom ){\n                                        if( _this._rowHgt == undefined ){\n                                            _this.__allow_scroll = true;\n                                        }\n                                        _this.scrollToRecord( _curIndex, true , scrollTop );\n                                        _this.__allow_scroll = false;\n                                    }\n\n                                    if( hasTarget ){\n                                        tr.classList.remove('lyteTableRowSorting');\n                                        tr = tbody.children[targetIndex];\n\n                                        changePlaceHolder( tr );\n\n                                        trTransform = tr.style.transform;\n                                        tr.classList.add('lyteTableRowSorting');\n                                        fixTop(isUp);\n                                        cur_index = targetIndex;\n                                    }else{\n                                        tr = tbody.children[getIndex(removeIndex)] ; neighbour = tbody.children[getIndex(insertIndex)];\n\n                                        changePlaceHolder( neighbour );\n\n                                        tr.classList.remove('lyteTableRowSorting');\n                                        neighbour.classList.add('lyteTableRowSorting');\n                                        trTransform = neighbour.style.transform;\n                                        cur_index = isDown ? checkLimit( cur_index + 1 ) ? cur_index + 1 : 0 : checkLimit( cur_index - 1 ) ? cur_index - 1 : data.length-1;\n                                        neighbour.style.transform = \"translateY(\" + ( ( isDown ? ( cur_index == 0 ) : ( cur_index == data.length - 1 ) ) ?  (parseNum(neighbour.style.transform) + heightDiff ) : heightDiff + parseNum(trTransform) ) + \"px)\";\n                                        tr = neighbour; \n                                    }\n\n\n                                    index = isDown ? (index + 1) : (index - 1);\n\n                                    _this._ignoreTimeout = setTimeout(() => {\n                                        _this.__ignore_scroll = false;\n                                    }, 100);\n                                }\n\n                           }\n                        }                   \n                    \n                     initialY =  y;\n                    }\n                \n                    document.addEventListener( 'mousemove' , mousemove , evt );\n                    document.addEventListener( 'mouseup' , mouseup , evt);\n\n                    document.addEventListener( 'touchmove' , mousemove , false );\n                    document.addEventListener( 'touchend' , mouseup , false);\n                }   \n            }\n  \n    }\n}\n\nexport { LyteTableSortableMixin };\n\n","import { Mixin } from \"@slyte/core\";\nimport $L from \"@zoho/lyte-dom\";\n\nclass LyteTableUtilsMixin extends Mixin {\n    getScrollDiv() {\n        return this.$node.getElementsByClassName( 'lyteTableScroll' )[ 0 ];\n    }\n\n    registerInterSection(scrollDiv) {\n         this._intersectionObs = new window.IntersectionObserver( this.intersection.bind( this ), { threshold : [ 1 ], root : scrollDiv } )\n    }\n\n    detectBrowsers() {\n        var userAgent = window.navigator.userAgent\n        this._isSafari = /safari/ig.test( userAgent );\n        this._FF = /firefox/ig.test( userAgent );\n        this._chrome = /Chrome/i.test( userAgent ) && /Google Inc/i.test( window.navigator.vendor );\n    }\n\n    getHeaderWidths(headerCells) {\n        return headerCells.map( function( cell ){\n            return cell.getBoundingClientRect().width;\n        });\n    }\n\n    getTbody() {\n        return this._tbody || this.$node.getElementsByTagName( this.data.ltPropTags.tbody );\n    }\n\n    getThead() {\n        return this.$node.getElementsByTagName( this.data.ltPropTags.thead )[ 0 ];\n    }\n\n    getRows() {\n        return this.$node.getElementsByTagName( this.data.ltPropTags.tr );\n    }\n\n    makeFixedColumn(rows, index, left, value) {\n\n        rows.forEach( function( row ){\n            var _$L = $L( row );\n            if( !_$L.hasClass( 'dummy' ) ) {\n                $L( this.get_nth_cell( row, index ) ).css( left, value ).addClass( 'lyteFixedColumn' );\n            }\n        }.bind( this ) );\n    }\n\n    observe(intersection) {\n        if( !intersection._observed ){\n            this._intersectionObs.observe( intersection );\n            intersection._observed = true;\n        }\n    }\n\n    _setLeftForInterSection(reset) {\n\n        var fastdom = $L.fastdom,\n        __this = this;\n\n\n        fastdom.clear( __this._setmeasure );\n\n        __this._setmeasure = fastdom.measure( function(){\n\n            var __tags = __this.data.ltPropTags,\n            th_rows = Array.from( __this.$node.querySelectorAll( __tags.thead + ' ' + __tags.tr ) ),\n            accumulatedTop = 0;\n\n            th_rows.forEach( function( row, ___index ){\n                var headerCells = __this.get_children( row ),\n                __length = headerCells.length - 1;\n\n                if( __length + 1 ){\n                    var width = __this.getHeaderWidths( headerCells ),\n                    top_to_set = accumulatedTop,\n                    check_right = true,\n                    left = __this.rtlfunc( 'left' );\n\n                    accumulatedTop += row.getBoundingClientRect().height;\n\n                    fastdom.mutate( function(){\n                        var tbody = __this.getTbody(),\n                        rows = ___index ? [] : __this.get_children( tbody ),\n                        intersectionDivs = [],\n                        accumulatedWidth = 0,\n                        accumulatedLeft = 0,\n                        fn = function( cell, index ){\n                            var intersection = cell._horizontalIntersectionDiv,\n                            __index = check_right ? index : ( __length - index );\n\n                            if( intersection ){\n                                var _hasClass = $L( cell ).hasClass( 'lyteTableRightFixed' );\n                                if( ( check_right && _hasClass ) || ( !check_right && !_hasClass ) ){\n                                    intersection = void 0;\n                                }\n                            }\n\n                            if( intersection ){\n                                intersectionDivs.push( intersection );\n                                intersection.style[ left ] = accumulatedLeft + 'px';\n                                cell.style[ left ] = accumulatedWidth + 'px';\n\n                                __this.throwEvent( \"intersectionSet\", cell, left, accumulatedWidth );\n\n                                __this.makeFixedColumn( rows, __index, left, accumulatedWidth );\n\n                                accumulatedWidth += width[ __index ];\n\n                                __this.observe( intersection );\n\n                                if( intersection._sticked && reset ){\n                                    __this.addFixedClass( cell );\n                                }\n                            } else {\n                                accumulatedLeft +=  width[ __index ];\n                            }\n\n                            if( ___index ){\n                                cell.style.top = top_to_set + 'px';\n                            }\n                        };\n\n                        headerCells.forEach( fn );\n                        check_right = false;\n                        left = __this.rtlfunc( 'right' );\n                        accumulatedLeft = 0;\n                        accumulatedWidth = 0;\n\n                        headerCells.reverse().forEach( fn );\n\n                         ___index ? void 0 : ( __this._intersections = intersectionDivs );\n                    });\n                }\n            }); \n        });\n    }\n\n    intersection(intersections) {\n        \n        intersections.forEach( function( intersection ){\n            this.singleIntersection( intersection );\n        }.bind( this ) );\n    }\n\n    singleIntersection(intersection) {\n        var cell = intersection.target._cell,\n        __this = this,\n        ns = intersection.intersectionRatio ? 'processUnfix' : 'processFix';\n\n        __this._fixedWidth = __this._fixedWidth || 0;\n        __this._rightFixedWidth = __this._rightFixedWidth || 0;\n        __this[ ns ]( cell, intersection );\n    }\n\n    common_fn(cell, intersection, __remove) {\n        var __this = this;\n\n        __this[ __remove ? 'removeFixedClass' : 'addFixedClass' ]( cell );\n        intersection.target._sticked = !__remove;\n        __this[ __remove ? 'callUnfix' : \"callFix\" ]( cell );\n\n        if( cell.parentNode.previousElementSibling ){\n            return;\n        }\n\n        $L.fastdom.measure( function(){\n            var bcr = cell._bcr || cell.getBoundingClientRect(),\n            ns = cell.classList.contains( 'lyteTableRightFixed' ) ? '_rightFixedWidth' : \"_fixedWidth\";\n\n            if( ( __this[ ns ] += ( bcr.width * ( __remove ? -1 : 1 ) ) ) < 0 && __remove ){\n                __this[ ns ] = 0;\n            }\n        });\n    }\n\n    processUnfix(cell, intersection) {\n        this.common_fn( cell, intersection, true );\n    }\n\n    processFix(cell, intersection) {\n        this.common_fn( cell, intersection );\n    }\n\n    execute(cb) {\n        return this.getMethods( cb ) && this.executeMethod.apply( this, arguments );\n    }\n\n    callUnfix(cell) {\n        this.execute( 'onUnFix', cell, this.$node );\n    }\n\n    callFix(cell) {\n        this.execute( 'onFix', cell, this.$node );\n    }\n\n    callDrop(selectedCell, next, startIndex, endIndex, header, evt) {\n        this.execute( 'onDrop', selectedCell, next, startIndex, endIndex, header, evt, this.$node );\n    }\n\n    callRelease(evt, selectedCell) {\n       this.execute( 'onRelease', evt, selectedCell, this.$node );\n    }\n\n    callOnBeforeSelect(selectedCell, ev, index) {\n        return this.execute( 'onBeforeSelect', selectedCell, ev, this.$node, index ) == false;\n    }\n\n    callOnSelect(selectedCell, ev, index) {\n        return this.execute('onSelect', selectedCell, ev, this.$node, index ) === false;\n    }\n\n    stickyFunction(cell, isCss, property, value) {\n        var index = this.getIndex( cell ),\n        tbody = this.getTbody(),\n        rows = cell.parentNode.previousElementSibling ? [] : this.get_children( tbody ),\n        fnName = isCss ? 'css' : property,\n        fnValue = value;\n\n        if( isCss ){\n            fnValue = {};\n            fnValue[ property ] = value;\n        }\n\n        $L( cell )[ fnName ]( fnValue );\n\n        rows.forEach( row => {\n            $L( this.get_nth_cell( row, index ) )[ fnName ]( fnValue );\n        });\n    }\n\n    removeFixedClass(cell) {\n        this.stickyFunction( cell, false, 'removeClass', 'lyteTableFixed' );\n    }\n\n    addFixedClass(cell) {\n        this.stickyFunction( cell, false, 'addClass', 'lyteTableFixed' );\n    }\n\n    removeSticky(cell) {\n        var is_right = cell.classList.contains( 'lyteTableRightFixed' );\n\n        this.stickyFunction( cell, true, this.rtlfunc( is_right ? 'right' : 'left' ), '' );\n        this.stickyFunction( cell, false, 'removeClass', 'lyteFixedColumn' );\n    }\n\n    makeSticky(cell) {\n        var __left = this.rtlfunc( 'left' );\n\n        this.stickyFunction( cell, true, __left, cell.style[ __left ] );\n    }\n\n    stickyScroll(evt) {\n        var __target = evt.target;\n\n        if( __target == this.scrollDiv ){\n            var __intersections = this._intersections;\n\n            if( __intersections.length  ){\n                $L.fastdom.measure( function(){\n                    var scrollTop = __target.scrollTop;\n                    $L.fastdom.mutate( function(){\n                       __target.closest( 'lyte-table' ).style.setProperty( '--lyte-table-intersection', scrollTop + 'px' );\n                    });\n                });\n            }\n        }\n    }\n\n    sortablemousedown(ev) {\n        var evt = ev,\n        isTch,\n        __target = ev.target;\n\n        if( /lyte-tablehead-resize/i.test( __target.tagName ) || ev.button != 0 ){\n            return\n        }\n\n        if( /touch/i.test( ev.type ) ){\n            if( ev.touches.length > 1 ){\n                return;\n            }\n            isTch = true;\n            evt = ev.touches[ 0 ];\n        }\n        var target = __target,\n        selectedCell = $L( target ).closest( this.data.ltPropTags.th ).get( 0 ),\n        index = this.getIndex( selectedCell );\n\n        if( $L( selectedCell ).hasClass( 'lyteTableFixed' ) ){\n            return;\n        }\n\n        if( this.callOnBeforeSelect( selectedCell, ev, index ) ){\n            return;\n        }\n\n        this._ww = window.innerWidth;\n\n        // no need to pass this._ww inside rtlfunc. its already available inside it == > here only its available in this. In other places i am passing. So i need to pass here too. Here i am storing because of window dimension wont change during mousemove. So no need to measure that in mousemove\n        var clientX = this.rtlfunc( 'clientX', evt, this._ww ),\n        offleft = 0,\n        tbody = this.getTbody(),\n        thead = this.getThead(),\n        cells = [],\n        rows = this.get_children( tbody ),\n        scrollDiv = this.getScrollDiv(),\n        scrollTop = scrollDiv.scrollTop;\n\n        this._elem = selectedCell;\n\n        this._originalIndex = index;\n        this._sortmousemove = this.sortmousemove.bind( this );\n        this._sortmouseup = this.sortmouseup.bind( this );\n        this._currentIndex = index;\n        this._tbody = tbody;\n        this._cells = cells;\n        this._affectedIndex = [];\n\n        this._scrolldivBcr = scrollDiv.getBoundingClientRect();\n        this._scrollwidth = scrollDiv.scrollWidth;\n\n        this._prevx = clientX;\n        this._originalDiv = scrollDiv;\n        this._originalDiv._sL = scrollDiv.scrollLeft;\n\n        var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),\n        rowBcr = selectedCell.parentNode.getBoundingClientRect(),\n        __dir = this._dir;\n\n        headerCells.forEach( function( cell, index, originalArray ){\n            var previousCell = ( originalArray[ index - 1 ] || {} )._bcr,\n            cellBcr = cell.getBoundingClientRect(),\n            __width = cellBcr.width;\n\n            // Feels like this calculation might not be needed. ===> Actual position( If not sticked ) and sticked positions will be different. here i am calculating Actual position. getBounding will give sticked position\n\n            if( index == 0 ){\n                if( __dir ){\n                    var __right = rowBcr.right;\n                    cell._bcr = { left : __right - __width, right : __right, width : __width };\n                } else {\n                    var __left = rowBcr.left;\n                    cell._bcr = { left : __left, right : __left + __width, width : __width };\n                }\n            } else {\n                if( __dir ){\n                    var __left = previousCell.left;\n                    cell._bcr = { left : __left - __width, right : __left, width : __width };\n                } else {\n                    var __right = previousCell.right;\n                    cell._bcr = { left : __right, right : __right + __width, width : __width };\n                }\n            }\n        });\n\n        // don't understand this part either ==> converting event client value with respect to right( in rtl )\n        \n        this._xoffset = clientX - this.rtlfunc( 'right', selectedCell._bcr, this._ww );\n\n        if( !this.data.ltPropPreventTableModify ){\n            var height = 0;\n\n            rows.every( function( row ){\n                var cell = this.get_nth_cell( row, index ),\n                cellHeight = cell.getBoundingClientRect().height;\n                height += cellHeight;\n\n                if( height < scrollTop - rowBcr.height ){\n                    return true;\n                }\n\n                 cell._translateX = 0;\n                 cells.push( cell );\n                 // may this can be this._currentEndIndex ===> its just virtual movement. So i named this as transformed index\n                 cell._transformedindex = index;\n                 cell.classList.add( 'lyteStickyTableColumnSortSelect' );\n\n                 if( height >= this._scrolldivBcr.height + scrollTop ){\n                    return false;\n                }\n                return true;\n            }.bind( this ) );\n\n            selectedCell._translateX = offleft;\n            cells.push( selectedCell );\n            selectedCell._transformedindex = index;\n        } else {\n            selectedCell._transformedindex = index;\n        }\n\n        document.addEventListener( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );\n        document.addEventListener( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );\n        this.$node.classList.add( 'lyteTableSortSelected' );\n        selectedCell.classList.add( 'lyteStickyTableColumnSortSelect' );\n        ev.preventDefault();\n\n        this.callOnSelect( selectedCell, ev, index );\n    }\n\n    isIncrement(increment, isRightEdge) {\n        return increment > 0 || ( increment == 0 && isRightEdge );\n    }\n\n    isDecrement(increment, isRightEdge) {\n        return increment < 0 || ( increment == 0 && isRightEdge === false );\n    }\n\n    getTd(cell, increment, isRightEdge) {\n        // what is transformedindex ==> while moving columns are interchanged. here transformed index is virtual new index\n        var transindex = cell._transformedindex,\n        __index = -1,\n        ori_index = this._originalIndex;\n\n        if( this.isIncrement( increment, isRightEdge ) ){\n            if( ori_index <= transindex ){\n                __index = transindex + 1;\n            } else{\n                __index = transindex;\n            }\n        } else if( this.isDecrement( increment, isRightEdge ) ) {\n            if( ori_index < transindex ){\n                __index = transindex;\n            } else {\n                __index = transindex - 1;\n            }\n        }\n\n        return this.get_nth_cell( cell.parentNode, __index );\n\n    }\n\n    findFromClosest(evt, cell) {\n        var __tags = this.data.ltPropTags,\n        closestCell = $L( evt.target ).closest( __tags.th + ', ' + __tags.td ).get( 0 );\n        if( this.isHeader( closestCell ) ){\n            var index = this.getIndex( closestCell );\n            closestCell = this.get_nth_cell( cell.parentNode, index );\n        }\n        return this.$node.contains( closestCell ) ? closestCell : undefined;\n    }\n\n    isHeader(cell) {\n        return cell && ( cell.tagName.toLowerCase() == this.data.ltPropTags.td );\n    }\n\n    isSortEnabled() {\n        return this._elem;\n    }\n\n    isMoved() {\n        return this._moved;\n    }\n\n    getIndex(cell) {\n        return Array.from( this.get_children( cell.parentNode ) ).indexOf( cell );\n    }\n\n    getClassForFake() {\n        return 'lyteTableSortHelper ' + this.data.ltPropSortDummyColumClass;\n    }\n\n    createFakeColum(cell) {\n        var __doc = document,\n        __element = __doc.documentElement,\n        originaldiv = __doc.createElement( 'div' ),\n        div = $L( originaldiv ),\n        cellObj = $L( cell ),\n        bcr = cell.getBoundingClientRect(),\n        xscroll = __element.scrollLeft,\n        yscroll = __element.scrollTop,\n        cb = \"onFakeColumnCreate\";\n\n        cellObj.data( 'sortElement', originaldiv );\n        originaldiv._bcr = { left : bcr.left, right : bcr.right, width : bcr.width };\n        originaldiv._translateX = bcr.left;\n        originaldiv._translateY = bcr.top;\n\n        div.attr( 'style', cellObj.attr( 'style' ) );\n        div.text( cell.textContent )\n            .addClass( this.getClassForFake() )\n            .data( 'relatedElement', cell )\n            .css({ \n                    height : bcr.height, \n                    width : bcr.width,\n                    left : xscroll * ( this._dir ? -1 : 1 ),\n                    top : yscroll,\n                    pointerEvents : \"none\",\n                    transform : 'translate(' + originaldiv._translateX + 'px,' + originaldiv._translateY + 'px)'\n                });\n\n\n        this.getMethods( cb ) && this.executeMethod( cb, originaldiv, cell, this.$node );\n\n        __doc.body.appendChild( originaldiv );\n        this._moved = true;\n    }\n\n    sortmousemove(ev, allowAtSame, isRightEdge) {\n        if( !this.isSortEnabled() ){\n            return;\n        }\n\n        var evt = ev,\n        ww = this._ww,\n        // maybe the rtlfunc needs a better name ==> its a old function can't change its name right now\n        clientX = this.rtlfunc( 'clientX', evt, ww ),\n        left = this.rtlfunc( 'left' ),\n        selectedCell = this._elem,\n        tbody = this.getTbody(),\n        cells = this._cells,\n\n        // don't understand the xoffset == > initial mouse position during mousedown. Increment calculated based on this\n        xoffset = this._xoffset,\n        preventable = this.data.ltPropPreventTableModify;\n\n        // evt = this.getProperEvent() ==> if touch length is more than one i need to stop the function. if i write this as additional function it again leads to write one more function. Right now i can't write this as a fucntion\n        if( /touch/i.test( ev.type ) ){\n            if( ev.touches.length > 1 ){\n                return;\n            }\n            evt = ev.touches[ 0 ];\n        }\n\n        if( preventable && !this.isMoved() ){\n            return this.createFakeColum( selectedCell );\n        }\n\n        if( this._prevx == evt.clientX && !allowAtSame ){\n            return;\n        }\n\n        window.$selectedCell = $L( selectedCell );\n\n        if( this.getMethods( 'onBeforeDrag' ) && this.executeMethod( 'onBeforeDrag', selectedCell, $selectedCell.data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex ) === false ){\n            return;\n        }\n\n        this._prevx = evt.clientX;\n\n        var fakeCell = $selectedCell.data( 'sortElement' ),\n        // won't div._bcr be present? In one type it wont present\n        bcr = preventable ? fakeCell._bcr : selectedCell._bcr,\n        increment = ( clientX - this.rtlfunc( 'right', bcr, ww ) - xoffset ),\n        is_increment = this.isIncrement( increment, isRightEdge ),\n        is_decrement = this.isDecrement( increment, isRightEdge ),\n\n        closestCell = preventable ? this.findFromClosest( evt, selectedCell ) : this.getTd( selectedCell, increment, isRightEdge ),\n\n        closestbcr = closestCell ? closestCell._bcr : {},\n\n        newone, closestCellIndex, \n\n        scrollLeft = this._originalDiv._sL,\n\n        fact = this._dir ? -1 : 1,\n\n        interchangeprevent, \n        offLeft = 0,\n        cb = 'onBeforeInterChange',\n        __affectedIndex = this._affectedIndex;\n\n        if( selectedCell == closestCell && !fakeCell ){\n            closestCell = undefined;\n        }\n\n        if( closestCell && this.isSortEnabled() ){\n            closestCellIndex = this.getIndex( closestCell );\n\n            if( closestCellIndex != this._originalIndex || preventable ){\n                var allow = false,\n                close_index = closestCell._transformedindex,\n                transindex = !isNaN( close_index ) ? close_index : closestCellIndex,\n                __limit = this.rtlfunc( 'left', closestbcr, ww ) + closestbcr.width * 0.5,\n                __transformedindex = selectedCell._transformedindex;\n\n                if( fakeCell && selectedCell == closestCell ){\n                    transindex = closestCellIndex;\n                } \n                \n                if( is_increment ) {\n                    if( this.rtlfunc( 'right', bcr, ww ) + increment > __limit ){\n                        allow = transindex > __transformedindex;\n                    }\n                } else if( is_decrement ){\n                    if( this.rtlfunc( 'left', bcr, ww ) + increment < __limit ){\n                        allow = transindex < __transformedindex;\n                        if( allow && ( closestCell._horizontalIntersectionDiv || {} )._sticked ){\n                            allow = false;\n                        }\n                    }\n                }\n                if( allow ){\n                    if( !preventable ){\n                        newone = __affectedIndex.indexOf( closestCellIndex ) == -1;\n                        if( newone ){\n                            offLeft = 0;\n                            __affectedIndex.push( closestCellIndex );\n                        }\n                    }\n                } else {\n                    closestCell = undefined;\n                }\n            }\n        } else {\n            closestCell = undefined;\n        }\n        if( closestCell && this.getMethods( cb ) ){\n            interchangeprevent = this.executeMethod( cb, ev, selectedCell, closestCell, this.$node ) === false;\n            if( interchangeprevent && newone ){\n                this.$addon.arrayUtils( __affectedIndex, 'removeAt', __affectedIndex.indexOf( closestCellIndex ) );\n            }\n        }\n\n        if( preventable ){\n            fakeCell.style.transform = 'translate( ' + ( fakeCell._translateX += ( increment * fact ) ) + 'px,' + fakeCell._translateY + 'px)';\n            if( closestCell && !interchangeprevent ){\n                if( closestCell != selectedCell ){\n                   var __fact = 0;\n                   if( is_decrement ){\n                     __fact = -1;\n                   } else if( is_increment ){\n                     __fact = 1;\n                   }\n                   selectedCell._transformedindex += __fact;\n                }\n            }\n        } else {\n            cells.forEach( function( cell, indexVal ){\n                cell.style.transform = \"translateX(\" + ( cell._translateX += ( increment * fact ) ) + \"px)\";\n                // if( !this.isSortEnabled() ){\n                    cell.classList.add( 'lyteStickyTableColumnMoving' );\n                // }\n                if( closestCell && !interchangeprevent ){\n                    var newcell = this.get_nth_cell( cell.parentNode, closestCellIndex ),\n                    __fact = 0,\n                    ___ns = '_transformedindex';\n\n                    if( newone ){\n                        newcell.classList.add( 'lyteStickyTableColumnSortAnimate' );\n                        newcell._translateX = 0;\n                    }\n                    newcell.style.transform = \"translateX(\" + ( newcell._translateX += ( bcr.width * ( this.isIncrement( increment, isRightEdge ) ? -1 : 1 ) * fact ) ) + \"px)\";\n\n                    if( newcell[ ___ns ] == undefined ){\n                        newcell[ ___ns ] = closestCellIndex;\n                    }\n\n                    if( is_decrement ){\n                        __fact = 1;\n                    } else if( is_increment ){\n                        __fact = -1;\n                    }\n\n                    newcell[ ___ns ] += __fact;\n                    cell[ ___ns ] -= __fact\n                }\n            }.bind( this ));\n        }\n\n        if( fakeCell ){\n            var __fakecell = fakeCell._bcr;\n\n            __fakecell.left += ( increment* fact );\n            __fakecell.right += ( increment * fact );\n        } else {\n            var __selected_bcr = selectedCell._bcr;\n\n            __selected_bcr.left += ( increment * fact );\n            __selected_bcr.right += ( increment * fact );\n            if( closestCell && !interchangeprevent ){\n                var close_bcr = closestCell._bcr;\n\n                close_bcr.left += ( bcr.width * ( is_increment ? -1 : 1 ) * fact );\n                close_bcr.right += ( bcr.width * ( is_decrement ? -1 : 1 ) * fact );\n            }\n        }\n        this.clearFastdom();\n\n        this.sorthorizontalscroll( { left : bcr.left, width : bcr.width, right :  bcr.right }, scrollLeft, is_increment );\n\n        if( closestCell ){\n            this.callInterChange( ev, selectedCell, closestCell );\n        }\n        this.callDrag( selectedCell, ev );\n        this._moved = true;\n    }\n\n    callInterChange(ev, selectedCell, closestCell) {\n        this.execute( 'onInterChange', ev, selectedCell, closestCell, this.$node );\n    }\n\n    callDrag(selectedCell, ev) {\n        this.execute( 'onDrag', selectedCell, $L( selectedCell ).data( 'sortElement' ), ev, this.$node, this._originalIndex, selectedCell._transformedindex );\n    }\n\n    clearFastdom() {\n        var fastdom = $L.fastdom;\n        fastdom.clear( this._reqId );\n        fastdom.clear( this._measure );\n        delete this._measure;\n        delete this._reqId;\n    }\n\n    sorthorizontalscroll(bcr, scrollLeft, isIncrement) {\n        var left = this.rtlfunc( 'left' ),\n        ww = this._ww,\n        _scrolldivBcr = this._scrolldivBcr,\n        _scrollwidth = this._scrollwidth,\n        _thisBccr = this._thisBccr,\n        _originalDiv = this._originalDiv,\n        _FF = this._FF,\n        _dir = this._dir,\n        _chrome = this._chrome,\n        _isSafari = this._isSafari,\n        isLeft = !isIncrement && ( this.rtlfunc( 'left', bcr, ww ) < Math.max( this._fixedWidth + this.rtlfunc( 'left', _scrolldivBcr, ww ), 0 ) ),\n        isRight = isIncrement && ( ( this.rtlfunc( 'left', bcr, ww ) + bcr.width ) > Math.min( this.rtlfunc( 'right', _scrolldivBcr, ww ), ww ) ),\n        selectedCell = this._elem;\n\n        if( _FF && isRight ){\n            // is this like checking if currentEndIndex is on the last node? == > firefox behaves weirdly. If we keep moving scrollwidth gradully increases. So if it reaches its end i am returning false\n\n            if( selectedCell._transformedindex == this.get_children( selectedCell.parentNode ).length - 1 ){\n                if( _dir ){\n                     // why scrollwidth + scrollleft <= widthofscrolldiv? - Firefox rtl behaviour\n                     if( _scrollwidth + window.sL <= _thisBccr.width ){\n                        return;\n                    }\n                } if( window.sL + _thisBccr.width >= _scrollwidth ){\n                    return;\n                }\n            }\n        }\n\n        var value;\n\n        if( isLeft ){\n            value = scrollLeft - this.getCrctScrollValue();\n            if( _dir ){\n                if( _chrome ){\n                    // why does this Math.min need to be taken ==> In Rtl scrollLeft value will be lower than initial value. Setting Higher value change its scroll width value automatically in rtl\n                    value = Math.min( value, _scrollwidth - _scrolldivBcr.width );\n                } else if( _FF || _isSafari ){\n                    value = Math.min( value, 0 );\n                }\n            } else {\n                value = Math.max( value, 0 );\n            }\n        } else if( isRight ){\n            value = scrollLeft + this.getCrctScrollValue();\n            if( _dir ){\n                if( _chrome ){\n                    value = Math.max( value, 0 );\n                    isRight = value != 0;\n                } else if( _FF || _isSafari ){\n                    value = Math.max( value, _scrolldivBcr.width - _scrollwidth );\n                    isRight = value != _scrolldivBcr.width - _scrollwidth;\n                } else {\n                    value = Math.min( value, _scrollwidth - _scrolldivBcr.width ); \n                    isRight = value != _scrollwidth - _scrolldivBcr.width;\n                }\n            } else {\n                value = Math.min( value, _scrollwidth - _scrolldivBcr.width );\n            }\n        } else {\n            this.clearFastdom();\n        } \n        if( isLeft || isRight ){\n            _originalDiv.scrollLeft = value;\n            var headerCells = Array.from( this.get_children( selectedCell.parentNode ) ),\n            scrollIncrement = value - scrollLeft\n\n            if( scrollIncrement ){\n\n                // why (value - sL) === > Updating my reference value without dom measure\n                _originalDiv._sL += scrollIncrement;\n\n                headerCells.forEach( cell => {\n                    cell._bcr.left -= scrollIncrement;\n                    cell._bcr.right -= scrollIncrement;\n                });\n\n                var fastdom = $L.fastdom;\n\n                this._measure = fastdom.measure( () => {\n                    delete this._measure;\n                    this._reqId = fastdom.mutate( () => {\n                        delete this._reqId;\n                        this.sortmousemove( { clientX : this._prevx }, true, isRight );\n                    });\n                });\n            }\n         }\n    }\n\n    getCrctScrollValue() {\n        return this.data.ltPropScrollStep * ( this._dir ? -1 : 1 );\n    }\n\n    swapColumnsInData(header, startIndex, endIndex) {\n        var La = this.$addon.arrayUtils,\n        current = La( header, 'removeAt', startIndex );\n        La( header, 'insertAt', endIndex, current );\n    }\n\n    swapColumnsInDom(startIndex, endIndex) {\n        this._preventCustomdelete = true;\n\n        var rows = Array.from( this.getRows() );\n\n        rows.forEach( row => {\n            this.$component[ startIndex < endIndex ? 'insertAfter' : 'insertBefore' ]( this.get_nth_cell( row, endIndex ), this.get_nth_cell( row, startIndex ) );\n        });\n        delete this._preventCustomdelete;\n    }\n\n    removeEvents(evt) {\n        var isTch = /touch/i.test( evt.type ),\n        rel = 'removeEventListener',\n        __doc = document;\n\n        __doc[ rel ]( isTch ? 'touchmove' : 'mousemove', this._sortmousemove, true );\n        __doc[ rel ]( isTch ? 'touchend' : 'mouseup', this._sortmouseup, true );\n\n        delete this._sortmouseup; \n        delete this._sortmousemove; \n    }\n\n    clearVariables() {\n        delete this._elem; \n        delete this._xoffset; \n        delete this._originalIndex; \n        delete this._moved;\n        delete this._affectedIndex; \n        delete this._tbody;\n        delete this._cells; \n        delete this._prevx; \n        delete this._scrolldivBcr; \n        delete this._ww; \n        delete this._scrollwidth;\n        delete this._originalDiv;\n    }\n\n    sortmouseup(evt) {\n        var startIndex = this._originalIndex,\n        selectedCell = this._elem,\n        endIndex = selectedCell._transformedindex;\n\n        this.resetcells();\n        if( this.isSortEnabled() ){\n            var failed,\n            header = this.getData( 'ltPropHeader' ),\n            next = this.get_nth_cell( selectedCell.parentNode, endIndex ),\n            cb = \"onBeforeDrop\",\n            failed = this.getMethods( cb ) && this.executeMethod( cb, selectedCell, next, startIndex, endIndex, header, evt ) == false;\n\n            if( !failed && startIndex != endIndex ){\n                if( header.length ){\n                    this.swapColumnsInData( header, startIndex, endIndex );\n                } else {\n                    this.swapColumnsInDom( startIndex, endIndex );\n                }\n            }\n            this._setLeftForInterSection();\n            !failed && this.callDrop( selectedCell, next, startIndex, endIndex, header, evt )\n        } else {\n            // Is onRelease a callback which gets fired when the element has not been moved? This sounds like a very special case callback. I want to know more about the use case of this\n\n            // Generally all are adding some class to selected element in mousedown and want to remove the same in mouseup. If its not moved those classes will not be removed( or they have to write that in first mousemove ). In my case too i need to call reset cells. Thats why i here provided one extra callback\n            this.callRelease( evt, selectedCell )\n        }\n\n        this.removeEvents( evt );\n        this.clearFastdom();\n        this.clearVariables();\n\n        this.$node.classList.remove( 'lyteTableSortSelected' );\n    }\n\n    removeFakeCell(selectedCell) {\n        var $node = $L( selectedCell ),\n        ns = 'sortElement',\n        div = $node.data( ns );\n        if( div ){\n          div.remove();\n          $L( div ).data( 'relatedElement', void 0 );\n        }\n        $node.data( ns, void 0 );\n    }\n\n    resetcells(cells) {\n        var affected = this._affectedIndex,\n        cells = this._cells,\n        selectedCell = this._elem;\n\n        if( this.data.ltPropPreventTableModify ){\n            this.removeFakeCell( selectedCell );\n            this.resetSingleCell( selectedCell );\n        } else {\n            cells.forEach( function( cell ){\n                var rowChildren = this.get_children( cell.parentNode );\n                this.resetSingleCell( cell );\n                 affected.forEach( function( affIndex ){\n                    this.resetSingleCell( rowChildren[ affIndex ] );\n                }.bind( this ) );\n            }.bind( this ) );\n        }\n    }\n\n    resetSingleCell(cell) {                \n        cell.style.transform = \"\";\n        cell.classList.remove( 'lyteStickyTableColumnSortSelect', 'lyteStickyTableColumnMoving', 'lyteStickyTableColumnSortAnimate' );\n        delete cell._transformedindex;\n        delete cell._translateX;\n    }\n\n    checkIntersection(arg, ignore_removal) {\n        var table = this.__table,\n        __this = table.component;\n\n        if( table.ltProp( 'stickyTable' ) && __this.data.ltPropScroll.horizontal ){\n            var __elem = this._horizontalIntersectionDiv;\n            if( arg && !__elem ){\n                __this.createIntersection.call( this, table );\n            } else if( !arg && __elem ){\n                var intersection = __elem;\n                __this.removeIntersection.call( this, intersection, table );\n                __this.removeSticky( this );\n                __this.removeFixedClass( this );\n\n                if( ignore_removal ){\n                    __this.createIntersection.call( this, table );\n                }\n            }\n        }\n    }\n\n    createIntersection(table) {\n        var div = $L( document.createElement( 'div' ) ).addClass( 'lyteIntersectionDiv' ).get( 0 );\n        table.getElementsByTagName( table.ltProp( 'tags' ).table )[ 0 ].appendChild( div );\n        this._horizontalIntersectionDiv = div;\n        div._cell = this;\n        table.component._setLeftForInterSection();\n    }\n\n    disconnectedCallback() {\n        var intersection = this._horizontalIntersectionDiv;\n        if( intersection ){\n            var table = this.__table,\n            __this = table.component;\n\n            if( table && __this._preventCustomdelete ){\n                return;\n            }\n            delete this.__table;\n            __this.removeIntersection.call( this, intersection, table );\n        }\n    }\n\n    removeIntersection(intersection, table) {\n        if( table ){\n            var ins = table.component._intersectionObs;\n            if( ins ){\n                ins.unobserve( intersection );\n            }\n        }\n        intersection.remove();\n\n        delete intersection._cell;\n        delete this._horizontalIntersectionDiv;\n    }\n\n    static observers() {\n        return {\n            stickyTable : function(){\n                var __this = this,\n                __data = __this.data;\n\n                if( __data.ltPropStickyTable ){\n                    var $node = __this.$node,\n                    scroll = __data.ltPropScroll,\n                    scrollDiv = __this.getScrollDiv();\n\n                    __this.__mixinAdded = true;\n                    $node.classList.add( 'lyteStickyTable' );\n\n                    if( scroll.horizontal ){\n                        __this.registerInterSection( scrollDiv );\n                        scrollDiv.addEventListener( 'scroll', __this.stickyScroll.bind( __this ), true );\n                    }\n\n                   $node.reset = function(){\n                        __this._setLeftForInterSection( true );\n                        if( !__this.__from_collapse ){\n                            __this.update_collapse( true );\n                        }\n                   }.bind( __this );\n\n                    __this.detectBrowsers();\n                }\n            }.on( 'didConnect' ),\n\n            setLeftForInterSection : function(){\n                if( this.data.ltPropStickyTable ){ \n                    this.$node.reset();\n                }\n            }.observes( 'ltPropContent.[]', 'ltPropHeader.[]', 'ltPropContent', 'ltPropHeader' ).on( 'didConnect' ),\n\n            bindingEvts : function(){\n               var data = this.data;\n\n               if( !data.ltPropStickyTable ){\n                   return;\n               }\n\n               var header = this.getThead();\n               if( header ){\n                   var fn,\n                   ns = \"addEventListener\";\n                   if( data.ltPropColumnSortable ){\n                       fn = ( this._sortmousedown = this.sortablemousedown.bind( this ) );\n                   } else {\n                        if( fn = this._sortmousedown ){\n                           ns = \"removeEventListener\";\n                           delete this._sortmousedown;\n                       }\n                   }\n                   if( fn ){\n                       header[ ns ]( 'mousedown', fn, true );\n                       header[ ns ]( 'touchstart', fn, true );\n                   }\n               }\n\n           }.observes( 'ltPropColumnSortable' ).on( 'didConnect' )\n        };\n    }\n}\n\nexport { LyteTableUtilsMixin };",";( function( cb ){\n\tif( typeof define == \"function\" && define.amd ){\n\t\t  define( [ \"@zoho/lyte-dom\" ], cb );\n\t  } else {\n\t\t  cb( window.$L );\n\t  }\n} )( function( $L ){\n   if( $L ) {\n    var uA = window.navigator.userAgent, \n    isSaf =  { \n        uA : uA, \n        isUbuntu : /ubuntu/ig.test( uA ), \n        isIpad : /ipad/ig.test( uA ), \n        safari : /safari/ig.test( uA ), \n        isIE11Lyte : /rv:11/ig.test( uA ), \n        isEdgeLyte : /Edge/ig.test( uA ), \n        mode : {}, \n        chrome  : !!window.chrome , \n        firefox : /firefox/ig.test( uA ) \n    };\n\n    function appendDiv( className, obj, dir, is_parent ) {\n        var div = document.createElement( 'div' ), innerDiv;\n        div.className = className;\n        div._scrolldiv = this;\n        div.style.visibility = 'hidden';\n        innerDiv = document.createElement( 'div' );\n        innerDiv.classList.add( 'lyteScrollDiv' );\n        if( obj.handlerClass ) {\n            innerDiv.classList.add( obj.handlerClass );\n        }\n        if( obj.containerClass ) {\n            div.classList.add( obj.containerClass )\n        }\n        div.appendChild(innerDiv);\n        if( dir ) {\n            innerDiv._direction = dir;\n            if( obj.horizontalContainerClass ){\n                div.classList.add( obj.horizontalContainerClass );\n            }\n            if( obj.horizontalHandlerClass ) {\n                innerDiv.classList.add( obj.horizontalHandlerClass );\n            }\n            this._horiDiv = div;\n        } else {\n            if( obj.verticalContainerClass  ) {\n                div.classList.add( obj.verticalContainerClass );\n            }\n            if( obj.verticalHandlerClass ){\n                innerDiv.classList.add( obj.verticalHandlerClass );\n            }\n            this._vertDiv = div;\n        }\n\n        ( is_parent ? this.parentElement : this ).appendChild( div )\n        \n        div.addEventListener( 'click', outerDivClick, true );\n        innerDiv.addEventListener( 'mousedown', innerDivClick );\n        if( !this._infiniteScroll ){        \n            innerDiv.addEventListener( 'touchstart', innerDivClick );       \n        }\n        return div;\n    }   \n\n    function set( elem, prop, val ) {\n        if( elem.style[ prop ] != val ){\n            elem.style[ prop ] = val\n        }\n    }\n\n    function checkscrollable( evt ){\n        evt = evt || { target : this };\n        var target = evt.target.correspondingElement || evt.target, ret;\n\n        if( target.closest( '.lyteConnectWrapper.preventWheel' ) ){\n            return true;\n        }\n        \n        while( target && target != this ) {\n            if( target.classList.contains( 'preventWheel' ) ) {\n                ret = true;\n                break;\n            }\n            target = target.parentElement\n        }\n        return ret\n    }\n\n    function check( flag, elem, obj, mode, evt ){\n        var fg;\n        evt = evt || {};\n\n        window.fn = function( elem ){\n            set( elem, 'visibility', 'hidden' );\n            elem.classList.remove( 'visible' );\n        };\n\n        if( !flag.scroll ) {\n            var is_showon_scroll = this._scrollData.showOn == 'scroll';\n            if( !( [ 'mouseenter', 'touchstart' ].indexOf( evt.type ) != -1 && is_showon_scroll ) ){\n                var from_reset = ( this._enableScroll = !flag.frm_reset ),\n                is_event_added = $L( this ).hasClass( \"eventBinded\" );\n\n                if( elem && ( !is_showon_scroll || !flag.frm_reset ) ) {\n                    clearTimeout( elem._entertimeout );\n                    clearTimeout( elem._leavetimeout );\n                    delete elem._entertimeout; delete elem._leavetimeout;\n                    if( !flag.scrollbar ){\n\n                        if( !from_reset && !is_event_added ){\n                            return;\n                        }\n\n                        if( evt.type == \"touchstart\" ){\n                            elem._entertimeout = setTimeout( set.bind( this, elem, 'visibility', 'visible' ), 150 );\n                        } else {\n                            set( elem, 'visibility', 'visible' );\n                        }\n                        elem.classList.add( 'visible' );\n                        updatePos.call( this, mode, undefined, {}, obj );\n                    } else{\n                        window.fn( elem );\n                    }\n                }\n            }\n            fg = true\n        } else {\n            if( elem ) {\n               window.fn( elem );\n            }\n        }\n        return fg\n    }\n\n    function initialWheel( evt ){\n        this.removeEventListener( 'wheel', initialWheel, true )\n        if( !this.classList.contains( 'eventBinded' ) ){\n            var close_connect = this.closest( \"lyte-connect\" );\n            if( !close_connect ){\n                mouseenter.call( this, { type : 'mouseenter' } );\n            }\n        }\n        evt.preventDefault()\n    }\n\n    function format_bcr( bcr ){\n        var obj = {};\n        [ 'x', 'y', 'bottom', 'height', 'top', 'width', 'left', 'right' ].forEach( function( item ){\n            obj[ item ] = Math.round( bcr[ item ] );\n        });\n        return obj;\n    }\n\n    function mouseenter( evt, frm_reset ) {\n        // console.log( evt.target, evt.type, evt.currentTarget );\n        if( this.classList.contains( 'eventBinded' ) && evt != true ){\n            return\n        }\n        if( evt.type == 'mouseenter' && this._prtmseenr ){\n            return;\n        }\n        var flag, \n        obj = { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) },\n        scrolldata = this._scrollData;\n\n        this._wheelObj = obj\n        if( this.classList.contains( 'lyteTableScroll' ) ){\n            forTable.call( this, obj )\n        }\n        this._direction = window.getComputedStyle(  this ).direction;\n        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}\n        obj.horbcr = this._horiDiv ?  this._horiDiv.getBoundingClientRect() : {}\n        flag = check.call( this, fitForScroll.call( this, true, obj, frm_reset ), this._vertDiv, obj, true, evt )\n        flag = check.call( this, fitForScroll.call( this, false, obj, frm_reset ), this._horiDiv, obj, false, evt ) || flag\n        if( flag && evt ) {\n            this._mouseleave = this._mouseleave || mouseleave.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this );\n            if( evt.type == \"touchstart\" ) {\n               if( evt.touches.length == 1 ){\n                    clearTimeout( this._tchtime );\n                    document.addEventListener( 'touchcancel', this._mouseleave, true )\n                } else {\n                    return;\n                }\n            } else {\n                this.addEventListener( 'wheel', wheelEvent, true );\n                this.addEventListener('keydown', keydownFunc, true);\n                if( this._scrollData.showOn == 'scroll' ){\n                    this.addEventListener( 'mousemove', hideScrollbar, true );\n                }\n            }\n            this._allowTouch = true;\n            document.addEventListener( 'touchend', this._mouseleave, true )\n            this.classList.add( 'eventBinded' )\n            this._tabindex = this._tabindex == undefined ? this.tabIndex : this._tabindex;\n            if(this.tabIndex == -1){\n                this.tabIndex = scrolldata.tabIndex || 0;\n            }\n        }\n    } \n\n    function keydownFunc( evt ) {\n        if( evt.target != this ){\n            return\n        }\n\n        var key = evt.key,\n        elem = this,\n        sL =  Math.round( elem.scrollLeft ),\n        sT = Math.round( elem.scrollTop ),\n        wd = elem.offsetWidth,\n        hgt = elem.offsetHeight,\n        s_wd = elem.scrollWidth,\n        s_hgt = elem.scrollHeight,\n        obj = { \n            scrollLeft : sL, \n            scrollTop : sT, \n            scrollWidth : s_wd, \n            scrollHeight : s_hgt, \n            bcr : elem.getBoundingClientRect() \n        },\n        step = this._scrollData.keyStep,\n        dir = this._direction == 'rtl',\n        pos,\n        mode,\n        __new,\n        is_negative = dir && ( !window._lyteUiUtils || window._lyteUiUtils.isNegativeScroll() ),\n        meta = evt.metaKey || evt.ctrlKey;\n\n        switch( key ){\n            case \"ArrowLeft\" : {\n                mode = false;\n\n                if( meta ){\n                    if( dir ){\n                        if( is_negative ){\n                            __new = wd - s_wd;\n                        } else {\n                            __new = s_wd - wd;\n                        }\n                    } else {\n                        __new = 0;\n                    }\n                } else {\n                    if( dir && is_negative ){\n                        dir = false;\n                    }\n                    __new = sL - step * ( dir ? -1 : 1 );\n                }\n            }\n            break;\n            case \"ArrowRight\" : {\n                mode = false;\n                \n                if( meta ){\n                    if( dir ){\n                        if( is_negative ){\n                            __new = 0;\n                        } else {\n                            __new = wd - s_wd;\n                        }\n                    } else {\n                        __new = s_wd - wd;\n                    }\n                } else {\n                    if( dir && is_negative ){\n                        dir = false;\n                    }\n                    __new = sL + step * ( dir ? -1 : 1 );\n                }\n            }\n            break;\n            case \"ArrowDown\" : {\n                __new = Math.min( sT + step, s_hgt - hgt );\n                mode = true;\n            }\n            break;\n            case \"ArrowUp\" : {\n                __new = Math.max( 0, sT - step );\n                mode = true;\n            }\n            break;\n            case \"PageDown\" : {\n                __new = Math.min( sT + hgt, s_hgt - hgt );\n                mode = true;\n            }\n            break;\n            case \"PageUp\" : {\n                __new = Math.max( sT - hgt, 0 );\n                mode = true;\n            }\n            break;\n            case \"Home\" : {\n                __new = 0;\n                mode = true;\n            }\n            break;\n            case \"End\" : {\n                __new = s_hgt - hgt;\n                mode = true;\n            }\n            break;\n        }\n\n        if( mode != void 0 && shouldPrevent.call( elem, obj, mode, __new - ( mode ? sT : sL ) ) ){\n            elem[ mode ? 'scrollTop' : 'scrollLeft' ] = __new;\n            scroll.call( elem, evt )\n            evt.preventDefault();\n        }\n    }\n\n    function mouseleave( evt ){\n        evt = evt || {};\n        if( ( evt.relatedTarget && this.contains( evt.relatedTarget ) ) || document._scrollmouseup ){\n            return\n        }\n        if( evt.type == 'touchend' ) {     \n            var tar = evt.target.correspondingElement || evt.target;        \n            if( tar && tar.classList.contains( 'lyteScrollContainer' ) ) {      \n                return;     \n            }       \n        }\n        var bars = $L( this ).children( '.lyteScrollContainer' ), scrlDiv = this._scrolldiv || this;\n        if( bars.length ) {\n            for(  var i = 0; i < bars.length; i++ ) {\n                var __cur_bar = bars[ i ];\n\n                clearTimeout( __cur_bar._entertimeout );\n                clearTimeout( __cur_bar._leavetimeout );\n                delete __cur_bar._entertimeout;\n                delete __cur_bar._leavetimeout;\n\n                __cur_bar.classList.remove( 'visible' )\n                if( evt.type == 'touchend' ){\n                    __cur_bar._leavetimeout = setTimeout( set.bind( this, __cur_bar, 'visibility', 'hidden'), 150 )\n                } else {\n                    __cur_bar.style.visibility = 'hidden';\n                }\n            }\n            if( evt.type == 'mouseleave' ) {\n                scrlDiv.removeEventListener('wheel', wheelEvent, true);\n                scrlDiv.removeEventListener('keydown', keydownFunc, true);\n                scrlDiv.removeEventListener( 'mousemove', hideScrollbar, true );\n                scrlDiv.addEventListener( 'wheel', initialWheel, true );\n            } else if( evt.type == 'touchend' || evt.type == \"touchcancel\" ) {\n                scrlDiv._prtmseenr = true;\n                scrlDiv._tchtime = setTimeout( function(){\n                    delete scrlDiv._prtmseenr;\n                }, 500 )\n                document.removeEventListener( 'touchcancel', scrlDiv._mouseleave, true )\n            }\n            if( evt.type ){\n                document.removeEventListener( 'touchend', scrlDiv._mouseleave, true )\n                delete scrlDiv._allowTouch;\n                scrlDiv.classList.remove( 'eventBinded' );\n                // scrlDiv.tabIndex = this._scrolldiv._tabindex;\n                // delete scrlDiv._tabindex;\n                 delete scrlDiv._wheelObj;\n                delete scrlDiv._prevPosY; delete scrlDiv._mouseleave;\n                delete scrlDiv._prevPosX; delete scrlDiv._wheelEvt;\n            }\n            delete scrlDiv._enableScroll;\n        }\n    }\n\n    function outerDivClick( evt ) {\n        if( !this.classList.contains( 'visible' ) ){\n            return\n        }\n        var isTch = evt.type == \"touchmove\";       \n        if( isTch ) {       \n            if( evt.touches.length > 1 ){       \n                return;     \n            } else {        \n                evt.preventDefault();       \n                evt = evt.touches[ 0 ]      \n            }       \n        }       \n        var elem = this._scrolldiv, mode, inn = this.children[ 0 ], outBcr = this.getBoundingClientRect(), inBcr = inn.getBoundingClientRect(),\n        obj = { scrollLeft : Math.round( elem.scrollLeft ), scrollTop : Math.round( elem.scrollTop ), scrollWidth : elem.scrollWidth, scrollHeight : elem.scrollHeight, bcr : elem.getBoundingClientRect() },\n        hgt = 'width', top1 = 'left', sT = 'scrollLeft', sH = 'scrollWidth', bt = 'right', cY = 'clientX';\n        if( this.classList.contains( 'lyteTableScroll' ) && !obj.$nodeClient ){\n            forTable.call( this, obj )\n        }\n        obj.vertbcr = this._vertDiv ?  this._vertDiv.getBoundingClientRect() : {}\n        obj.horbcr = this._vertDiv ?  this._horiDiv.getBoundingClientRect() : {}\n        if(!inn._direction){\n            mode = true;\n            hgt = 'height', top1 = 'top', sT = 'scrollTop', sH = 'scrollHeight', bt = 'bottom', cY = 'clientY';\n        }\n        var scramt = evt.type != 'click' ? ( evt[ cY ] - ( this.prev || evt[ cY ] ) ) : ( evt[ cY ] - ( inBcr[ top1 ] + inBcr[ hgt ] / 2 ) ), newsL;\n        newsL = ( scramt / ( obj.bcr[ hgt ] + obj.bcr[ top1 ] - outBcr[ top1 ] ) * obj[ sH ] )\n        elem[ sT ] += ( newsL ) ;\n        scroll.call( elem, evt );\n        this.prev = evt[ cY ];\n    }\n\n    function innerDivClick( evt ) {\n       var isTch = evt.type == \"touchstart\",\n       __parentNode = this.parentNode,\n       __document = document,\n       ael = 'addEventListener';\n\n        __document[ ael ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove = outerDivClick.bind( __parentNode ), true );\n        __document[ ael ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup = mouseup.bind( __parentNode ), true );\n\n        evt.preventDefault();\n        evt.stopPropagation();\n    }\n\n    function mouseup( evt ) {\n        var isTch = evt.type == \"touchend\",\n        __document = document,\n        rel = \"removeEventListener\",\n        scroll_elem = this._scrolldiv || this,\n        target = evt.target,\n        scrolldata = scroll_elem._scrollData;\n\n        __document[ rel ]( isTch ? 'touchmove' : 'mousemove', __document._scrollmousemove, true );\n        __document[ rel ]( isTch ? 'touchend' : 'mouseup', __document._scrollmouseup, true );\n\n        delete __document._scrollmousemove;\n        delete __document._scrollmouseup; \n        delete this.prev;\n\n        if( !scroll_elem.contains( target.correspondingElement || target ) && scrolldata.showOn != 'always' ){\n            mouseleave.call( scrolldata.appendTo == \"parent\" ? scroll_elem.parentNode : scroll_elem , { type : 'mouseleave' } );\n        }\n    }\n\n    function mousedown( evt ) {\n\n        var scrolldata = this._scrollData,\n        __document = document;\n\n        if( __document._scrollmouseup ) {\n            return\n        }\n        __document.addEventListener( 'mouseup', __document._scrollmouseup = mouseup.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this ), true )\n    }\n\n    function fitForScroll( mode, obj, frm_reset ) {\n        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv,\n        scrolldata = this._scrollData,\n        margin = scrolldata.scrollYMarginOffset;\n\n        if( !mode ) {\n            sL = 'scrollLeft', sW = 'scrollWidth', wd = 'width';\n            margin = scrolldata.scrollXMarginOffset;\n        }\n        if( obj[ sL ] + obj.bcr[ wd ] >= obj[ sW ] && obj[ sL ] == 0 ){\n            if( elem && elem.classList.contains( 'visible' ) ) {\n                check.call( this, { scroll : true, scrollbar : true }, elem )\n            }\n            return {\n                scroll : true,\n                scrollbar : true,\n                frm_reset : frm_reset\n            }\n        }\n\n        return{\n            scroll : false,\n            scrollbar : ( obj[ sW ] - obj.bcr[ wd ] ) <= margin,\n            frm_reset : frm_reset\n        }\n    }\n\n    function wheelEvent( evt ){\n         if( checkscrollable.call( this, evt ) ) {\n                return\n            }\n        if( evt.type == 'touchmove' ) { \n            if( this._allowTouch && evt.touches.length == 1 ) {\n                var curr = evt.touches[ 0 ];\n                wheelEvent1.call( this, evt, [ (this._prevPosX || curr.clientX ) - curr.clientX,  ( this._prevPosY || curr.clientY ) - curr.clientY ] )\n                this._prevPosY = curr.clientY;\n                this._prevPosX = curr.clientX;\n            }\n        } else {   \n            wheelEvent1.call( this, evt )\n        }\n    }\n\n    function shouldPrevent( obj, mode, val ){\n        var sL = 'scrollTop', sW = 'scrollHeight', wd = 'height', elem = mode ? this._vertDiv : this._horiDiv;\n        if( !mode ) {\n            sL = 'scrollLeft';\n            sW = 'scrollWidth';\n            wd = 'width';\n        }\n\n        if( mode ){\n            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && obj[ sL ] == 0 ) ){\n                return false\n            }\n        } else {\n            if( ( val > 0 && Math.round( obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) || ( val < 0 && Math.round( -obj[ sL ] + obj.bcr[ wd ] ) >= obj[ sW ] ) ){\n                return false\n            } else if( !mode && isSaf.firefox && this._direction == 'rtl' && ( val < 0 && obj[ sL ] == 0 ) ){\n                return true\n            } else if( ( val < 0 && obj[ sL ] == 0 ) && !( val < 0 && isSaf.safari && this._direction == 'rtl' && obj[ sL ] == 0 ) ){\n                return false;\n            }\n        }\n        return true\n    }\n\n    function getWheel( evt ) {\n        var data = this._scrollData, min = data.min, max = data.max,\n        fact1 = data.wheelSpeed, fact = fact1, uA = isSaf.uA.toLowerCase(), inf = this._infiniteScroll, ie = isSaf.isIE11Lyte;\n        if( ( uA.indexOf('edge') != -1 || (( uA.indexOf('trident') != -1 || uA.indexOf('msie') != -1)) ) && this._direction == 'rtl' ){\n            fact1 *= -1\n        }\n        // if( evt.shiftKey ) {\n        //     fact1 *= -1; fact *= -1; \n        // }\n        var x, \n        y, \n        delta = evt.deltaMode && evt.deltaMode == 1,\n        __deltaX = evt.deltaX,\n        __deltaY = evt.deltaY;\n\n        if( evt.shiftKey ){\n            var __temp = __deltaX;\n            __deltaX = __deltaY;\n            __deltaY = __temp;\n        }\n\n        if( __deltaX > 0 ) {\n            x = Math.max( delta ? ( __deltaX * 6 ) :  __deltaX, (inf ? 0 : 4 ) )\n        } else if( __deltaX < 0 ) {\n            x = Math.min( inf ? 0 : -4, delta ? ( __deltaX * 6 ) : __deltaX )\n        }\n        if( __deltaY > 0 ) {\n            y = Math.min( max, Math.max( delta ? ( __deltaY * 6 ) : __deltaY, inf ? 0 : 4 ), ie ? 20 : Infinity );\n        } else if( __deltaY < 0 ) {\n            y = Math.max( min, Math.min( inf ? 0 : -4, delta ? ( __deltaY * 6 ) : __deltaY ), ie ? -20 : -Infinity );\n        }\n        return [ x * fact1, y * fact ]\n    }\n\n    function nestedScroll( evt, ret ){  \n        var target = evt.target;\n        while( target != this ) {\n            var sT = Math.round( target.scrollTop ),\n            sH = target.scrollHeight,\n            oH = target.offsetHeight,\n            compsty = window.getComputedStyle( target ),\n            isMatch = ( /scroll|auto/i.test( compsty.overflowY ) || ( target.classList.contains( 'lyteScrollBar' ) && /hidden/i.test( compsty.overflowY  ) ) );\n\n\n            if( oH < sH  ){\n                if( ret ){\n                    if( oH + sT < sH && isMatch ){\n                        return true;\n                    }\n                } else {\n                    if( sT && isMatch ){\n                        return true;\n                    }\n                }\n            }\n            target = target.parentNode;\n        }\n    }\n\n    function wheelEvent1( evt, tch ) {            \n        var ret = tch || getWheel.call( this, evt );\n        var a = ret[ 0 ] || 0, \n        b = ret[ 1 ] || 0, \n        mode = false, \n        obj = this._wheelObj || {} , \n        fit, \n        stpre, \n        isTable = this.classList.contains( 'lyteTableScroll' ),\n        __deltaX = evt.deltaX,\n        __deltaY = evt.deltaY,\n        scrolldata = this._scrollData;\n\n        if( evt.shiftKey ){\n            var __temp = __deltaX;\n            __deltaX = __deltaY;\n            __deltaY = __temp;\n        }\n\n        if( Math.abs( tch ? a : ( __deltaX || 0 ) ) <= Math.abs( tch ? b : ( __deltaY || 0 ) ) ) {\n            mode = true\n        }\n        if( scrolldata.nested && mode && nestedScroll.call( this, evt, b > 0 ) ){\n            return;\n        }\n\n        if( scrolldata.showOn == 'scroll' ){\n            if( !this._enableScroll ){\n                mouseenter.call( this, true )\n                evt.preventDefault();\n                return\n            }\n            clearTimeout( this._scrollplugin )  \n            this._scrollplugin = setTimeout(mouseleave.bind( scrolldata.appendTo == \"parent\" ? this.parentElement : this, {} ), scrolldata.tOut )\n        }\n\n        if( this._scrollEnd ) {\n            obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : format_bcr( this.getBoundingClientRect() ) };\n            this._wheelObj = obj\n            if( this.classList.contains( 'lyteTableScroll' ) ){\n                forTable.call( this, obj )\n            }\n        }\n        if( this._wheelObj ){\n            fit = fitForScroll.call( this, mode, obj );\n            if(( fit.scroll && mode /*&& b > 0*/ && (  !this._vertDiv || ( this._vertDiv && !this._vertDiv.classList.contains( 'visible' ) ) ) ) || ( fit.scroll && !mode /*&& a < 0*/ && ( !this._horiDiv || ( this._horiDiv && !this._horiDiv.classList.contains( 'visible' ) ) ) ) ){\n                return\n            }\n            stpre = shouldPrevent.call( this, obj, mode, mode ? b : a ); \n\n\n            var is_inf = this._infiniteScroll,\n            is_stopped = is_inf ? this.comp._stopScroll : false;\n\n            if( ( is_inf && b > 0 ) || stpre ){\n                 evt.preventDefault();\n                if( !stpre && isTable && mode ) {\n                    this.comp.scrollTable.call( this.comp, { yScroll : b }, this._wheelObj )\n                }\n            } else{\n                if( scrolldata.preventOnEnd ){\n                    evt.preventDefault();\n                }\n                return\n            }\n        }\n        if( mode ) {\n            if( isSaf.isIE11Lyte ) {\n                if( this._wheelObj ){\n                    this._wheelObj.scrollTop = Math.max( Math.min( this._wheelObj.scrollTop + b, this._wheelObj.scrollHeight - this._wheelObj.bcr.height ), 0 )\n                    if(  isTable ) {\n                        evt.yScroll = b;\n                        this.comp.scroll.call( this, evt )\n                    }\n                    this.scrollTop += b;\n                } \n            } else if( !isSaf.isIE11Lyte ) {\n                this.scrollTop += b;\n            }\n        } else {\n             if( isSaf.isIE11Lyte ) {\n                if( this._wheelObj ) {\n                    this._wheelObj.scrollLeft = Math.max( Math.min( this._wheelObj.scrollLeft + a, this._wheelObj.scrollWidth - this._wheelObj.bcr.width ), 0 )\n                    if(  isTable ) {\n                        evt.xScroll = a;\n                        this.comp.scroll.call( this, evt )\n                    }\n                    this.scrollLeft += a;\n                }\n            } else {\n               this.scrollLeft += a; \n            }\n         }   \n        if( isSaf.safari || isSaf.isIE11Lyte || isSaf.isIpad ) {\n                this._alive = true;\n                clearTimeout( this._alivetime )\n                this._alivetime = setTimeout( function(){\n                   delete this._alive; delete this._alivetime; \n                }.bind( this ), 16 )\n            this._scrollFun.call( this, evt )\n        }\n\n\n        // if( this.comp ){\n        //     clearTimeout( this._overlay.time );\n        //     !this._overlay.classList.contains( 'lytescrolling' ) && this._overlay.classList.add( 'lytescrolling' );\n        //     this._overlay.time = setTimeout( function(){\n        //         this._overlay.classList.remove( 'lytescrolling' );\n        //         delete this._overlay.time;\n        //     }.bind( this ), 250 ) \n        // }\n    }\n\n    function scroll( evt ) {\n        var a, b, issafIE = isSaf.isIE11Lyte || isSaf.safari || isSaf.isIpad, isIe = isSaf.isIE11Lyte ;\n        if( issafIE && evt && evt.type == 'scroll' && ( this._alive && !evt._byFunc ) ) {\n            trigEvt.call( this, isSaf.mode.a, isSaf.mode.b, this._wheelObj || { bcr : {} }, evt )\n        } else{\n            var obj= { scrollLeft : Math.round( this.scrollLeft ), scrollTop : Math.round( this.scrollTop ), scrollWidth : this.scrollWidth, scrollHeight : this.scrollHeight, bcr : this.getBoundingClientRect() };\n            this._wheelObj = obj\n            if( this.classList.contains( 'lyteTableScroll' ) ){\n                forTable.call( this, obj )\n            }\n            if( this.prevScrlLeft != obj.scrollLeft ) {\n                a = obj.scrollLeft - ( this.prevScrlLeft || 0 );\n                b = 0;\n                updatePos.call( this, false, a , evt, obj )\n            } \n            if( this.prevScrlTop!= obj.scrollTop ) {\n                b = obj.scrollTop - ( this.prevScrlTop || 0 );\n                a = 0;\n                updatePos.call( this, true, b , evt, obj )\n            }\n            isSaf.mode.b = b; isSaf.mode.a = a;\n            if( !isIe || ( issafIE && ( !this._alive || evt._byFunc ) ) ) {\n               if(  this.classList.contains( 'lyteTableScroll' ) ) {\n                    this.comp.scroll.call( this, evt )\n                }\n            }\n        }\n    }\n\n     function hideScrollbar( evt ) {\n        clearTimeout( this._scrollplugin );  \n        this._scrollplugin = setTimeout( mouseleave.bind( this._scrollData.appendTo == \"parent\" ? this.parentElement : this ), 500 );\n    }\n\n    function forTable( obj ) {\n        var component =  this.comp, headerList = component.$node.getElementsByTagName( 'lyte-th' )\n        if( this._infiniteScroll ){\n            obj.$nodeClient = this.parentElement.getBoundingClientRect();\n            var dummy =  this.getElementsByClassName( 'lytePreventInfiniteScroll' );\n            obj.neglected = [];\n            for( var m = 0; m < dummy.length; m++ ) {\n                if( /*isVisible( dummy[ m ] )*/ !dummy[ m ].classList.contains( 'lyteHidden' ) ) {\n                    obj.neglected.push( dummy[ m ] );\n                }\n            }\n\n            obj.compNeg = dummy;\n            if( this.comp._top != undefined ) {\n                obj.topElem = [];\n                var body = this.getElementsByTagName( 'lyte-tbody' )[ 0 ],\n                another = body.getElementsByTagName( 'lyte-tr' );\n                for( var n = 0; n < another.length; n++ ) {\n                    if( !another[ n ].classList.contains( 'dummy' ) ) {\n                        obj.topElem.push( another[ n ] );\n                    }\n                }\n                obj.topElem = obj.topElem[ this.comp._top + obj.compNeg.length ]\n                obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};\n                obj.bottmElem = body.querySelector( 'lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length ) ) + ')' );\n                obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}\n                obj.tbody = body\n                obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};\n            }\n        }\n        obj.scrollDivClient = obj.bcr;\n        for(var k = 0; k < headerList.length; k++)\n            {\n                headerList[k].property = headerList[k].getBoundingClientRect();\n                headerList[k].order = k\n            }\n        obj.calculated = true;  \n    }\n\n    function trigEvt( a, b, obj, evt ) {\n        delete this._scrollEnd; \n\n        var offset = this._scrollData.offset,\n        __direction = this._direction == \"rtl\";\n\n        if( ( ( Math.ceil( obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) && !( __direction && isSaf.chrome ) ) || ( ( isSaf.firefox || isSaf.safari ) && __direction && ( Math.ceil( -obj.scrollLeft + obj.bcr.width + offset.x ) >= obj.scrollWidth ) ) || ( __direction && isSaf.chrome &&  obj.scrollLeft == offset.x ) ) {\n            evt.horiScrollEnd = true;\n        }\n        if( Math.ceil( obj.scrollTop + obj.bcr.height + offset.y ) >= obj.scrollHeight ) {\n            this._scrollEnd = evt.vertScrollEnd = true;\n        }\n        evt.yScroll = b; evt.xScroll = a;\n        evt._byPlugin = true;\n        this._wheelObj = obj;\n    }\n\n    function updatePos( mode, a, evt, obj ){\n        var __this = this,\n        __vert = __this._vertDiv,\n        __hori = __this._horiDiv;\n\n        if( parseInt( Math.abs( a ) ) == 0 || ( mode && !__vert ) ||( !mode && !__hori ) ){\n            return;\n        }\n\n        var __out = mode ? __vert : __hori,\n        rail_bcr = obj[ ( mode ? 'vert' : 'hori' ) + 'bcr' ] || __out.getBoundingClientRect(),\n        __inn = __out.children[ 0 ],\n        sL = \"scrollTop\",\n        sW = \"scrollHeight\",\n        wd = \"height\",\n        lt = \"top\",\n        direction = __this._direction == \"rtl\",\n        btm = \"bottom\",\n        __scrolldata = __this._scrollData,\n        __bcr = obj.bcr,\n        is_container = __scrolldata.appendTo != \"parent\",\n        top_offset = mode ? ( __scrolldata.topOffset || 0 ) : 0;\n\n        if( is_container ){\n            rail_bcr = __bcr;\n        }\n\n        if( !mode ){\n            sL = \"scrollLeft\";\n            sW = \"scrollWidth\";\n            wd = \"width\";\n            lt = \"left\";\n        }\n\n        var __width = __bcr[ wd ],\n        rail_bcr_lt = rail_bcr[ lt ],\n        __rt = ( __width - ( rail_bcr_lt + top_offset - __bcr[ lt ] ) ) / obj[ sW ],\n        trt = obj[ sL ] / obj[ sW ],\n        mL = __scrolldata.minLength,\n        minLength = mL ? ( mL != \"auto\" ? mL : 0 ) : 0.1 * __width,\n        __final;\n\n        set( __inn, wd, Math.max( __rt * __width, minLength ).toFixed( 3 ) + 'px' );\n\n        if( direction && __inn._direction ){\n            if( ( isSaf.safari && (  window._lyteUiUtils.isNegativeScroll() || !window.chrome ) ) || isSaf.firefox ) {\n                __final =  ( ( obj[ sL ] / obj[ sW ] * 100 )  * obj.bcr[ wd ] / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );;\n            } else {\n                __final =  ( ( -( obj[ sW ] - __width - obj[ sL ] ) / obj[ sW ] * 100 ) * __width / parseFloat( Math.max( __rt * __width, minLength ).toFixed( 3 ) ) );\n            }\n            __final = 'translateX(' + __final + '%)';\n        } else {\n            __final = ( mode ? 'translateY' : 'translateX' ) + '(' + trt * ( __width - ( rail_bcr_lt - __bcr[ lt ] ) - ( Math.max( 0, minLength - __rt * __width ) ) ) + 'px)';\n        }\n\n        set( __inn, 'transform', __final );\n\n        if( is_container ){\n            set( __out, wd, __width + 'px' );\n\n            var __other_elem = mode ? __hori : __vert,\n            __to_set = 'translate' + '(' + obj.scrollLeft + 'px,' + obj.scrollTop + 'px)';\n\n            set( __other_elem, 'transform', __to_set );\n            set( __out, 'transform', __to_set );\n        }\n\n        __this.prevScrlLeft = obj.scrollLeft; \n        __this.prevScrlTop = obj.scrollTop;\n\n        if( evt.type ){\n            trigEvt.call( __this, mode ? 0 : a, mode ? a : 0, obj, evt );\n        }\n    }\n\n    function removeScroll(){\n        var elements = this;\n        for( var i = 0; i < elements.length; i++ ) {\n            var elem = elements[ i ], wrap = elem.parentElement;\n            if( !wrap ){\n                continue;\n            }\n\n            var scrolldata = elem._scrollData;\n\n            if( scrolldata ) {\n\n                if( scrolldata.appendTo != \"parent\" ){\n                    wrap = elem;\n                }\n\n                delete elem._scrollData;\n            }\n            var scrollDivs = wrap.querySelectorAll( 'div.lyteScrollContainer' );\n            for(var k = 0; k < scrollDivs.length; k++){\n                if( scrollDivs[k].parentElement == wrap ) {\n                    delete scrollDivs[ k ]._entertimeout;\n                    delete scrollDivs[ k ]._leavetimeout;\n                    wrap.removeChild(scrollDivs[k]);\n                }\n            }\n            elem.classList.remove( 'lyteScrollBar', 'eventBinded' );\n            elem.removeEventListener( 'mouseenter', mouseenter, true );\n            elem.removeEventListener( 'wheel', initialWheel, true );\n            elem.removeEventListener( 'touchstart', mouseenter, true )\n            wrap.removeEventListener( 'mouseleave', mouseleave, true );\n            elem.removeEventListener( 'mousedown', mousedown );\n            elem.removeEventListener( 'touchmove', wheelEvent, { passive : false } )\n            elem.removeEventListener( 'scroll', scroll, true );\n            clearTimeout( elem._tchtime );\n            if( elem._mouseleave ){\n                document.removeEventListener( 'touchcancel', elem._mouseleave, true );\n                document.removeEventListener( 'touchend', elem._mouseleave, true );\n            }\n            delete elem._wheelObj; delete elem._vertDiv; delete elem._horiDiv;\n            delete elem._scrollFun; delete elem._alivetime; delete elem._alive; delete elem._wheelObj;\n            delete elem.resetScrollbar; delete wrap._scrolldiv; delete elem._tchtime;\n            delete elem._allowTouch;\n            elem.classList.remove( 'eventBinded' );\n            elem.tabIndex = elem._tabindex;\n            delete elem._tabindex; delete elem._wheelObj;\n            delete elem._prevPosY; delete elem._mouseleave;\n            delete elem._prevPosX; delete elem._wheelEvt;\n        }\n        return this;\n    }\n\n    function destroy(){\n        $L( '.lyteScrollBar' ).scroll( 'destroy' );\n        window.removeEventListener('scroll', globalscroll, true ); \n        return this; \n    }\n\n    function reset(){\n        var elements = this;\n        for( var i = 0; i < elements.length; i++ ){\n            var __elems = elements[ i ],\n            data = __elems._scrollData;\n\n            if( data ){\n                if( data.appendTo != \"parent\" ){\n                    var obj = {\n                        transform : \"\",\n                        width : \"\",\n                        height : \"\"\n                    };\n                    \n                    $L( __elems._horiDiv ).css( obj );\n                    $L( __elems._vertDiv ).css( obj );\n                }\n               __elems.resetScrollbar( true, true );\n            }\n        }\n        return this;\n    }\n\n    $L.prototype.removeScroll = function(){\n        // console.warn( 'removeScroll deprecated. Use scroll(\"destroy\") instead' );\n        return removeScroll.call( this );\n    }\n\n    $L.prototype.scroll = function( obj ) {\n        if( obj && obj.constructor == String ){\n            if( obj == \"destroy\" ){\n                return removeScroll.call( this );\n            } else if( obj == \"destroyScroll\" ){\n                destroy.call( this );\n            } else if( obj == \"reset\" ){\n                reset.call( this );\n            }\n            return;\n        }\n\n        var fn = function( obj, name, _default ){\n            var value = obj[ name ];\n            if( value == void 0 ){\n                value = _default;\n            }\n            obj[ name ] = value;\n        };\n\n        obj = obj || {};\n        obj.showOn = obj.showOn || 'hover';\n        obj.keyStep = obj.keyStep || 30;\n        obj.wheelSpeed = obj.wheelSpeed || 1;\n        // its a major change. to ensure same behaviour of normal scroll and to overcome issue in browser zoomed state changed this to false\n        fn( obj, 'preventOnEnd', false );\n        obj.offset = obj.offset || { x : 0, y : 0 };\n        obj.tOut = obj.scrollTimeout || 500;\n        obj.nested = obj.nested || false;\n        obj.min = obj.min || -Infinity;\n        obj.max = obj.max || Infinity;\n\n        obj.appendTo = obj.appendTo || \"parent\";\n\n        fn( obj, 'scrollYMarginOffset', 5 );\n        fn( obj, 'scrollXMarginOffset', 5 );\n        if( obj.preventXScroll ){\n            obj.preventHorizontal = true; \n        }\n        if( obj.preventYScroll ){\n            obj.preventVertical = true;\n        }\n        var elements = this,\n        is_parent = obj.appendTo == \"parent\";\n\n        for( var i = 0; i < elements.length; i++ ) {\n            var elem =  elements[ i ], vertDiv, horiDiv, wrp = elem.parentElement;\n            is_parent && set( wrp, 'position', 'relative' );\n            if( elem._scrollData ) {\n                $L( elem ).removeScroll()\n            }\n            elem.resetScrollbar = mouseenter.bind( elements[ i ] );\n            is_parent && ( wrp._scrolldiv = elem );\n            elem._scrollData = obj;\n            if( !obj.preventVertical ) {\n                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerY', obj, void 0, is_parent );\n                if(obj.verticalPosition == 'left'){\n                    vertDiv.classList.add('left');\n                }\n            }\n            if( !obj.preventHorizontal ) {\n                vertDiv = appendDiv.call( elem, 'lyteScrollContainer lyteScrollContainerX', obj, true, is_parent );\n                if(obj.horizontalPosition == 'top'){\n                    vertDiv.classList.add('top');\n                }\n            }\n            if(isSaf.firefox ){\n                elem.scrollLeft = 0;\n                elem.scrollTop = 0;\n            } \n            elem.addEventListener( 'mouseenter', mouseenter, true )\n            elem.addEventListener( 'touchstart', mouseenter, true )\n            elem.addEventListener( 'touchmove', wheelEvent, { passive : false } )\n            elem.addEventListener( 'mousedown', mousedown );\n            elem.addEventListener( 'wheel', initialWheel, true );\n            \n            if( obj.showOn != 'always' ){\n                ( is_parent ? wrp : elem ).addEventListener( 'mouseleave', mouseleave, true )\n            } else {\n                setTimeout( mouseenter.bind( elem ), 100, {} )\n            }\n\n            elem.classList.add( 'lyteScrollBar' )\n            elem._scrollFun = scroll;\n        }\n      return this;\n    }\n\n    $L.prototype.destroyLyteScroll = function(){\n        // console.warn( 'destroyLyteScroll deprecated. Use scroll(\"destroyScroll\") instead' );\n        return destroy.call( this );  \n    }\n\n    $L.prototype.resetScrollbar = function(){\n        // console.warn( 'resetScrollbar deprecated. Use scroll(\"reset\") instead' );\n        return reset.call( this );\n    }\n\n    function globalscroll( evt ){\n        var el = evt.target.correspondingElement || evt.target;\n        if( el != document && el != document.body && el._scrollFun ) {\n            el._scrollFun.call( el, evt );\n        }\n        if( evt._byFunc ) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            evt.stopImmediatePropagation();\n        }\n    }\n    window.addEventListener('scroll', globalscroll, true ); \n   }\n} );"],"names":[],"sourceRoot":""}